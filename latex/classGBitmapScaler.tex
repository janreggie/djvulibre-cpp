\hypertarget{classGBitmapScaler}{}\doxysection{G\+Bitmap\+Scaler Class Reference}
\label{classGBitmapScaler}\index{GBitmapScaler@{GBitmapScaler}}


{\ttfamily \#include $<$G\+Scaler.\+h$>$}



Inheritance diagram for G\+Bitmap\+Scaler\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=169pt]{classGBitmapScaler__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for G\+Bitmap\+Scaler\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=348pt]{classGBitmapScaler__coll__graph}
\end{center}
\end{figure}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classGBitmapScaler_a07eea8e84df217aa090304ee8a0cdb7d}\label{classGBitmapScaler_a07eea8e84df217aa090304ee8a0cdb7d}} 
virtual \mbox{\hyperlink{classGBitmapScaler_a07eea8e84df217aa090304ee8a0cdb7d}{$\sim$\+G\+Bitmap\+Scaler}} ()
\begin{DoxyCompactList}\small\item\em Virtual destructor. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classGBitmapScaler_a2bd97c3bef55e39d014c8b5868b3d980}{scale}} (const \mbox{\hyperlink{classGRect}{G\+Rect}} \&provided\+\_\+input, const \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} \&input, const \mbox{\hyperlink{classGRect}{G\+Rect}} \&desired\+\_\+output, \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} \&output)
\end{DoxyCompactItemize}
\doxysubsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \mbox{\hyperlink{classGP}{GP}}$<$ \mbox{\hyperlink{classGBitmapScaler}{G\+Bitmap\+Scaler}} $>$ \mbox{\hyperlink{classGBitmapScaler_a432506d2b590f7ac77ab7f3cf3a6a9c4}{create}} (void)
\item 
static \mbox{\hyperlink{classGP}{GP}}$<$ \mbox{\hyperlink{classGBitmapScaler}{G\+Bitmap\+Scaler}} $>$ \mbox{\hyperlink{classGBitmapScaler_ae8e316e85a1fd27860df557b89838214}{create}} (const int inw, const int inh, const int outw, const int outh)
\end{DoxyCompactItemize}
\doxysubsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classGBitmapScaler_ac97393c3214c410aa3f00965a041da0e}\label{classGBitmapScaler_ac97393c3214c410aa3f00965a041da0e}} 
{\bfseries G\+Bitmap\+Scaler} (int inw, int inh, int outw, int outh)
\item 
\mbox{\Hypertarget{classGBitmapScaler_a6094cd5a00fe28fcc56cd34f5295aea8}\label{classGBitmapScaler_a6094cd5a00fe28fcc56cd34f5295aea8}} 
unsigned char $\ast$ {\bfseries get\+\_\+line} (int, const \mbox{\hyperlink{classGRect}{G\+Rect}} \&, const \mbox{\hyperlink{classGRect}{G\+Rect}} \&, const \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} \&)
\end{DoxyCompactItemize}
\doxysubsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classGBitmapScaler_acfd1ca0d52c9b59b882bbadaf7e1cd8d}\label{classGBitmapScaler_acfd1ca0d52c9b59b882bbadaf7e1cd8d}} 
unsigned char $\ast$ {\bfseries lbuffer}
\item 
\mbox{\Hypertarget{classGBitmapScaler_a655198bca1ae548b8dd2f696d23bbc5b}\label{classGBitmapScaler_a655198bca1ae548b8dd2f696d23bbc5b}} 
\mbox{\hyperlink{classGPBuffer}{G\+P\+Buffer}}$<$ unsigned char $>$ {\bfseries glbuffer}
\item 
\mbox{\Hypertarget{classGBitmapScaler_ac367198e11970119e2dace0f772e5d47}\label{classGBitmapScaler_ac367198e11970119e2dace0f772e5d47}} 
unsigned char $\ast$ {\bfseries conv}
\item 
\mbox{\Hypertarget{classGBitmapScaler_a51ddbafd8ed9f581f62fc01e69151e68}\label{classGBitmapScaler_a51ddbafd8ed9f581f62fc01e69151e68}} 
\mbox{\hyperlink{classGPBuffer}{G\+P\+Buffer}}$<$ unsigned char $>$ {\bfseries gconv}
\item 
\mbox{\Hypertarget{classGBitmapScaler_a75fdc4ced9aab99a8698c8e3afe0bf42}\label{classGBitmapScaler_a75fdc4ced9aab99a8698c8e3afe0bf42}} 
unsigned char $\ast$ {\bfseries p1}
\item 
\mbox{\Hypertarget{classGBitmapScaler_ae190388d56a4783d27135c36154857d7}\label{classGBitmapScaler_ae190388d56a4783d27135c36154857d7}} 
\mbox{\hyperlink{classGPBuffer}{G\+P\+Buffer}}$<$ unsigned char $>$ {\bfseries gp1}
\item 
\mbox{\Hypertarget{classGBitmapScaler_a8a917f0b00fb53fdce3ecd93609b0ba0}\label{classGBitmapScaler_a8a917f0b00fb53fdce3ecd93609b0ba0}} 
unsigned char $\ast$ {\bfseries p2}
\item 
\mbox{\Hypertarget{classGBitmapScaler_ac8d4de9ecb02df54ad9ca8bf327aa822}\label{classGBitmapScaler_ac8d4de9ecb02df54ad9ca8bf327aa822}} 
\mbox{\hyperlink{classGPBuffer}{G\+P\+Buffer}}$<$ unsigned char $>$ {\bfseries gp2}
\item 
\mbox{\Hypertarget{classGBitmapScaler_a105551656c2641173e6d8ece7d0cbb31}\label{classGBitmapScaler_a105551656c2641173e6d8ece7d0cbb31}} 
int {\bfseries l1}
\item 
\mbox{\Hypertarget{classGBitmapScaler_a04114418ba2bb5263b0252591b36fead}\label{classGBitmapScaler_a04114418ba2bb5263b0252591b36fead}} 
int {\bfseries l2}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Fast rescaling code for gray level images. This class augments the base class \textbackslash{}\+Ref\{\mbox{\hyperlink{classGScaler}{G\+Scaler}}\} with a function for rescaling gray level images. Function \textbackslash{}\+Ref\{\mbox{\hyperlink{classGBitmapScaler_a2bd97c3bef55e39d014c8b5868b3d980}{G\+Bitmap\+Scaler\+::scale}}\} computes an arbitrary segment of the output image given the corresponding pixels in the input image.

\{\textbackslash{}bf Example\} --- The following functions returns an gray level image (sixteen gray levels, size \#nw\# by \#nh\#) containing a rescaled version of the input image \#in\#. \textbackslash{}begin\{verbatim\} \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} $\ast$rescale\+\_\+bitmap(const \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} \&in, int nw, int nh) \{ int w = in.\+columns(); // Get input width int h = in.\+raws(); // Get output width \mbox{\hyperlink{classGBitmapScaler}{G\+Bitmap\+Scaler}} scaler(w,h,nw,nh); // Creates bitmap scaler \mbox{\hyperlink{classGRect}{G\+Rect}} desired(0,0,nw,nh); // Desired output = complete bitmap \mbox{\hyperlink{classGRect}{G\+Rect}} provided(0,0,w,h); // Provided input = complete bitmap \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} $\ast$out = new \mbox{\hyperlink{classGBitmap}{G\+Bitmap}}; scaler.\+scale(provided, in, desired, $\ast$out); // Rescale out-\/$>$change\+\_\+grays(16); // Reduce to 16 gray levels return out; \} \textbackslash{}end\{verbatim\} 

\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{classGBitmapScaler_ae8e316e85a1fd27860df557b89838214}\label{classGBitmapScaler_ae8e316e85a1fd27860df557b89838214}} 
\index{GBitmapScaler@{GBitmapScaler}!create@{create}}
\index{create@{create}!GBitmapScaler@{GBitmapScaler}}
\doxysubsubsection{\texorpdfstring{create()}{create()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classGP}{GP}}$<$\mbox{\hyperlink{classGBitmapScaler}{G\+Bitmap\+Scaler}}$>$ G\+Bitmap\+Scaler\+::create (\begin{DoxyParamCaption}\item[{const int}]{inw,  }\item[{const int}]{inh,  }\item[{const int}]{outw,  }\item[{const int}]{outh }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}

Creates a \mbox{\hyperlink{classGBitmapScaler}{G\+Bitmap\+Scaler}}. The size of the input image is given by \#inw\# and \#inh\#. This function internally calls \textbackslash{}\+Ref\{\mbox{\hyperlink{classGScaler_a778e8d3e07b23ccd5fc335c10a5af30c}{G\+Scaler\+::set\+\_\+input\+\_\+size}}\} and \textbackslash{}\+Ref\{\mbox{\hyperlink{classGScaler_afe49c265810cd581d1974ef0cc50079c}{G\+Scaler\+::set\+\_\+output\+\_\+size}}\}. The size of the output image is given by \#outw\# and \#outh\#. . \mbox{\Hypertarget{classGBitmapScaler_a432506d2b590f7ac77ab7f3cf3a6a9c4}\label{classGBitmapScaler_a432506d2b590f7ac77ab7f3cf3a6a9c4}} 
\index{GBitmapScaler@{GBitmapScaler}!create@{create}}
\index{create@{create}!GBitmapScaler@{GBitmapScaler}}
\doxysubsubsection{\texorpdfstring{create()}{create()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classGP}{GP}}$<$\mbox{\hyperlink{classGBitmapScaler}{G\+Bitmap\+Scaler}}$>$ G\+Bitmap\+Scaler\+::create (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}

Creates an empty \mbox{\hyperlink{classGBitmapScaler}{G\+Bitmap\+Scaler}}. You must call functions \textbackslash{}\+Ref\{\mbox{\hyperlink{classGScaler_a778e8d3e07b23ccd5fc335c10a5af30c}{G\+Scaler\+::set\+\_\+input\+\_\+size}}\} and \textbackslash{}\+Ref\{\mbox{\hyperlink{classGScaler_afe49c265810cd581d1974ef0cc50079c}{G\+Scaler\+::set\+\_\+output\+\_\+size}}\} before calling any of the scaling functions. \mbox{\Hypertarget{classGBitmapScaler_a2bd97c3bef55e39d014c8b5868b3d980}\label{classGBitmapScaler_a2bd97c3bef55e39d014c8b5868b3d980}} 
\index{GBitmapScaler@{GBitmapScaler}!scale@{scale}}
\index{scale@{scale}!GBitmapScaler@{GBitmapScaler}}
\doxysubsubsection{\texorpdfstring{scale()}{scale()}}
{\footnotesize\ttfamily void G\+Bitmap\+Scaler\+::scale (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classGRect}{G\+Rect}} \&}]{provided\+\_\+input,  }\item[{const \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} \&}]{input,  }\item[{const \mbox{\hyperlink{classGRect}{G\+Rect}} \&}]{desired\+\_\+output,  }\item[{\mbox{\hyperlink{classGBitmap}{G\+Bitmap}} \&}]{output }\end{DoxyParamCaption})}

Computes a segment of the rescaled output image. The \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} object \#output\# is overwritten with the segment of the output image specified by the rectangle \#desired\+\_\+output\#. The rectangle \#provided\+\_\+input\# specifies which segment of the input image is provided by the \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} object \#input\#. An exception \textbackslash{}\+Ref\{\mbox{\hyperlink{classGException}{G\+Exception}}\} is thrown if the rectangle \#provided\+\_\+input\# is smaller then the rectangle \#required\+\_\+input\# returned by function \textbackslash{}\+Ref\{\mbox{\hyperlink{classGScaler_a065a024ed262724d7ce01205655c4b18}{G\+Scaler\+::get\+\_\+input\+\_\+rect}}\}. Note that the output image always contain 256 gray levels. You may want to use function \textbackslash{}\+Ref\{\mbox{\hyperlink{classGBitmap_a0bd82b9d6776bd0aed1b8fcc8258ed7e}{G\+Bitmap\+::change\+\_\+grays}}\} to reduce the number of gray levels. 

The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
libdjvu/G\+Scaler.\+h\item 
libdjvu/G\+Scaler.\+cpp\end{DoxyCompactItemize}
