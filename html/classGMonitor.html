<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: GMonitor Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classGMonitor-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">GMonitor Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="GThreads_8h_source.html">GThreads.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for GMonitor:</div>
<div class="dyncontent">
<div class="center"><img src="classGMonitor__inherit__graph.png" border="0" usemap="#GMonitor_inherit__map" alt="Inheritance graph"/></div>
<map name="GMonitor_inherit__map" id="GMonitor_inherit__map">
<area shape="rect" title=" " alt="" coords="150,5,233,32"/>
<area shape="rect" href="classGCriticalSection.html" title=" " alt="" coords="5,80,132,107"/>
<area shape="rect" href="classGEvent.html" title=" " alt="" coords="157,80,226,107"/>
<area shape="rect" href="classGSafeFlags.html" title=" " alt="" coords="250,80,346,107"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a751db0f5dcbb979d13e13e7bc354631d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGMonitor.html#a751db0f5dcbb979d13e13e7bc354631d">enter</a> ()</td></tr>
<tr class="separator:a751db0f5dcbb979d13e13e7bc354631d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad455cde2dfca233ef99ac9aaff70954d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGMonitor.html#ad455cde2dfca233ef99ac9aaff70954d">leave</a> ()</td></tr>
<tr class="separator:ad455cde2dfca233ef99ac9aaff70954d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a835950c9bcf04e711351d2fba0ce694e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGMonitor.html#a835950c9bcf04e711351d2fba0ce694e">wait</a> ()</td></tr>
<tr class="separator:a835950c9bcf04e711351d2fba0ce694e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a692188e207d01aeeee050384d6889e89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGMonitor.html#a692188e207d01aeeee050384d6889e89">wait</a> (unsigned long timeout)</td></tr>
<tr class="separator:a692188e207d01aeeee050384d6889e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab59e35bfcc98eda3bc28cba39cf9fe4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGMonitor.html#ab59e35bfcc98eda3bc28cba39cf9fe4a">signal</a> ()</td></tr>
<tr class="separator:ab59e35bfcc98eda3bc28cba39cf9fe4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a244b089a48d162efe1a786f79e9f1343"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGMonitor.html#a244b089a48d162efe1a786f79e9f1343">broadcast</a> ()</td></tr>
<tr class="separator:a244b089a48d162efe1a786f79e9f1343"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Monitor class. Monitors have been first described in (C.A.R Hoare, Communications of the ACM, 17(10), 1974). This mechanism provides the basic mutual exclusion (mutex) and thread notification facilities (condition variables).</p>
<p>Only one thread can own the monitor at a given time. Functions \Ref{enter} and \Ref{leave} can be used to acquire and release the monitor. This mutual exclusion provides an efficient way to protect segment of codes ({<em>critical</em> sections}) which should not be simultaneously executed by two threads. <a class="el" href="structClass.html">Class</a> \Ref{<a class="el" href="classGMonitorLock.html">GMonitorLock</a>} provides a convenient way to do this effectively.</p>
<p>When the thread owning the monitor calls function \Ref{wait}, the monitor is released and the thread starts waiting until another thread calls function \Ref{signal} or \Ref{broadcast}. When the thread wakes-up, it re-acquires the monitor and function <a class="el" href="classGMonitor.html#a835950c9bcf04e711351d2fba0ce694e">wait</a># returns. Since the signaling thread must acquire the monitor before calling functions <a class="el" href="classGMonitor.html#ab59e35bfcc98eda3bc28cba39cf9fe4a">signal</a># and <a class="el" href="classGMonitor.html#a244b089a48d162efe1a786f79e9f1343">broadcast</a>#, the signaled thread will not be able to re-acquire the monitor until the signaling thread(s) releases the monitor.</p>
<p>{\bf Note} &mdash; Both the copy constructor and the copy operator are declared as private members. It is therefore not possible to make multiple copies of instances of this class, as implied by the class semantic. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a244b089a48d162efe1a786f79e9f1343"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a244b089a48d162efe1a786f79e9f1343">&#9670;&nbsp;</a></span>broadcast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GMonitor::broadcast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Signals all waiting threads. Function <a class="el" href="classGMonitor.html#a244b089a48d162efe1a786f79e9f1343">broadcast</a># wakes up all the waiting threads for this monitor. An exception is thrown if this function is called by a thread which does not own the monitor. </p>

</div>
</div>
<a id="a751db0f5dcbb979d13e13e7bc354631d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a751db0f5dcbb979d13e13e7bc354631d">&#9670;&nbsp;</a></span>enter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GMonitor::enter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enters the monitor. If the monitor is acquired by another thread this function waits until the monitor is released. The current thread then acquires the monitor. Calls to <a class="el" href="classGMonitor.html#a751db0f5dcbb979d13e13e7bc354631d">enter</a># and <a class="el" href="classGMonitor.html#ad455cde2dfca233ef99ac9aaff70954d">leave</a># may be nested. </p>

</div>
</div>
<a id="ad455cde2dfca233ef99ac9aaff70954d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad455cde2dfca233ef99ac9aaff70954d">&#9670;&nbsp;</a></span>leave()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GMonitor::leave </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Leaves the monitor. The monitor counts how many times the current thread has entered the monitor. Function <a class="el" href="classGMonitor.html#ad455cde2dfca233ef99ac9aaff70954d">leave</a># decrement this count. The monitor is released when this count reaches zero. An exception is thrown if this function is called by a thread which does not own the monitor. </p>

</div>
</div>
<a id="ab59e35bfcc98eda3bc28cba39cf9fe4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab59e35bfcc98eda3bc28cba39cf9fe4a">&#9670;&nbsp;</a></span>signal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GMonitor::signal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Signals one waiting thread. Function <a class="el" href="classGMonitor.html#ab59e35bfcc98eda3bc28cba39cf9fe4a">signal</a># wakes up at most one of the waiting threads for this monitor. An exception is thrown if this function is called by a thread which does not own the monitor. </p>

</div>
</div>
<a id="a835950c9bcf04e711351d2fba0ce694e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a835950c9bcf04e711351d2fba0ce694e">&#9670;&nbsp;</a></span>wait() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GMonitor::wait </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Waits until the monitor is signaled. The current thread atomically releases the monitor and waits until another thread calls function <a class="el" href="classGMonitor.html#ab59e35bfcc98eda3bc28cba39cf9fe4a">signal</a># or <a class="el" href="classGMonitor.html#a244b089a48d162efe1a786f79e9f1343">broadcast</a>#. Function <a class="el" href="classGMonitor.html#a835950c9bcf04e711351d2fba0ce694e">wait</a># then re-acquires the monitor and returns. An exception is thrown if this function is called by a thread which does not own the monitor. </p>

</div>
</div>
<a id="a692188e207d01aeeee050384d6889e89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a692188e207d01aeeee050384d6889e89">&#9670;&nbsp;</a></span>wait() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GMonitor::wait </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Waits until the monitor is signaled or a timeout is reached. The current thread atomically releases the monitor and waits until another thread calls function <a class="el" href="classGMonitor.html#ab59e35bfcc98eda3bc28cba39cf9fe4a">signal</a># or <a class="el" href="classGMonitor.html#a244b089a48d162efe1a786f79e9f1343">broadcast</a># or a maximum of #timeout# milliseconds. Function <a class="el" href="classGMonitor.html#a835950c9bcf04e711351d2fba0ce694e">wait</a># then re-acquires the monitor and returns. An exception is thrown if this function is called by a thread which does not own the monitor. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>libdjvu/<a class="el" href="GThreads_8h_source.html">GThreads.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
