<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: DataPool Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="classDataPool-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">DataPool Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="DataPool_8h_source.html">DataPool.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for DataPool:</div>
<div class="dyncontent">
<div class="center"><img src="classDataPool__inherit__graph.png" border="0" usemap="#DataPool_inherit__map" alt="Inheritance graph"/></div>
<map name="DataPool_inherit__map" id="DataPool_inherit__map">
<area shape="rect" title=" " alt="" coords="11,80,92,107"/>
<area shape="rect" href="classGPEnabled.html" title=" " alt="" coords="5,5,97,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for DataPool:</div>
<div class="dyncontent">
<div class="center"><img src="classDataPool__coll__graph.png" border="0" usemap="#DataPool_coll__map" alt="Collaboration graph"/></div>
<map name="DataPool_coll__map" id="DataPool_coll__map">
<area shape="rect" title=" " alt="" coords="11,80,92,107"/>
<area shape="rect" href="classGPEnabled.html" title=" " alt="" coords="5,5,97,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPool_1_1BlockList.html">BlockList</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPool_1_1Counter.html">Counter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPool_1_1Incrementor.html">Incrementor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPool_1_1OpenFiles.html">OpenFiles</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPool_1_1OpenFiles__File.html">OpenFiles_File</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPool_1_1Reader.html">Reader</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPool_1_1Trigger.html">Trigger</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Adding data.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Please note, that these functions are for not connected #DataPool#s only. You can not add data to a <a class="el" href="classDataPool.html">DataPool</a>#, which is connected to another <a class="el" href="classDataPool.html">DataPool</a># or to a file. </p>
</div></td></tr>
<tr class="memitem:aa6e5617eb145d85224e19511c6ffe83e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPool.html#aa6e5617eb145d85224e19511c6ffe83e">add_data</a> (const void *buffer, int size)</td></tr>
<tr class="separator:aa6e5617eb145d85224e19511c6ffe83e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fb011a3561c2e2ed664dcb23e790cb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPool.html#a3fb011a3561c2e2ed664dcb23e790cb6">add_data</a> (const void *buffer, int offset, int size)</td></tr>
<tr class="separator:a3fb011a3561c2e2ed664dcb23e790cb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5028bb28c326c25f0d6b3218b0367b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPool.html#ae5028bb28c326c25f0d6b3218b0367b8">set_eof</a> (void)</td></tr>
<tr class="separator:ae5028bb28c326c25f0d6b3218b0367b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Accessing data.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These functions provide direct and sequential access to the data of the <a class="el" href="classDataPool.html">DataPool</a>#. If the <a class="el" href="classDataPool.html">DataPool</a># is not connected (contains some real data) then it handles the requests itself. Otherwise they are forwarded to the master <a class="el" href="classDataPool.html">DataPool</a># or the file. </p>
</div></td></tr>
<tr class="memitem:a22152069e78754b7b878c3980378c574"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPool.html#a22152069e78754b7b878c3980378c574">get_data</a> (void *buffer, int offset, int size)</td></tr>
<tr class="separator:a22152069e78754b7b878c3980378c574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b9c871c9125cc0bfd252a04c35ca90e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGP.html">GP</a>&lt; <a class="el" href="classByteStream.html">ByteStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPool.html#a3b9c871c9125cc0bfd252a04c35ca90e">get_stream</a> (void)</td></tr>
<tr class="separator:a3b9c871c9125cc0bfd252a04c35ca90e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">State querying functions.</div></td></tr>
<tr class="memitem:a0a939a560f83bcfbaf9a1aa3ff766294"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPool.html#a0a939a560f83bcfbaf9a1aa3ff766294">is_connected</a> (void) const</td></tr>
<tr class="separator:a0a939a560f83bcfbaf9a1aa3ff766294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78c1d25daf95259d16df37b5ea7dd667"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPool.html#a78c1d25daf95259d16df37b5ea7dd667">has_data</a> (int start, int length)</td></tr>
<tr class="separator:a78c1d25daf95259d16df37b5ea7dd667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a019975772d57f62cc3969c4f9fac7928"><td class="memItemLeft" align="right" valign="top"><a id="a019975772d57f62cc3969c4f9fac7928"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_eof</b> (void) const</td></tr>
<tr class="separator:a019975772d57f62cc3969c4f9fac7928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc6b66d1b2e72448a31a21a82cf7b7d6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPool.html#abc6b66d1b2e72448a31a21a82cf7b7d6">get_length</a> (void) const</td></tr>
<tr class="separator:abc6b66d1b2e72448a31a21a82cf7b7d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3598836ed10e1d5ce0742c680bd091b2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPool.html#a3598836ed10e1d5ce0742c680bd091b2">get_size</a> (void) const</td></tr>
<tr class="separator:a3598836ed10e1d5ce0742c680bd091b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classGPEnabled"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classGPEnabled')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classGPEnabled.html">GPEnabled</a></td></tr>
<tr class="memitem:a9e5f12f17477e448d1fc08e37cb9d2dd inherit pub_methods_classGPEnabled"><td class="memItemLeft" align="right" valign="top"><a id="a9e5f12f17477e448d1fc08e37cb9d2dd"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGPEnabled.html#a9e5f12f17477e448d1fc08e37cb9d2dd">~GPEnabled</a> ()</td></tr>
<tr class="memdesc:a9e5f12f17477e448d1fc08e37cb9d2dd inherit pub_methods_classGPEnabled"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual destructor. <br /></td></tr>
<tr class="separator:a9e5f12f17477e448d1fc08e37cb9d2dd inherit pub_methods_classGPEnabled"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af197d1b7ec283031880818fd05fdd2f9 inherit pub_methods_classGPEnabled"><td class="memItemLeft" align="right" valign="top"><a id="af197d1b7ec283031880818fd05fdd2f9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGPEnabled.html#af197d1b7ec283031880818fd05fdd2f9">GPEnabled</a> ()</td></tr>
<tr class="memdesc:af197d1b7ec283031880818fd05fdd2f9 inherit pub_methods_classGPEnabled"><td class="mdescLeft">&#160;</td><td class="mdescRight">Null constructor. <br /></td></tr>
<tr class="separator:af197d1b7ec283031880818fd05fdd2f9 inherit pub_methods_classGPEnabled"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2875b20558241302927c11dea068b6a inherit pub_methods_classGPEnabled"><td class="memItemLeft" align="right" valign="top"><a id="ae2875b20558241302927c11dea068b6a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGPEnabled.html#ae2875b20558241302927c11dea068b6a">GPEnabled</a> (const <a class="el" href="classGPEnabled.html">GPEnabled</a> &amp;obj)</td></tr>
<tr class="memdesc:ae2875b20558241302927c11dea068b6a inherit pub_methods_classGPEnabled"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy construcotr. <br /></td></tr>
<tr class="separator:ae2875b20558241302927c11dea068b6a inherit pub_methods_classGPEnabled"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4604c98eff7df30c6071bacdbc6693aa inherit pub_methods_classGPEnabled"><td class="memItemLeft" align="right" valign="top"><a id="a4604c98eff7df30c6071bacdbc6693aa"></a>
<a class="el" href="classGPEnabled.html">GPEnabled</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGPEnabled.html#a4604c98eff7df30c6071bacdbc6693aa">operator=</a> (const <a class="el" href="classGPEnabled.html">GPEnabled</a> &amp;obj)</td></tr>
<tr class="memdesc:a4604c98eff7df30c6071bacdbc6693aa inherit pub_methods_classGPEnabled"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy operator. <br /></td></tr>
<tr class="separator:a4604c98eff7df30c6071bacdbc6693aa inherit pub_methods_classGPEnabled"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff96ec9203073e902735c5b6b1f650a0 inherit pub_methods_classGPEnabled"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGPEnabled.html#aff96ec9203073e902735c5b6b1f650a0">get_count</a> (void) const</td></tr>
<tr class="separator:aff96ec9203073e902735c5b6b1f650a0 inherit pub_methods_classGPEnabled"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Initialization</h2></td></tr>
<tr class="memitem:a67d18971f64052b1404914f862118dbd"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGP.html">GP</a>&lt; <a class="el" href="classDataPool.html">DataPool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPool.html#a67d18971f64052b1404914f862118dbd">create</a> (void)</td></tr>
<tr class="separator:a67d18971f64052b1404914f862118dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a580fcf30fbf781a922a58c1887ed4ffb"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGP.html">GP</a>&lt; <a class="el" href="classDataPool.html">DataPool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPool.html#a580fcf30fbf781a922a58c1887ed4ffb">create</a> (const <a class="el" href="classGP.html">GP</a>&lt; <a class="el" href="classByteStream.html">ByteStream</a> &gt; &amp;str)</td></tr>
<tr class="separator:a580fcf30fbf781a922a58c1887ed4ffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f06da78a43575a065183ea0a37c8dbc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGP.html">GP</a>&lt; <a class="el" href="classDataPool.html">DataPool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPool.html#a1f06da78a43575a065183ea0a37c8dbc">create</a> (const <a class="el" href="classGP.html">GP</a>&lt; <a class="el" href="classDataPool.html">DataPool</a> &gt; &amp;master_pool, int start=0, int length=-1)</td></tr>
<tr class="separator:a1f06da78a43575a065183ea0a37c8dbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6fc2d3bb6b68f9719aa1db01caa694d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGP.html">GP</a>&lt; <a class="el" href="classDataPool.html">DataPool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPool.html#aa6fc2d3bb6b68f9719aa1db01caa694d">create</a> (const <a class="el" href="classGURL.html">GURL</a> &amp;url, int start=0, int length=-1)</td></tr>
<tr class="separator:aa6fc2d3bb6b68f9719aa1db01caa694d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6450f268cabe687dfde1525ecbf73c20"><td class="memItemLeft" align="right" valign="top"><a id="a6450f268cabe687dfde1525ecbf73c20"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~DataPool</b> ()</td></tr>
<tr class="separator:a6450f268cabe687dfde1525ecbf73c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae27873d7b46ce204166bb0f51a70d8d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPool.html#ae27873d7b46ce204166bb0f51a70d8d2">connect</a> (const <a class="el" href="classGP.html">GP</a>&lt; <a class="el" href="classDataPool.html">DataPool</a> &gt; &amp;master_pool, int start=0, int length=-1)</td></tr>
<tr class="separator:ae27873d7b46ce204166bb0f51a70d8d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63961e55936b1db28c8b3f2cf87c9906"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPool.html#a63961e55936b1db28c8b3f2cf87c9906">connect</a> (const <a class="el" href="classGURL.html">GURL</a> &amp;url, int start=0, int length=-1)</td></tr>
<tr class="separator:a63961e55936b1db28c8b3f2cf87c9906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d36a05eca714362333f305571834292"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPool.html#a4d36a05eca714362333f305571834292">stop</a> (bool only_blocked=false)</td></tr>
<tr class="separator:a4d36a05eca714362333f305571834292"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Trigger callbacks.</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpf326a7f10aa9ed71a61394610d8045a6"></a>{<em><a class="el" href="classDataPool_1_1Trigger.html">Trigger</a></em> callbacks} are special callbacks called when all data for the given range of offsets has been made available. Since reading unavailable data may result in a thread block, which may be bad, the usage of {<em>trigger</em> callbacks} appears to be a convenient way to signal availability of data.</p>
<p>You can add a trigger callback in two ways: \begin{enumerate} \item By specifying a range. This is the most general case \item By providing just one {<em>threshold}</em>. In this case the range is assumed to start from offset #ZERO# and last for {<em>threshold}+1</em> bytes. \end{enumerate} </p>
</td></tr>
<tr class="memitem:a52a0e31f8e079647aaaefc2acaf34fe1"><td class="memItemLeft" align="right" valign="top"><a id="a52a0e31f8e079647aaaefc2acaf34fe1"></a>
static const char *&#160;</td><td class="memItemRight" valign="bottom"><b>Stop</b> = ERR_MSG(&quot;STOP&quot;)</td></tr>
<tr class="separator:a52a0e31f8e079647aaaefc2acaf34fe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa10ae5cad6f03fe9a1329bf33ca06137"><td class="memItemLeft" align="right" valign="top"><a id="aa10ae5cad6f03fe9a1329bf33ca06137"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>FCPools</b></td></tr>
<tr class="separator:aa10ae5cad6f03fe9a1329bf33ca06137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada575a6bbb9d148e57afcb2c202aa959"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPool.html#ada575a6bbb9d148e57afcb2c202aa959">load_file</a> (const <a class="el" href="classGURL.html">GURL</a> &amp;url)</td></tr>
<tr class="separator:ada575a6bbb9d148e57afcb2c202aa959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1c299c034b542fd4c10831c51160bed"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPool.html#ad1c299c034b542fd4c10831c51160bed">close_all</a> (void)</td></tr>
<tr class="separator:ad1c299c034b542fd4c10831c51160bed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b57f0564372c9a2bde1441cf36f18bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPool.html#a6b57f0564372c9a2bde1441cf36f18bc">add_trigger</a> (int start, int length, void(*callback)(void *), void *cl_data)</td></tr>
<tr class="separator:a6b57f0564372c9a2bde1441cf36f18bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71061d55851274bc925dccec746e5009"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPool.html#a71061d55851274bc925dccec746e5009">add_trigger</a> (int thresh, void(*callback)(void *), void *cl_data)</td></tr>
<tr class="separator:a71061d55851274bc925dccec746e5009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ea082271590ea6a234176aacb39949e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPool.html#a2ea082271590ea6a234176aacb39949e">del_trigger</a> (void(*callback)(void *), void *cl_data)</td></tr>
<tr class="separator:a2ea082271590ea6a234176aacb39949e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05c41e301aa5971f4887e89b97c358e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPool.html#a05c41e301aa5971f4887e89b97c358e8">load_file</a> (void)</td></tr>
<tr class="separator:a05c41e301aa5971f4887e89b97c358e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11576cdf27160ba1310e28c3f901a469"><td class="memItemLeft" align="right" valign="top"><a id="a11576cdf27160ba1310e28c3f901a469"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clear_stream</b> (const bool release=true)</td></tr>
<tr class="separator:a11576cdf27160ba1310e28c3f901a469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a860b0df7fd46f33a2c9b5b5fcb45a983"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPool.html#a860b0df7fd46f33a2c9b5b5fcb45a983">simple_compare</a> (<a class="el" href="classDataPool.html">DataPool</a> &amp;pool) const</td></tr>
<tr class="separator:a860b0df7fd46f33a2c9b5b5fcb45a983"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_attribs_classGPEnabled"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classGPEnabled')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classGPEnabled.html">GPEnabled</a></td></tr>
<tr class="memitem:aaeebfa533635d29cc70aaa3620678734 inherit pro_attribs_classGPEnabled"><td class="memItemLeft" align="right" valign="top"><a id="aaeebfa533635d29cc70aaa3620678734"></a>
volatile int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGPEnabled.html#aaeebfa533635d29cc70aaa3620678734">count</a></td></tr>
<tr class="memdesc:aaeebfa533635d29cc70aaa3620678734 inherit pro_attribs_classGPEnabled"><td class="mdescLeft">&#160;</td><td class="mdescRight">The reference counter. <br /></td></tr>
<tr class="separator:aaeebfa533635d29cc70aaa3620678734 inherit pro_attribs_classGPEnabled"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Thread safe data storage. The purpose of <a class="el" href="classDataPool.html">DataPool</a># is to provide a uniform interface for accessing data from decoding routines running in a multi-threaded environment. Depending on the mode of operation it may contain the actual data, may be connected to another <a class="el" href="classDataPool.html">DataPool</a># or may be mapped to a file. Regardless of the mode, the class returns data in a thread-safe way, blocking reading threads if there is no data of interest available. This blocking is especially useful in the networking environment (plugin) when there is a running decoding thread, which wants to start decoding as soon as there is just one byte available blocking if necessary.</p>
<p>Access to data in a <a class="el" href="classDataPool.html">DataPool</a># may be direct (Using \Ref{get_data}() function) or sequential (See \Ref{get_stream}() function).</p>
<p>If the <a class="el" href="classDataPool.html">DataPool</a># is not connected to anything, that is it contains some real data, this data can be added to it by means of two \Ref{add_data}() functions. One of them adds data sequentially maintaining the offset of the last block of data added by it. The other can store data anywhere. Thus it's important to realize, that there may be "white
spots" in the data storage.</p>
<p>There is also a way to test if data is available for some given data range (See \Ref{has_data}()). In addition to this mechanism, there are so-called {<em>trigger</em> callbacks}, which are called, when there is all data available for a given data range.</p>
<p>Let us consider all modes of operation in details:</p>
<p>\begin{enumerate} \item {\bf Not connected <a class="el" href="classDataPool.html">DataPool</a>#}. In this mode the <a class="el" href="classDataPool.html">DataPool</a># contains some real data. As mentioned above, it may be added <br  />
 by means of two functions \Ref{add_data}() operating independent of each other and allowing to add data sequentially and directly to any place of data storage. It's important to call function \Ref{set_eof}() after all data has been added.</p>
<p>Functions like \Ref{get_data}() or \Ref{get_stream}() can be used to obtain direct or sequential access to the data. As long as \Ref{is_eof}() is #FALSE#, <a class="el" href="classDataPool.html">DataPool</a># will block every reader, which is trying to read unavailable data until it really becomes available. But as soon as \Ref{is_eof}() is #TRUE#, any attempt to read non-existing data will read #0# bytes.</p>
<p>Taking into account the fact, that <a class="el" href="classDataPool.html">DataPool</a># was designed to store DjVu files, which are in IFF formats, it becomes possible to predict the size of the <a class="el" href="classDataPool.html">DataPool</a># as soon as the first #32# bytes have been added. This is invaluable for estimating download progress. See function \Ref{get_length}() for details. If this estimate fails (which means, that stored data is not in IFF format), \Ref{get_length}() returns #-1#.</p>
<p>Triggers may be added and removed by means of \Ref{add_trigger}() and \Ref{del_trigger}() functions. \Ref{add_trigger}() takes a data range. As soon as all data in that data range is available, the trigger callback will be called.</p>
<p>All trigger callbacks will be called when #EOF# condition has been set.</p>
<p>\item {\bf <a class="el" href="classDataPool.html">DataPool</a># connected to another <a class="el" href="classDataPool.html">DataPool</a>#}. In this {<em>slave}</em> mode you can map a given <a class="el" href="classDataPool.html">DataPool</a># to any offsets range inside another <a class="el" href="classDataPool.html">DataPool</a>#. You can connect the slave <a class="el" href="classDataPool.html">DataPool</a># even if there is no data in the master <a class="el" href="classDataPool.html">DataPool</a>#. Any \Ref{get_data}() request will be forwarded to the master <a class="el" href="classDataPool.html">DataPool</a>#, and it will be responsible for blocking readers trying to access unavailable data.</p>
<p>The usage of \Ref{add_data}() functions is prohibited for connected #DataPool#s.</p>
<p>The offsets range used to map a slave <a class="el" href="classDataPool.html">DataPool</a># can be fully specified (both start offset and length are positive numbers) or partially specified (the length is negative). In this mode the slave <a class="el" href="classDataPool.html">DataPool</a># is assumed to extend up to the end of the master <a class="el" href="classDataPool.html">DataPool</a>#.</p>
<p>Triggers may be used with slave #DataPool#s as well as with the master ones.</p>
<p>Calling \Ref{stop}() function of a slave will stop only the slave (and any other slave connected to it), but not the master.</p>
<p>\Ref{set_eof}() function is meaningless for slaves. They obtain the <a class="el" href="classByteStream.html#a6a752fb635ed48366afad0719be4ef08">ByteStream::EndOfFile</a># status from their master.</p>
<p>Depending on the offsets range passed to the constructor, \Ref{get_length}() returns different values. If the length passed to the constructor was positive, then it is returned by \Ref{get_length}() all the time. Otherwise the value returned is either #-1# if master's length is still unknown (it didn't manage to parse IFF data yet) or it is calculated as #masters_length-slave_start#.</p>
<p>\item {\bf <a class="el" href="classDataPool.html">DataPool</a># connected to a file}. This mode is quite similar to the case, when the <a class="el" href="classDataPool.html">DataPool</a># is connected to another <a class="el" href="classDataPool.html">DataPool</a>#. Similarly, the <a class="el" href="classDataPool.html">DataPool</a># stores no data inside. It just forwards all \Ref{get_data}() requests to the underlying source (a file in this case). Thus these requests will never block the reader. But they may return #0# if there is no data available at the requested offset.</p>
<p>The usage of \Ref{add_data}() functions is meaningless and is prohibited.</p>
<p>\Ref{is_eof}() function always returns #TRUE#. Thus \Ref{set_eof}() us meaningless and does nothing.</p>
<p>\Ref{get_length}() function always returns the file size.</p>
<p>Calling \Ref{stop}() function will stop this <a class="el" href="classDataPool.html">DataPool</a># and any other slave connected to it.</p>
<p><a class="el" href="classDataPool_1_1Trigger.html">Trigger</a> callbacks passed through \Ref{add_trigger}() function are called immediately.</p>
<p>This mode is useful to read and decode DjVu files without reading and storing them in full in memory. \end{enumerate} </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a3fb011a3561c2e2ed664dcb23e790cb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fb011a3561c2e2ed664dcb23e790cb6">&#9670;&nbsp;</a></span>add_data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DataPool::add_data </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stores the specified block of data at the specified offset. Like the function above this one can also unblock readers waiting for data and engage trigger callbacks. The difference is that {\bf this} function can store data anywhere.</p>
<p>{\bf Note:} After all the data has been added, it's necessary to call \Ref{set_eof}() to tell the <a class="el" href="classDataPool.html">DataPool</a># that nothing else is expected.</p>
<p>{\bf Note:} This function may not be called if the <a class="el" href="classDataPool.html">DataPool</a># has been connected to something.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>data to store </td></tr>
    <tr><td class="paramname">offset</td><td>where to store the data </td></tr>
    <tr><td class="paramname">size</td><td>length of the {<em>buffer}</em> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa6e5617eb145d85224e19511c6ffe83e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6e5617eb145d85224e19511c6ffe83e">&#9670;&nbsp;</a></span>add_data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DataPool::add_data </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Appends the new block of data to the <a class="el" href="classDataPool.html">DataPool</a>#. There are two \Ref{add_data}() functions available. One is for adding data sequentially. It keeps track of the last byte position, which has been stored {\bf by it} and always appends the next block after this position. The other \Ref{add_data}() can store data anywhere.</p>
<p>The function will unblock readers waiting for data if this data arrives with this block. It may also trigger some {<em>trigger</em> callbacks}, which may have been added by means of \Ref{add_trigger}() function.</p>
<p>{\bf Note:} After all the data has been added, it's necessary to call \Ref{set_eof}() to tell the <a class="el" href="classDataPool.html">DataPool</a># that nothing else is expected.</p>
<p>{\bf Note:} This function may not be called if the <a class="el" href="classDataPool.html">DataPool</a># has been connected to something.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>data to append </td></tr>
    <tr><td class="paramname">size</td><td>length of the {<em>buffer}</em> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6b57f0564372c9a2bde1441cf36f18bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b57f0564372c9a2bde1441cf36f18bc">&#9670;&nbsp;</a></span>add_trigger() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DataPool::add_trigger </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cl_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Associates the specified {<em>trigger</em> callback} with the given data range.</p>
<p>{\bf Note:} The callback may be called immediately if all data for the given range is already available or #EOF# is #TRUE#.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>The beginning of the range for which all data should be available </td></tr>
    <tr><td class="paramname">length</td><td>If the {<em>length}</em> is not negative then the callback will be called when there is data available for every offset from {<em>start}</em> to {<em>start+length-1}</em>. If {<em>thresh}</em> is negative, the callback is called after #EOF# condition has been set. </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call </td></tr>
    <tr><td class="paramname">cl_data</td><td>Argument to pass to the callback when it's called. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a71061d55851274bc925dccec746e5009"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71061d55851274bc925dccec746e5009">&#9670;&nbsp;</a></span>add_trigger() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DataPool::add_trigger </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thresh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cl_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Associates the specified {<em>trigger</em> callback} with the specified threshold.</p>
<p>This function is a simplified version of the function above. The callback will be called when there is data available for every offset from #0# to #thresh#, if #thresh# is positive, or when #EOF# condition has been set otherwise. </p>

</div>
</div>
<a id="ad1c299c034b542fd4c10831c51160bed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1c299c034b542fd4c10831c51160bed">&#9670;&nbsp;</a></span>close_all()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataPool::close_all </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function will remove <a class="el" href="classDataPool_1_1OpenFiles.html">OpenFiles</a> filelist. </p>

</div>
</div>
<a id="ae27873d7b46ce204166bb0f51a70d8d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae27873d7b46ce204166bb0f51a70d8d2">&#9670;&nbsp;</a></span>connect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DataPool::connect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGP.html">GP</a>&lt; <a class="el" href="classDataPool.html">DataPool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>master_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Switches the <a class="el" href="classDataPool.html">DataPool</a># to slave mode and connects it to the specified offsets range of the master <a class="el" href="classDataPool.html">DataPool</a>#. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">master_pool</td><td>Master <a class="el" href="classDataPool.html">DataPool</a># providing data for this slave </td></tr>
    <tr><td class="paramname">start</td><td>Beginning of the offsets range which the slave is mapped into </td></tr>
    <tr><td class="paramname">length</td><td>Length of the offsets range. If negative, the range is assumed to extend up to the end of the master <a class="el" href="classDataPool.html">DataPool</a>#. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a63961e55936b1db28c8b3f2cf87c9906"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63961e55936b1db28c8b3f2cf87c9906">&#9670;&nbsp;</a></span>connect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DataPool::connect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGURL.html">GURL</a> &amp;&#160;</td>
          <td class="paramname"><em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Connects the <a class="el" href="classDataPool.html">DataPool</a># to the specified offsets range of the named #url#. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">url</td><td>Name of the file to connect to. </td></tr>
    <tr><td class="paramname">start</td><td>Beginning of the offsets range which the <a class="el" href="classDataPool.html">DataPool</a># is mapped into </td></tr>
    <tr><td class="paramname">length</td><td>Length of the offsets range. If negative, the range is assumed to extend up to the end of the file. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a580fcf30fbf781a922a58c1887ed4ffb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a580fcf30fbf781a922a58c1887ed4ffb">&#9670;&nbsp;</a></span>create() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGP.html">GP</a>&lt; <a class="el" href="classDataPool.html">DataPool</a> &gt; DataPool::create </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGP.html">GP</a>&lt; <a class="el" href="classByteStream.html">ByteStream</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates and initialized the <a class="el" href="classDataPool.html">DataPool</a># with data from stream #str#. The constructor will read the stream's contents and add them to the pool using the \Ref{add_data}() function. Afterwards it will call \Ref{set_eof}() function, and no other data will be allowed to be added to the pool. </p>

</div>
</div>
<a id="a1f06da78a43575a065183ea0a37c8dbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f06da78a43575a065183ea0a37c8dbc">&#9670;&nbsp;</a></span>create() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGP.html">GP</a>&lt; <a class="el" href="classDataPool.html">DataPool</a> &gt; DataPool::create </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGP.html">GP</a>&lt; <a class="el" href="classDataPool.html">DataPool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>master_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes the <a class="el" href="classDataPool.html">DataPool</a># in slave mode and connects it to the specified offsets range of the specified master <a class="el" href="classDataPool.html">DataPool</a>#. It is equivalent to calling default constructor and function \Ref{connect}().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">master_pool</td><td>Master <a class="el" href="classDataPool.html">DataPool</a># providing data for this slave </td></tr>
    <tr><td class="paramname">start</td><td>Beginning of the offsets range which the slave is mapped into </td></tr>
    <tr><td class="paramname">length</td><td>Length of the offsets range. If negative, the range is assumed to extend up to the end of the master <a class="el" href="classDataPool.html">DataPool</a>#. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa6fc2d3bb6b68f9719aa1db01caa694d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6fc2d3bb6b68f9719aa1db01caa694d">&#9670;&nbsp;</a></span>create() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGP.html">GP</a>&lt; <a class="el" href="classDataPool.html">DataPool</a> &gt; DataPool::create </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGURL.html">GURL</a> &amp;&#160;</td>
          <td class="paramname"><em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes the <a class="el" href="classDataPool.html">DataPool</a># in slave mode and connects it to the specified offsets range of the specified file. It is equivalent to calling default constructor and function \Ref{connect}(). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">url</td><td>Name of the file to connect to. </td></tr>
    <tr><td class="paramname">start</td><td>Beginning of the offsets range which the <a class="el" href="classDataPool.html">DataPool</a># is mapped into </td></tr>
    <tr><td class="paramname">length</td><td>Length of the offsets range. If negative, the range is assumed to extend up to the end of the file. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a67d18971f64052b1404914f862118dbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67d18971f64052b1404914f862118dbd">&#9670;&nbsp;</a></span>create() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGP.html">GP</a>&lt;<a class="el" href="classDataPool.html">DataPool</a>&gt; DataPool::create </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Default creator. Will prepare <a class="el" href="classDataPool.html">DataPool</a># for accepting data added through functions \Ref{add_data}(). Use \Ref{connect}() functions if you want to map this <a class="el" href="classDataPool.html">DataPool</a># to another or to a file. </p>

</div>
</div>
<a id="a2ea082271590ea6a234176aacb39949e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ea082271590ea6a234176aacb39949e">&#9670;&nbsp;</a></span>del_trigger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DataPool::del_trigger </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cl_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use this function to unregister callbacks, which are no longer needed. {\bf Note!} It's important to do it when the client is about to be destroyed. </p>

</div>
</div>
<a id="a22152069e78754b7b878c3980378c574"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22152069e78754b7b878c3980378c574">&#9670;&nbsp;</a></span>get_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int DataPool::get_data </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Attempts to return a block of data at the given #offset# of the given #size#.</p>
<p>\begin{enumerate} \item If the <a class="el" href="classDataPool.html">DataPool</a># is connected to another <a class="el" href="classDataPool.html">DataPool</a># or to a file, the request will just be forwarded to them. \item If the <a class="el" href="classDataPool.html">DataPool</a># is not connected to anything and some of the data requested is in the internal buffer, the function copies available data to #buffer# and returns immediately.</p>
<p>If there is no data available, and \Ref{is_eof}() returns #FALSE#, the reader (and the thread) will be {\bf blocked} until the data actually arrives. Please note, that since the reader is blocked, it should run in a separate thread so that other threads have a chance to call \Ref{add_data}(). If there is no data available, but \Ref{is_eof}() is #TRUE# the behavior is different and depends on the <a class="el" href="classDataPool.html">DataPool</a>#'s estimate of the file size: \begin{itemize} \item If <a class="el" href="classDataPool.html">DataPool</a># learns from the IFF structure of the data, that its size should be greater than it really is, then any attempt to read non-existing data in the range of {<em>valid}</em> offsets will result in an <a class="el" href="classByteStream.html#a6a752fb635ed48366afad0719be4ef08">ByteStream::EndOfFile</a># exception. This is done to indicate, that there was an error in adding data, and the data requested is {\bf supposed} to be there, but has actually not been added. \item If <a class="el" href="classDataPool.html">DataPool</a>#'s expectations about the data size coincide with the reality then any attempt to read data beyond the legal range of offsets will result in #ZERO# bytes returned. \end{itemize}. \end{enumerate}.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>Buffer to be filled with data </td></tr>
    <tr><td class="paramname">offset</td><td>Offset in the <a class="el" href="classDataPool.html">DataPool</a># to read data at </td></tr>
    <tr><td class="paramname">size</td><td>Size of the {<em>buffer}</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes actually read </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">STOP</td><td>The stream has been stopped </td></tr>
    <tr><td class="paramname">EOF</td><td>The requested data is not there and will not be added, although it should have been. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abc6b66d1b2e72448a31a21a82cf7b7d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc6b66d1b2e72448a31a21a82cf7b7d6">&#9670;&nbsp;</a></span>get_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int DataPool::get_length </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the {<em>length}</em> of data in the <a class="el" href="classDataPool.html">DataPool</a>#. The value returned depends on the mode of operation: \begin{itemize} \item If the <a class="el" href="classDataPool.html">DataPool</a># is not connected to anything then the length returned is either calculated by interpreting the IFF structure of stored data (if successful) or by calculating the real size of data after \Ref{set_eof}() has been called. Otherwise it is #-1#. \item If the <a class="el" href="classDataPool.html">DataPool</a># is connected to a file, the length is calculated basing on the length passed to the \Ref{connect}() function and the file size. \item If the <a class="el" href="classDataPool.html">DataPool</a># is connected to a master <a class="el" href="classDataPool.html">DataPool</a>#, the length is calculated basing on the value returned by the master's <a class="el" href="classDataPool.html#abc6b66d1b2e72448a31a21a82cf7b7d6">get_length()</a># function and the length passed to the \Ref{connect}() function. \end{itemize}. </p>

</div>
</div>
<a id="a3598836ed10e1d5ce0742c680bd091b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3598836ed10e1d5ce0742c680bd091b2">&#9670;&nbsp;</a></span>get_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int DataPool::get_size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of bytes of data available in this <a class="el" href="classDataPool.html">DataPool</a>#. Contrary to the \Ref{get_length}() function, this one doesn't try to interpret the IFF structure and predict the file length. It just returns the number of bytes of data really available inside the <a class="el" href="classDataPool.html">DataPool</a>#, if it contains data, or inside its range, if it's connected to another <a class="el" href="classDataPool.html">DataPool</a># or a file. </p>

</div>
</div>
<a id="a3b9c871c9125cc0bfd252a04c35ca90e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b9c871c9125cc0bfd252a04c35ca90e">&#9670;&nbsp;</a></span>get_stream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGP.html">GP</a>&lt; <a class="el" href="classByteStream.html">ByteStream</a> &gt; DataPool::get_stream </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a \Ref{<a class="el" href="classByteStream.html">ByteStream</a>} to access contents of the <a class="el" href="classDataPool.html">DataPool</a># sequentially. By reading from the returned stream you basically call \Ref{get_data}() function. Thus, everything said for it remains true for the stream too. </p>

</div>
</div>
<a id="a78c1d25daf95259d16df37b5ea7dd667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78c1d25daf95259d16df37b5ea7dd667">&#9670;&nbsp;</a></span>has_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DataPool::has_data </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns #TRUE# if all data available for offsets from #start# till #start+length-1#. If #length# is negative, the range is assumed to extend up to the end of the <a class="el" href="classDataPool.html">DataPool</a>#. This function works both for connected and not connected #DataPool#s. Once it returned #TRUE# for some offsets range, you can be sure that the subsequent \Ref{get_data}() request will not block. </p>

</div>
</div>
<a id="a0a939a560f83bcfbaf9a1aa3ff766294"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a939a560f83bcfbaf9a1aa3ff766294">&#9670;&nbsp;</a></span>is_connected()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DataPool::is_connected </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns #TRUE# if this <a class="el" href="classDataPool.html">DataPool</a># is connected to another <a class="el" href="classDataPool.html">DataPool</a># or to a file. </p>

</div>
</div>
<a id="ada575a6bbb9d148e57afcb2c202aa959"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada575a6bbb9d148e57afcb2c202aa959">&#9670;&nbsp;</a></span>load_file() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DataPool::load_file </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGURL.html">GURL</a> &amp;&#160;</td>
          <td class="paramname"><em>url</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function will make every <a class="el" href="classDataPool.html">DataPool</a># in the program, which is connected to a file, to load the file contents to the main memory and close the file. This feature is important when you want to do something with the file like remove or overwrite it not affecting the rest of the program. </p>

</div>
</div>
<a id="a05c41e301aa5971f4887e89b97c358e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05c41e301aa5971f4887e89b97c358e8">&#9670;&nbsp;</a></span>load_file() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DataPool::load_file </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Loads data from the file into memory. This function is only useful for #DataPool#s getting data from a file. It descends the #DataPool#s hierarchy until it either reaches a file-connected <a class="el" href="classDataPool.html">DataPool</a># or <a class="el" href="classDataPool.html">DataPool</a># containing the real data. In the latter case it does nothing, in the first case it makes the <a class="el" href="classDataPool.html">DataPool</a># read all data from the file into memory and stop using the file.</p>
<p>This may be useful when you want to overwrite the file and leave existing #DataPool#s with valid data. </p>

</div>
</div>
<a id="ae5028bb28c326c25f0d6b3218b0367b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5028bb28c326c25f0d6b3218b0367b8">&#9670;&nbsp;</a></span>set_eof()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DataPool::set_eof </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tells the <a class="el" href="classDataPool.html">DataPool</a># that all data has been added and nothing else is anticipated. When #EOF# is true, any reader attempting to read non existing data will not be blocked. It will either read #ZERO# bytes or will get an <a class="el" href="classByteStream.html#a6a752fb635ed48366afad0719be4ef08">ByteStream::EndOfFile</a># exception (see \Ref{get_data}()). Calling this function will also activate all registered trigger callbacks.</p>
<p>{\bf Note:} This function is meaningless and does nothing when the <a class="el" href="classDataPool.html">DataPool</a># is connected to another <a class="el" href="classDataPool.html">DataPool</a># or to a file. </p>

</div>
</div>
<a id="a860b0df7fd46f33a2c9b5b5fcb45a983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a860b0df7fd46f33a2c9b5b5fcb45a983">&#9670;&nbsp;</a></span>simple_compare()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DataPool::simple_compare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDataPool.html">DataPool</a> &amp;&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Useful in comparing data pools. Returns true if dirived from same URL or bytestream. </p>

</div>
</div>
<a id="a4d36a05eca714362333f305571834292"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d36a05eca714362333f305571834292">&#9670;&nbsp;</a></span>stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DataPool::stop </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>only_blocked</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tells the <a class="el" href="classDataPool.html">DataPool</a># to stop serving readers.</p>
<p>If #only_blocked# flag is #TRUE# then only those requests will be processed, which would not block. Any attempt to get non-existing data would result in a #STOP# exception (instead of blocking until data is available).</p>
<p>If #only_blocked# flag is #FALSE# then any further attempt to read from this <a class="el" href="classDataPool.html">DataPool</a># (as well as from any <a class="el" href="classDataPool.html">DataPool</a># connected to this one) will result in a #STOP# exception. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>libdjvu/<a class="el" href="DataPool_8h_source.html">DataPool.h</a></li>
<li>libdjvu/DataPool.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
