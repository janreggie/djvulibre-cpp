<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: ByteStream Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classByteStream-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ByteStream Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="ByteStream_8h_source.html">ByteStream.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ByteStream:</div>
<div class="dyncontent">
<div class="center"><img src="classByteStream__inherit__graph.png" border="0" usemap="#ByteStream_inherit__map" alt="Inheritance graph"/></div>
<map name="ByteStream_inherit__map" id="ByteStream_inherit__map">
<area shape="rect" title=" " alt="" coords="145,233,244,260"/>
<area shape="rect" href="classBSByteStream.html" title=" " alt="" coords="315,31,431,57"/>
<area shape="rect" href="classBufferByteStream.html" title=" " alt="" coords="303,81,442,108"/>
<area shape="rect" href="classByteStream_1_1Memory.html" title=" " alt="" coords="292,132,453,159"/>
<area shape="rect" href="classByteStream_1_1Static.html" title=" " alt="" coords="301,183,445,209"/>
<area shape="rect" href="classByteStream_1_1Stdio.html" title=" " alt="" coords="303,233,443,260"/>
<area shape="rect" href="classParsingByteStream.html" title=" " alt="" coords="299,284,446,311"/>
<area shape="rect" href="classPoolByteStream.html" title=" " alt="" coords="309,335,436,361"/>
<area shape="rect" href="classProgressByteStream.html" title=" " alt="" coords="295,385,450,412"/>
<area shape="rect" href="classUnicodeByteStream.html" title=" " alt="" coords="297,436,449,463"/>
<area shape="rect" href="classGPEnabled.html" title=" " alt="" coords="5,233,97,260"/>
<area shape="rect" href="classBSByteStream_1_1Decode.html" title=" " alt="" coords="501,5,675,32"/>
<area shape="rect" href="classBSByteStream_1_1Encode.html" title=" " alt="" coords="503,56,673,83"/>
<area shape="rect" href="classXMLByteStream.html" title=" " alt="" coords="525,436,651,463"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for ByteStream:</div>
<div class="dyncontent">
<div class="center"><img src="classByteStream__coll__graph.png" border="0" usemap="#ByteStream_coll__map" alt="Collaboration graph"/></div>
<map name="ByteStream_coll__map" id="ByteStream_coll__map">
<area shape="rect" title=" " alt="" coords="5,260,104,287"/>
<area shape="rect" href="classGPEnabled.html" title=" " alt="" coords="9,5,101,32"/>
<area shape="rect" href="classGPBase.html" title=" " alt="" coords="89,95,161,121"/>
<area shape="rect" href="classGP.html" title=" " alt="" coords="71,171,217,197"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classByteStream_1_1Memory.html">Memory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classByteStream_1_1Static.html">Static</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classByteStream_1_1Stdio.html">Stdio</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac277f6ccb77e88769ca7913ebf631b29"><td class="memItemLeft" align="right" valign="top"><a id="ac277f6ccb77e88769ca7913ebf631b29"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>codepage_type</b> { <b>RAW</b>, 
<b>AUTO</b>, 
<b>NATIVE</b>, 
<b>UTF8</b>
 }</td></tr>
<tr class="separator:ac277f6ccb77e88769ca7913ebf631b29"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3be09ee0d24f4ac6694b0012faeed2db"><td class="memItemLeft" align="right" valign="top"><a id="a3be09ee0d24f4ac6694b0012faeed2db"></a>
<a class="el" href="classByteStream.html">ByteStream</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>operator&amp;</b> () const</td></tr>
<tr class="separator:a3be09ee0d24f4ac6694b0012faeed2db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55f64c9c2b127a5487a1c3551dd405cd"><td class="memItemLeft" align="right" valign="top"><a id="a55f64c9c2b127a5487a1c3551dd405cd"></a>
<a class="el" href="classByteStream.html">ByteStream</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>operator&amp;</b> ()</td></tr>
<tr class="separator:a55f64c9c2b127a5487a1c3551dd405cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a087d1b5f7256f920b5f323834d2318b8"><td class="memItemLeft" align="right" valign="top"><a id="a087d1b5f7256f920b5f323834d2318b8"></a>
virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><b>read</b> (void *buffer, size_t <a class="el" href="classByteStream.html#aa33b66a4401b7ab98953158b766a8dec">size</a>)</td></tr>
<tr class="separator:a087d1b5f7256f920b5f323834d2318b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad982b4e417e8173768dd9f89eeed321d"><td class="memItemLeft" align="right" valign="top"><a id="ad982b4e417e8173768dd9f89eeed321d"></a>
virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><b>write</b> (const void *buffer, size_t <a class="el" href="classByteStream.html#aa33b66a4401b7ab98953158b766a8dec">size</a>)</td></tr>
<tr class="separator:ad982b4e417e8173768dd9f89eeed321d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee8d76bfdfee2cc70ed7daffb8e32337"><td class="memItemLeft" align="right" valign="top"><a id="aee8d76bfdfee2cc70ed7daffb8e32337"></a>
virtual long&#160;</td><td class="memItemRight" valign="bottom"><b>tell</b> (void) const</td></tr>
<tr class="separator:aee8d76bfdfee2cc70ed7daffb8e32337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac17769decaf8a46f58a6213c897b88a5"><td class="memItemLeft" align="right" valign="top"><a id="ac17769decaf8a46f58a6213c897b88a5"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>seek</b> (long offset, int whence=SEEK_SET, bool nothrow=false)</td></tr>
<tr class="separator:ac17769decaf8a46f58a6213c897b88a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8834ce0b44b9d266556e5b946d3c3493"><td class="memItemLeft" align="right" valign="top"><a id="a8834ce0b44b9d266556e5b946d3c3493"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>flush</b> (void)</td></tr>
<tr class="separator:a8834ce0b44b9d266556e5b946d3c3493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Virtual Functions.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These functions are usually implemented by each subclass of <a class="el" href="classByteStream.html">ByteStream</a>#. </p>
</div></td></tr>
<tr class="memitem:acc61f87bb3522fc450e88cb580fc33fd"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classByteStream.html#acc61f87bb3522fc450e88cb580fc33fd">~ByteStream</a> ()</td></tr>
<tr class="separator:acc61f87bb3522fc450e88cb580fc33fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae69bbdbc77545f72488bde0639ae0e95"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classByteStream.html#ae69bbdbc77545f72488bde0639ae0e95">read</a> (void *buffer, size_t <a class="el" href="classByteStream.html#aa33b66a4401b7ab98953158b766a8dec">size</a>)</td></tr>
<tr class="separator:ae69bbdbc77545f72488bde0639ae0e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac10e950d655e5dabb93af44e3a5da855"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classByteStream.html#ac10e950d655e5dabb93af44e3a5da855">write</a> (const void *buffer, size_t <a class="el" href="classByteStream.html#aa33b66a4401b7ab98953158b766a8dec">size</a>)</td></tr>
<tr class="separator:ac10e950d655e5dabb93af44e3a5da855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6379ec44f814a160980d2dd5c5e25672"><td class="memItemLeft" align="right" valign="top">virtual long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classByteStream.html#a6379ec44f814a160980d2dd5c5e25672">tell</a> (void) const =0</td></tr>
<tr class="separator:a6379ec44f814a160980d2dd5c5e25672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a601ef5bf4d183b262472e1e1f7c9a2ad"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classByteStream.html#a601ef5bf4d183b262472e1e1f7c9a2ad">seek</a> (long offset, int whence=SEEK_SET, bool nothrow=false)</td></tr>
<tr class="separator:a601ef5bf4d183b262472e1e1f7c9a2ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35993db0bf51666f6f60900d88c41dba"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classByteStream.html#a35993db0bf51666f6f60900d88c41dba">flush</a> (void)</td></tr>
<tr class="separator:a35993db0bf51666f6f60900d88c41dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classGPEnabled"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classGPEnabled')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classGPEnabled.html">GPEnabled</a></td></tr>
<tr class="memitem:a9e5f12f17477e448d1fc08e37cb9d2dd inherit pub_methods_classGPEnabled"><td class="memItemLeft" align="right" valign="top"><a id="a9e5f12f17477e448d1fc08e37cb9d2dd"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGPEnabled.html#a9e5f12f17477e448d1fc08e37cb9d2dd">~GPEnabled</a> ()</td></tr>
<tr class="memdesc:a9e5f12f17477e448d1fc08e37cb9d2dd inherit pub_methods_classGPEnabled"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual destructor. <br /></td></tr>
<tr class="separator:a9e5f12f17477e448d1fc08e37cb9d2dd inherit pub_methods_classGPEnabled"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af197d1b7ec283031880818fd05fdd2f9 inherit pub_methods_classGPEnabled"><td class="memItemLeft" align="right" valign="top"><a id="af197d1b7ec283031880818fd05fdd2f9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGPEnabled.html#af197d1b7ec283031880818fd05fdd2f9">GPEnabled</a> ()</td></tr>
<tr class="memdesc:af197d1b7ec283031880818fd05fdd2f9 inherit pub_methods_classGPEnabled"><td class="mdescLeft">&#160;</td><td class="mdescRight">Null constructor. <br /></td></tr>
<tr class="separator:af197d1b7ec283031880818fd05fdd2f9 inherit pub_methods_classGPEnabled"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2875b20558241302927c11dea068b6a inherit pub_methods_classGPEnabled"><td class="memItemLeft" align="right" valign="top"><a id="ae2875b20558241302927c11dea068b6a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGPEnabled.html#ae2875b20558241302927c11dea068b6a">GPEnabled</a> (const <a class="el" href="classGPEnabled.html">GPEnabled</a> &amp;obj)</td></tr>
<tr class="memdesc:ae2875b20558241302927c11dea068b6a inherit pub_methods_classGPEnabled"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy construcotr. <br /></td></tr>
<tr class="separator:ae2875b20558241302927c11dea068b6a inherit pub_methods_classGPEnabled"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4604c98eff7df30c6071bacdbc6693aa inherit pub_methods_classGPEnabled"><td class="memItemLeft" align="right" valign="top"><a id="a4604c98eff7df30c6071bacdbc6693aa"></a>
<a class="el" href="classGPEnabled.html">GPEnabled</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGPEnabled.html#a4604c98eff7df30c6071bacdbc6693aa">operator=</a> (const <a class="el" href="classGPEnabled.html">GPEnabled</a> &amp;obj)</td></tr>
<tr class="memdesc:a4604c98eff7df30c6071bacdbc6693aa inherit pub_methods_classGPEnabled"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy operator. <br /></td></tr>
<tr class="separator:a4604c98eff7df30c6071bacdbc6693aa inherit pub_methods_classGPEnabled"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff96ec9203073e902735c5b6b1f650a0 inherit pub_methods_classGPEnabled"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGPEnabled.html#aff96ec9203073e902735c5b6b1f650a0">get_count</a> (void) const</td></tr>
<tr class="separator:aff96ec9203073e902735c5b6b1f650a0 inherit pub_methods_classGPEnabled"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a1d57d35d33f45372a939853385f0f5fd"><td class="memItemLeft" align="right" valign="top"><a id="a1d57d35d33f45372a939853385f0f5fd"></a>
enum ByteStream::codepage_type&#160;</td><td class="memItemRight" valign="bottom"><b>cp</b></td></tr>
<tr class="separator:a1d57d35d33f45372a939853385f0f5fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a7e8b4e2f930407c55484ea59fdf30956"><td class="memItemLeft" align="right" valign="top"><a id="a7e8b4e2f930407c55484ea59fdf30956"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Wrapper</b> (void)</td></tr>
<tr class="separator:a7e8b4e2f930407c55484ea59fdf30956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8fd674a9a3008605e2b9b72c194ba84"><td class="memItemLeft" align="right" valign="top"><a id="af8fd674a9a3008605e2b9b72c194ba84"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Wrapper</b> (const <a class="el" href="classGP.html">GP</a>&lt; <a class="el" href="classByteStream.html">ByteStream</a> &gt; &amp;xbs)</td></tr>
<tr class="separator:af8fd674a9a3008605e2b9b72c194ba84"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a4dc3750d70ccc7dba318677c4611b00e"><td class="memItemLeft" align="right" valign="top"><a id="a4dc3750d70ccc7dba318677c4611b00e"></a>
<a class="el" href="classGP.html">GP</a>&lt; <a class="el" href="classByteStream.html">ByteStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>gbs</b></td></tr>
<tr class="separator:a4dc3750d70ccc7dba318677c4611b00e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada0ee8bd9f3d9081d41cc9f17e4805e9"><td class="memItemLeft" align="right" valign="top"><a id="ada0ee8bd9f3d9081d41cc9f17e4805e9"></a>
<a class="el" href="classByteStream.html">ByteStream</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>bs</b></td></tr>
<tr class="separator:ada0ee8bd9f3d9081d41cc9f17e4805e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classGPEnabled"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classGPEnabled')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classGPEnabled.html">GPEnabled</a></td></tr>
<tr class="memitem:aaeebfa533635d29cc70aaa3620678734 inherit pro_attribs_classGPEnabled"><td class="memItemLeft" align="right" valign="top"><a id="aaeebfa533635d29cc70aaa3620678734"></a>
volatile int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGPEnabled.html#aaeebfa533635d29cc70aaa3620678734">count</a></td></tr>
<tr class="memdesc:aaeebfa533635d29cc70aaa3620678734 inherit pro_attribs_classGPEnabled"><td class="mdescLeft">&#160;</td><td class="mdescRight">The reference counter. <br /></td></tr>
<tr class="separator:aaeebfa533635d29cc70aaa3620678734 inherit pro_attribs_classGPEnabled"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Utility Functions.</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpfdb67d4b986f5fcf59f4a1e1823cb5a2"></a><br  />
 <a class="el" href="structClass.html">Class</a> <a class="el" href="classByteStream.html">ByteStream</a># implements these functions using the virtual interface functions only. All subclasses of <a class="el" href="classByteStream.html">ByteStream</a># inherit these functions. </p>
</td></tr>
<tr class="memitem:a6a752fb635ed48366afad0719be4ef08"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classByteStream.html#a6a752fb635ed48366afad0719be4ef08">EndOfFile</a> =ERR_MSG(&quot;EOF&quot;)</td></tr>
<tr class="separator:a6a752fb635ed48366afad0719be4ef08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89ab1c5568227e3c8e45968178d78f5b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classByteStream.html#a89ab1c5568227e3c8e45968178d78f5b">readall</a> (void *buffer, size_t <a class="el" href="classByteStream.html#aa33b66a4401b7ab98953158b766a8dec">size</a>)</td></tr>
<tr class="separator:a89ab1c5568227e3c8e45968178d78f5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5783e755c524b6c5deb0644148a0f23"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classByteStream.html#ae5783e755c524b6c5deb0644148a0f23">writall</a> (const void *buffer, size_t <a class="el" href="classByteStream.html#aa33b66a4401b7ab98953158b766a8dec">size</a>)</td></tr>
<tr class="separator:ae5783e755c524b6c5deb0644148a0f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0d1a30ac0d602194c57ff0920639391"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classByteStream.html#ab0d1a30ac0d602194c57ff0920639391">copy</a> (<a class="el" href="classByteStream.html">ByteStream</a> &amp;bsfrom, size_t <a class="el" href="classByteStream.html#aa33b66a4401b7ab98953158b766a8dec">size</a>=0)</td></tr>
<tr class="separator:ab0d1a30ac0d602194c57ff0920639391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abff0fe1eef41b304519f9f10da6ef3c7"><td class="memItemLeft" align="right" valign="top"><a id="abff0fe1eef41b304519f9f10da6ef3c7"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classByteStream.html#abff0fe1eef41b304519f9f10da6ef3c7">format</a> (const char *fmt,...)</td></tr>
<tr class="memdesc:abff0fe1eef41b304519f9f10da6ef3c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows printf() type operations to a bytestream. <br /></td></tr>
<tr class="separator:abff0fe1eef41b304519f9f10da6ef3c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f4b7b447f343bcd2c2dffed4b4da109"><td class="memItemLeft" align="right" valign="top"><a id="a2f4b7b447f343bcd2c2dffed4b4da109"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classByteStream.html#a2f4b7b447f343bcd2c2dffed4b4da109">scanf</a> (const char *fmt,...)</td></tr>
<tr class="memdesc:a2f4b7b447f343bcd2c2dffed4b4da109"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows <a class="el" href="classByteStream.html#a2f4b7b447f343bcd2c2dffed4b4da109" title="Allows scanf() type operations on a bytestream.">scanf()</a> type operations on a bytestream. <br /></td></tr>
<tr class="separator:a2f4b7b447f343bcd2c2dffed4b4da109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49bd373dca4e0c6bbdd509b9ad7de42c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classByteStream.html#a49bd373dca4e0c6bbdd509b9ad7de42c">writestring</a> (const <a class="el" href="classGUTF8String.html">GUTF8String</a> &amp;s)</td></tr>
<tr class="separator:a49bd373dca4e0c6bbdd509b9ad7de42c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f5df9e9adbe3b37970f72c698ca1e80"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classByteStream.html#a3f5df9e9adbe3b37970f72c698ca1e80">writestring</a> (const <a class="el" href="classGNativeString.html">GNativeString</a> &amp;s)</td></tr>
<tr class="separator:a3f5df9e9adbe3b37970f72c698ca1e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58179619963ba32ecad140e7e8e55488"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classByteStream.html#a58179619963ba32ecad140e7e8e55488">formatmessage</a> (const char *fmt,...)</td></tr>
<tr class="separator:a58179619963ba32ecad140e7e8e55488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ab1c9315f01f695d7a2375c9bc54b94"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classByteStream.html#a4ab1c9315f01f695d7a2375c9bc54b94">writemessage</a> (const char *message)</td></tr>
<tr class="separator:a4ab1c9315f01f695d7a2375c9bc54b94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a674300c4bedd4205bad3263d9159a33a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classByteStream.html#a674300c4bedd4205bad3263d9159a33a">write8</a> (unsigned int card8)</td></tr>
<tr class="separator:a674300c4bedd4205bad3263d9159a33a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba0c903ed8b120f804f7c45c6de26f6f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classByteStream.html#aba0c903ed8b120f804f7c45c6de26f6f">write16</a> (unsigned int card16)</td></tr>
<tr class="separator:aba0c903ed8b120f804f7c45c6de26f6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a176da3627a17900cbdd95549c3c1a0c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classByteStream.html#a176da3627a17900cbdd95549c3c1a0c8">write24</a> (unsigned int card24)</td></tr>
<tr class="separator:a176da3627a17900cbdd95549c3c1a0c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76ae6a61bd5c6db5d81dc95cb530cfb0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classByteStream.html#a76ae6a61bd5c6db5d81dc95cb530cfb0">write32</a> (unsigned int card32)</td></tr>
<tr class="separator:a76ae6a61bd5c6db5d81dc95cb530cfb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab882f4e4e2ef82b1935381b25a2ddf89"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classByteStream.html#ab882f4e4e2ef82b1935381b25a2ddf89">read8</a> ()</td></tr>
<tr class="separator:ab882f4e4e2ef82b1935381b25a2ddf89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f57554fc3da020731631f0e6a45d5e7"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classByteStream.html#a5f57554fc3da020731631f0e6a45d5e7">read16</a> ()</td></tr>
<tr class="separator:a5f57554fc3da020731631f0e6a45d5e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10723e7f4212afc31e8c77899eceb2d3"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classByteStream.html#a10723e7f4212afc31e8c77899eceb2d3">read24</a> ()</td></tr>
<tr class="separator:a10723e7f4212afc31e8c77899eceb2d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1d5bbdb9b37193257095c7465b34453"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classByteStream.html#ab1d5bbdb9b37193257095c7465b34453">read32</a> ()</td></tr>
<tr class="separator:ab1d5bbdb9b37193257095c7465b34453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa33b66a4401b7ab98953158b766a8dec"><td class="memItemLeft" align="right" valign="top">virtual long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classByteStream.html#aa33b66a4401b7ab98953158b766a8dec">size</a> (void) const</td></tr>
<tr class="separator:aa33b66a4401b7ab98953158b766a8dec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a907234b0768296da96e1a59e6a94131d"><td class="memItemLeft" align="right" valign="top"><a id="a907234b0768296da96e1a59e6a94131d"></a>
<a class="el" href="classTArray.html">TArray</a>&lt; char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classByteStream.html#a907234b0768296da96e1a59e6a94131d">get_data</a> (void)</td></tr>
<tr class="memdesc:a907234b0768296da96e1a59e6a94131d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use at your own risk, only guarenteed to work for ByteStream::Memorys. <br /></td></tr>
<tr class="separator:a907234b0768296da96e1a59e6a94131d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6eb7cb9411fb20f1778bc290f2417be"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classByteStream.html#ae6eb7cb9411fb20f1778bc290f2417be">readat</a> (void *buffer, size_t sz, long pos)</td></tr>
<tr class="separator:ae6eb7cb9411fb20f1778bc290f2417be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab99df3538376936ff06e1462b3bd8061"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGNativeString.html">GNativeString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classByteStream.html#ab99df3538376936ff06e1462b3bd8061">getAsNative</a> (void)</td></tr>
<tr class="separator:ab99df3538376936ff06e1462b3bd8061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d7c5782f9f8edc2d5c1eccbf364e20c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGUTF8String.html">GUTF8String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classByteStream.html#a5d7c5782f9f8edc2d5c1eccbf364e20c">getAsUTF8</a> (void)</td></tr>
<tr class="separator:a5d7c5782f9f8edc2d5c1eccbf364e20c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a190b069b8c937947168a20211d237e19"><td class="memItemLeft" align="right" valign="top"><a id="a190b069b8c937947168a20211d237e19"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ByteStream</b> (void)</td></tr>
<tr class="separator:a190b069b8c937947168a20211d237e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad479674d935ff53e45613ed922504067"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGP.html">GP</a>&lt; <a class="el" href="classByteStream.html">ByteStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classByteStream.html#ad479674d935ff53e45613ed922504067">create</a> (void)</td></tr>
<tr class="separator:ad479674d935ff53e45613ed922504067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5163d5fd24cdf5c7ea7114368ae38f3c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGP.html">GP</a>&lt; <a class="el" href="classByteStream.html">ByteStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classByteStream.html#a5163d5fd24cdf5c7ea7114368ae38f3c">create</a> (void const *const buffer, const size_t <a class="el" href="classByteStream.html#aa33b66a4401b7ab98953158b766a8dec">size</a>)</td></tr>
<tr class="separator:a5163d5fd24cdf5c7ea7114368ae38f3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa03daeb22adfda1d9f9d6c929725e897"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGP.html">GP</a>&lt; <a class="el" href="classByteStream.html">ByteStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classByteStream.html#aa03daeb22adfda1d9f9d6c929725e897">create</a> (const <a class="el" href="classGURL.html">GURL</a> &amp;url, char const *const mode)</td></tr>
<tr class="separator:aa03daeb22adfda1d9f9d6c929725e897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0015d75be619fa5927f3f5908a59b605"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGP.html">GP</a>&lt; <a class="el" href="classByteStream.html">ByteStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classByteStream.html#a0015d75be619fa5927f3f5908a59b605">create</a> (char const *const mode)</td></tr>
<tr class="separator:a0015d75be619fa5927f3f5908a59b605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad74f72932da563b6e98358e6f081f919"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGP.html">GP</a>&lt; <a class="el" href="classByteStream.html">ByteStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classByteStream.html#ad74f72932da563b6e98358e6f081f919">create</a> (const int fd, char const *const mode, const bool closeme)</td></tr>
<tr class="separator:ad74f72932da563b6e98358e6f081f919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0690dae2073c9a76772ebb15a82bb67f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGP.html">GP</a>&lt; <a class="el" href="classByteStream.html">ByteStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classByteStream.html#a0690dae2073c9a76772ebb15a82bb67f">create</a> (FILE *const f, char const *const mode, const bool closeme)</td></tr>
<tr class="separator:a0690dae2073c9a76772ebb15a82bb67f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb458292f35c299bfc92e5520359fb4b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGP.html">GP</a>&lt; <a class="el" href="classByteStream.html">ByteStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classByteStream.html#abb458292f35c299bfc92e5520359fb4b">create_static</a> (void const *buffer, size_t <a class="el" href="classByteStream.html#aa33b66a4401b7ab98953158b766a8dec">size</a>)</td></tr>
<tr class="separator:abb458292f35c299bfc92e5520359fb4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36ec6d680202c1658f4967063b96ca8c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGP.html">GP</a>&lt; <a class="el" href="classByteStream.html">ByteStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classByteStream.html#a36ec6d680202c1658f4967063b96ca8c">get_stdin</a> (char const *mode=0)</td></tr>
<tr class="separator:a36ec6d680202c1658f4967063b96ca8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7291fe18f4afc26a66fc654e6677ad58"><td class="memItemLeft" align="right" valign="top"><a id="a7291fe18f4afc26a66fc654e6677ad58"></a>
static <a class="el" href="classGP.html">GP</a>&lt; <a class="el" href="classByteStream.html">ByteStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>get_stdout</b> (char const *mode=0)</td></tr>
<tr class="separator:a7291fe18f4afc26a66fc654e6677ad58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06cddc26637c4a5d91a743e56e34a27b"><td class="memItemLeft" align="right" valign="top"><a id="a06cddc26637c4a5d91a743e56e34a27b"></a>
static <a class="el" href="classGP.html">GP</a>&lt; <a class="el" href="classByteStream.html">ByteStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>get_stderr</b> (char const *mode=0)</td></tr>
<tr class="separator:a06cddc26637c4a5d91a743e56e34a27b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Abstract class for a stream of bytes. <a class="el" href="structClass.html">Class</a> <a class="el" href="classByteStream.html">ByteStream</a># represent an object from which (resp. to which) bytes can be read (resp. written) as with a regular file. Virtual functions <a class="el" href="classByteStream.html#ae69bbdbc77545f72488bde0639ae0e95">read</a># and <a class="el" href="classByteStream.html#ac10e950d655e5dabb93af44e3a5da855">write</a># must implement these two basic operations. In addition, function <a class="el" href="classByteStream.html#a6379ec44f814a160980d2dd5c5e25672">tell</a># returns an offset identifying the current position, and function <a class="el" href="classByteStream.html#a601ef5bf4d183b262472e1e1f7c9a2ad">seek</a># may be used to change the current position.</p>
<p>{\bf Note}. Both the copy constructor and the copy operator are declared as private members. It is therefore not possible to make multiple copies of instances of this class, as implied by the class semantic. <br  />
</p>
<p>ByteStream::Wrapper implements wrapping bytestream. This is useful for derived classes that take a <a class="el" href="classGP.html">GP&lt;ByteStream&gt;</a> as a creation argument, and the backwards compatible bytestreams. <br  />
 </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="acc61f87bb3522fc450e88cb580fc33fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc61f87bb3522fc450e88cb580fc33fd">&#9670;&nbsp;</a></span>~ByteStream()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ByteStream::~ByteStream </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Virtual destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab0d1a30ac0d602194c57ff0920639391"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0d1a30ac0d602194c57ff0920639391">&#9670;&nbsp;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ByteStream::copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classByteStream.html">ByteStream</a> &amp;&#160;</td>
          <td class="paramname"><em>bsfrom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy data from another <a class="el" href="classByteStream.html">ByteStream</a>. A maximum of <a class="el" href="classByteStream.html#aa33b66a4401b7ab98953158b766a8dec">size</a># bytes are read from the <a class="el" href="classByteStream.html">ByteStream</a> #bsfrom# and are written to the <a class="el" href="classByteStream.html">ByteStream</a> #*this# at the current position. Less than <a class="el" href="classByteStream.html#aa33b66a4401b7ab98953158b766a8dec">size</a># bytes may be written if an end-of-file mark is reached on #bsfrom#. This function returns the total number of bytes copied. Setting argument <a class="el" href="classByteStream.html#aa33b66a4401b7ab98953158b766a8dec">size</a># to zero (the default value) has a special meaning: the copying process will continue until reaching the end-of-file mark on <a class="el" href="classByteStream.html">ByteStream</a> #bsfrom#, regardless of the number of bytes transferred. <br  />
 </p>

</div>
</div>
<a id="a0015d75be619fa5927f3f5908a59b605"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0015d75be619fa5927f3f5908a59b605">&#9670;&nbsp;</a></span>create() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGP.html">GP</a>&lt; <a class="el" href="classByteStream.html">ByteStream</a> &gt; ByteStream::create </td>
          <td>(</td>
          <td class="paramtype">char const *const&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as the above, but uses stdin or stdout </p>

</div>
</div>
<a id="aa03daeb22adfda1d9f9d6c929725e897"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa03daeb22adfda1d9f9d6c929725e897">&#9670;&nbsp;</a></span>create() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGP.html">GP</a>&lt; <a class="el" href="classByteStream.html">ByteStream</a> &gt; ByteStream::create </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGURL.html">GURL</a> &amp;&#160;</td>
          <td class="paramname"><em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *const&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a <a class="el" href="classByteStream.html">ByteStream</a> for accessing the file named #url#. Arguments #url# and #mode# are similar to the arguments of the well known stdio function #fopen#. In addition a url of #-# will be interpreted as the standard output or the standard input according to #mode#. This constructor will open a stdio file and construct a <a class="el" href="classByteStream.html">ByteStream</a> object accessing this file. Destroying the <a class="el" href="classByteStream.html">ByteStream</a> object will flush and close the associated stdio file. Exception \Ref{<a class="el" href="classGException.html">GException</a>} is thrown with a plain text error message if the stdio file cannot be opened. </p>

</div>
</div>
<a id="ad74f72932da563b6e98358e6f081f919"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad74f72932da563b6e98358e6f081f919">&#9670;&nbsp;</a></span>create() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGP.html">GP</a>&lt; <a class="el" href="classByteStream.html">ByteStream</a> &gt; ByteStream::create </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *const&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>closeme</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a <a class="el" href="classByteStream.html">ByteStream</a> for accessing the stdio file #f#. Argument #mode# indicates the type of the stdio file, as in the well known stdio function #fopen#. Destroying the <a class="el" href="classByteStream.html">ByteStream</a> object will not close the stdio file #f# unless closeme is true. </p>

</div>
</div>
<a id="a0690dae2073c9a76772ebb15a82bb67f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0690dae2073c9a76772ebb15a82bb67f">&#9670;&nbsp;</a></span>create() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGP.html">GP</a>&lt; <a class="el" href="classByteStream.html">ByteStream</a> &gt; ByteStream::create </td>
          <td>(</td>
          <td class="paramtype">FILE *const&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *const&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>closeme</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a <a class="el" href="classByteStream.html">ByteStream</a> for accessing the stdio file #f#. Argument #mode# indicates the type of the stdio file, as in the well known stdio function #fopen#. Destroying the <a class="el" href="classByteStream.html">ByteStream</a> object will not close the stdio file #f# unless closeme is true. </p>

</div>
</div>
<a id="a5163d5fd24cdf5c7ea7114368ae38f3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5163d5fd24cdf5c7ea7114368ae38f3c">&#9670;&nbsp;</a></span>create() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGP.html">GP</a>&lt; <a class="el" href="classByteStream.html">ByteStream</a> &gt; ByteStream::create </td>
          <td>(</td>
          <td class="paramtype">void const *const&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a <a class="el" href="classByteStream_1_1Memory.html">Memory</a> <a class="el" href="classByteStream.html">ByteStream</a> by copying initial data. The <a class="el" href="classByteStream_1_1Memory.html">Memory</a> buffer is initialized with <a class="el" href="classByteStream.html#aa33b66a4401b7ab98953158b766a8dec">size</a># bytes copied from the memory area pointed to by #buffer#. </p>

</div>
</div>
<a id="ad479674d935ff53e45613ed922504067"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad479674d935ff53e45613ed922504067">&#9670;&nbsp;</a></span>create() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGP.html">GP</a>&lt; <a class="el" href="classByteStream.html">ByteStream</a> &gt; ByteStream::create </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs an empty <a class="el" href="classByteStream_1_1Memory.html">Memory</a> <a class="el" href="classByteStream.html">ByteStream</a>. The buffer itself is organized as an array of 4096 byte blocks. The buffer is initially empty. You must first use function <a class="el" href="classByteStream.html#ac10e950d655e5dabb93af44e3a5da855">write</a># to store data into the buffer, use function <a class="el" href="classByteStream.html#a601ef5bf4d183b262472e1e1f7c9a2ad">seek</a># to rewind the current position, and function <a class="el" href="classByteStream.html#ae69bbdbc77545f72488bde0639ae0e95">read</a># to read the data back. </p>

</div>
</div>
<a id="abb458292f35c299bfc92e5520359fb4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb458292f35c299bfc92e5520359fb4b">&#9670;&nbsp;</a></span>create_static()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGP.html">GP</a>&lt; <a class="el" href="classByteStream.html">ByteStream</a> &gt; ByteStream::create_static </td>
          <td>(</td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a <a class="el" href="classByteStream.html">ByteStream</a> object for allocating the memory area of length #sz# starting at address #buffer#. This call impliments a read-only <a class="el" href="classByteStream.html">ByteStream</a> interface for a memory area specified by the user at construction time. Calls to function <a class="el" href="classByteStream.html#ae69bbdbc77545f72488bde0639ae0e95">read</a># directly access this memory area. The user must therefore make sure that its content remain valid long enough. <br  />
 </p>

</div>
</div>
<a id="a35993db0bf51666f6f60900d88c41dba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35993db0bf51666f6f60900d88c41dba">&#9670;&nbsp;</a></span>flush()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ByteStream::flush </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Flushes all buffers in the <a class="el" href="classByteStream.html">ByteStream</a>. Calling this function guarantees that pending data have been actually written (i.e. passed to the operating system). <a class="el" href="structClass.html">Class</a> <a class="el" href="classByteStream.html">ByteStream</a># provides a default implementation which does nothing. </p>

<p>Reimplemented in <a class="el" href="classBSByteStream.html#ab4506bed8f8778ba256a43ae61d62646">BSByteStream</a>, <a class="el" href="classBSByteStream_1_1Encode.html#a0ba8f805838717bb146908ff8aa25dc3">BSByteStream::Encode</a>, <a class="el" href="classByteStream_1_1Stdio.html#abb8b7b09eedc6cad471fe0f397cc3ad7">ByteStream::Stdio</a>, <a class="el" href="classUnicodeByteStream.html#a5e6980e578f689be13201b3858f74b24">UnicodeByteStream</a>, and <a class="el" href="classBSByteStream_1_1Decode.html#af053edb53f525bafd282cbe0c7cbe9c0">BSByteStream::Decode</a>.</p>

</div>
</div>
<a id="a58179619963ba32ecad140e7e8e55488"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58179619963ba32ecad140e7e8e55488">&#9670;&nbsp;</a></span>formatmessage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ByteStream::formatmessage </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Formats the message string, looks up the external representation and writes it to the specified stream.</p>
<p>Looks up the message and writes it to the specified stream. </p>

</div>
</div>
<a id="a36ec6d680202c1658f4967063b96ca8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36ec6d680202c1658f4967063b96ca8c">&#9670;&nbsp;</a></span>get_stdin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGP.html">GP</a>&lt; <a class="el" href="classByteStream.html">ByteStream</a> &gt; ByteStream::get_stdin </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>mode</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Easy access to preallocated stdin/stdout/stderr bytestreams </p>

</div>
</div>
<a id="ab99df3538376936ff06e1462b3bd8061"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab99df3538376936ff06e1462b3bd8061">&#9670;&nbsp;</a></span>getAsNative()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGNativeString.html">GNativeString</a> ByteStream::getAsNative </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the contents of the file as a <a class="el" href="classGNativeString.html">GNativeString</a> </p>

</div>
</div>
<a id="a5d7c5782f9f8edc2d5c1eccbf364e20c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d7c5782f9f8edc2d5c1eccbf364e20c">&#9670;&nbsp;</a></span>getAsUTF8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGUTF8String.html">GUTF8String</a> ByteStream::getAsUTF8 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the contents of the file as a <a class="el" href="classGUTF8String.html">GUTF8String</a> </p>

</div>
</div>
<a id="ae69bbdbc77545f72488bde0639ae0e95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae69bbdbc77545f72488bde0639ae0e95">&#9670;&nbsp;</a></span>read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t ByteStream::read </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reads data from a <a class="el" href="classByteStream.html">ByteStream</a>. This function {<em>must}</em> be implemented by each subclass of <a class="el" href="classByteStream.html">ByteStream</a>#. At most <a class="el" href="classByteStream.html#aa33b66a4401b7ab98953158b766a8dec">size</a># bytes are read from the <a class="el" href="classByteStream.html">ByteStream</a> and stored in the memory area pointed to by #buffer#. Function <a class="el" href="classByteStream.html#ae69bbdbc77545f72488bde0639ae0e95">read</a># returns immediately if <a class="el" href="classByteStream.html#aa33b66a4401b7ab98953158b766a8dec">size</a># is zero. The actual number of bytes read is returned. Function <a class="el" href="classByteStream.html#ae69bbdbc77545f72488bde0639ae0e95">read</a># returns a number of bytes smaller than <a class="el" href="classByteStream.html#aa33b66a4401b7ab98953158b766a8dec">size</a># if the end-of-file mark is reached before filling the buffer. Subsequent invocations will always return value #0#. Function <a class="el" href="classByteStream.html#ae69bbdbc77545f72488bde0639ae0e95">read</a># may also return a value greater than zero but smaller than <a class="el" href="classByteStream.html#aa33b66a4401b7ab98953158b766a8dec">size</a># for internal reasons. Programs must be ready to handle these cases or use function \Ref{readall}. Exception \Ref{<a class="el" href="classGException.html">GException</a>} is thrown with a plain text error message whenever an error occurs. </p>

<p>Reimplemented in <a class="el" href="classByteStream_1_1Static.html#a7718d865c958538aa373e9c3bd0c2a54">ByteStream::Static</a>, <a class="el" href="classBSByteStream_1_1Decode.html#a861396dfe4dcc21160dc47619ee962a4">BSByteStream::Decode</a>, <a class="el" href="classPoolByteStream.html#ab8125b1378c6d78921cc4416569a91d8">PoolByteStream</a>, <a class="el" href="classBufferByteStream.html#a4b0a1cca421ba6743a4e2322233e0b49">BufferByteStream</a>, <a class="el" href="classByteStream_1_1Memory.html#a60d433b8501529d1fa640de85f4433ad">ByteStream::Memory</a>, <a class="el" href="classByteStream_1_1Stdio.html#a9d10abdb8459f59dcd79b909a744a1ab">ByteStream::Stdio</a>, <a class="el" href="classUnicodeByteStream.html#a88f426e151bc987841d82bc90e36e3b0">UnicodeByteStream</a>, <a class="el" href="classParsingByteStream.html#a7bfb355d44014c17a219ecafd5c5694e">ParsingByteStream</a>, and <a class="el" href="classProgressByteStream.html#a6765b3d844e5e37bfa8fa710c89de7d3">ProgressByteStream</a>.</p>

</div>
</div>
<a id="a5f57554fc3da020731631f0e6a45d5e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f57554fc3da020731631f0e6a45d5e7">&#9670;&nbsp;</a></span>read16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ByteStream::read16 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a two-bytes integer from a <a class="el" href="classByteStream.html">ByteStream</a>. The integer most significant byte is read first, regardless of the processor endianness. </p>

</div>
</div>
<a id="a10723e7f4212afc31e8c77899eceb2d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10723e7f4212afc31e8c77899eceb2d3">&#9670;&nbsp;</a></span>read24()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ByteStream::read24 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a three-bytes integer from a <a class="el" href="classByteStream.html">ByteStream</a>. The integer most significant byte is read first, regardless of the processor endianness. </p>

</div>
</div>
<a id="ab1d5bbdb9b37193257095c7465b34453"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1d5bbdb9b37193257095c7465b34453">&#9670;&nbsp;</a></span>read32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ByteStream::read32 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a four-bytes integer from a <a class="el" href="classByteStream.html">ByteStream</a>. The integer most significant bytes are read first, regardless of the processor endianness. </p>

</div>
</div>
<a id="ab882f4e4e2ef82b1935381b25a2ddf89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab882f4e4e2ef82b1935381b25a2ddf89">&#9670;&nbsp;</a></span>read8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ByteStream::read8 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a one-byte integer from a <a class="el" href="classByteStream.html">ByteStream</a>. </p>

</div>
</div>
<a id="a89ab1c5568227e3c8e45968178d78f5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89ab1c5568227e3c8e45968178d78f5b">&#9670;&nbsp;</a></span>readall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ByteStream::readall </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads data and blocks until everything has been read. This function is essentially similar to function <a class="el" href="classByteStream.html#ae69bbdbc77545f72488bde0639ae0e95">read</a>#. Unlike function <a class="el" href="classByteStream.html#ae69bbdbc77545f72488bde0639ae0e95">read</a># however, function <a class="el" href="classByteStream.html#a89ab1c5568227e3c8e45968178d78f5b">readall</a># will never return a value smaller than <a class="el" href="classByteStream.html#aa33b66a4401b7ab98953158b766a8dec">size</a># unless an end-of-file mark is reached. This is implemented by repeatedly calling function <a class="el" href="classByteStream.html#ae69bbdbc77545f72488bde0639ae0e95">read</a># until everything is read or until we reach an end-of-file mark. Note that <a class="el" href="classByteStream.html#ae69bbdbc77545f72488bde0639ae0e95">read</a># and <a class="el" href="classByteStream.html#a89ab1c5568227e3c8e45968178d78f5b">readall</a># are equivalent when <a class="el" href="classByteStream.html#aa33b66a4401b7ab98953158b766a8dec">size</a># is one. </p>

</div>
</div>
<a id="ae6eb7cb9411fb20f1778bc290f2417be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6eb7cb9411fb20f1778bc290f2417be">&#9670;&nbsp;</a></span>readat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t ByteStream::readat </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reads data from a random position. This function reads at most #sz# bytes at position #pos# into #buffer# and returns the actual number of bytes read. The current position is unchanged. </p>

<p>Reimplemented in <a class="el" href="classByteStream_1_1Memory.html#aaa4f7467497ab8ba789f5c3280a35d9b">ByteStream::Memory</a>.</p>

</div>
</div>
<a id="a601ef5bf4d183b262472e1e1f7c9a2ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a601ef5bf4d183b262472e1e1f7c9a2ad">&#9670;&nbsp;</a></span>seek()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ByteStream::seek </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>whence</em> = <code>SEEK_SET</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>nothrow</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the current position for reading or writing the <a class="el" href="classByteStream.html">ByteStream</a>. <a class="el" href="structClass.html">Class</a> <a class="el" href="classByteStream.html">ByteStream</a># provides a default implementation able to seek forward by calling function <a class="el" href="classByteStream.html#ae69bbdbc77545f72488bde0639ae0e95">read</a># until reaching the desired position. Subclasses implementing better seek capabilities must override this default implementation. The new current position is computed by applying displacement #offset# to the position represented by argument #whence#. The following values are recognized for argument #whence#: \begin{description} \item[#SEEK_SET#] Argument #offset# indicates the position relative to the beginning of the <a class="el" href="classByteStream.html">ByteStream</a>. \item[#SEEK_CUR#] Argument #offset# is a signed displacement relative to the current position. \item[#SEEK_END#] Argument #offset# is a displacement relative to the end of the file. It is then advisable to provide a negative value for #offset#. \end{description} Results are undefined whenever the new position is greater than the total size of the <a class="el" href="classByteStream.html">ByteStream</a>.</p>
<p>{\bf Error reporting}: If <a class="el" href="classByteStream.html#a601ef5bf4d183b262472e1e1f7c9a2ad">seek()</a># succeeds, #0# is returned. Otherwise it either returns #-1# (if #nothrow# is set to #FALSE#) or throws the \Ref{<a class="el" href="classGException.html">GException</a>} exception. </p>

<p>Reimplemented in <a class="el" href="classPoolByteStream.html#ac9c8275542763851fd60d39ac6a6161d">PoolByteStream</a>, <a class="el" href="classByteStream_1_1Static.html#a55f5da568dee41a9281adf2a88e36409">ByteStream::Static</a>, <a class="el" href="classByteStream_1_1Memory.html#a8d51e2b55083bc2c5051e6ee211e8240">ByteStream::Memory</a>, <a class="el" href="classByteStream_1_1Stdio.html#a192cea80ee0b71c24abf66177d71f960">ByteStream::Stdio</a>, <a class="el" href="classUnicodeByteStream.html#a0c9db9bd7041e995519d37531632a970">UnicodeByteStream</a>, and <a class="el" href="classProgressByteStream.html#aad514adb9a446d6827822800d41609d7">ProgressByteStream</a>.</p>

</div>
</div>
<a id="aa33b66a4401b7ab98953158b766a8dec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa33b66a4401b7ab98953158b766a8dec">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long ByteStream::size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the total number of bytes contained in the buffer, file, etc. Valid offsets for function <a class="el" href="classByteStream.html#a601ef5bf4d183b262472e1e1f7c9a2ad">seek</a># range from 0 to the value returned by this function. </p>

<p>Reimplemented in <a class="el" href="classByteStream_1_1Static.html#a98aeb63d88d360dacb5daa067b51c5e2">ByteStream::Static</a>, and <a class="el" href="classByteStream_1_1Memory.html#a1c7b52e3f451a4721f93c71791283e99">ByteStream::Memory</a>.</p>

</div>
</div>
<a id="a6379ec44f814a160980d2dd5c5e25672"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6379ec44f814a160980d2dd5c5e25672">&#9670;&nbsp;</a></span>tell()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual long ByteStream::tell </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the offset of the current position in the <a class="el" href="classByteStream.html">ByteStream</a>. This function {<em>must}</em> be implemented by each subclass of <a class="el" href="classByteStream.html">ByteStream</a>#. </p>

<p>Implemented in <a class="el" href="classPoolByteStream.html#a33cc04b23aef2260f5b757c6688a43c3">PoolByteStream</a>, <a class="el" href="classByteStream_1_1Static.html#a12b0e484d381e8f0d5e4326a68b98dbb">ByteStream::Static</a>, <a class="el" href="classBSByteStream.html#a3afd626c4c292d4fae7527cb82f84540">BSByteStream</a>, <a class="el" href="classBufferByteStream.html#a0f1985c286115798af846a157e2aa701">BufferByteStream</a>, <a class="el" href="classByteStream_1_1Memory.html#a1225e6b4cc7bd2cba6ff6852d5a977c8">ByteStream::Memory</a>, <a class="el" href="classByteStream_1_1Stdio.html#aa6fd0dd5fdcf2f392f9ad7611ed58ed9">ByteStream::Stdio</a>, <a class="el" href="classUnicodeByteStream.html#aa151728b4d17b8f7d20dca4c3de0ee39">UnicodeByteStream</a>, <a class="el" href="classProgressByteStream.html#a2e078affe7e26a2d03878a112bc0de22">ProgressByteStream</a>, and <a class="el" href="classParsingByteStream.html#a643cec829dbb0c3234720da018df10cd">ParsingByteStream</a>.</p>

</div>
</div>
<a id="ae5783e755c524b6c5deb0644148a0f23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5783e755c524b6c5deb0644148a0f23">&#9670;&nbsp;</a></span>writall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ByteStream::writall </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes data and blocks until everything has been written. This function is essentially similar to function <a class="el" href="classByteStream.html#ac10e950d655e5dabb93af44e3a5da855">write</a>#. Unlike function <a class="el" href="classByteStream.html#ac10e950d655e5dabb93af44e3a5da855">write</a># however, function <a class="el" href="classByteStream.html#ae5783e755c524b6c5deb0644148a0f23">writall</a># will only return after all <a class="el" href="classByteStream.html#aa33b66a4401b7ab98953158b766a8dec">size</a># bytes have been written. This is implemented by repeatedly calling function <a class="el" href="classByteStream.html#ac10e950d655e5dabb93af44e3a5da855">write</a># until everything is written. Note that <a class="el" href="classByteStream.html#ac10e950d655e5dabb93af44e3a5da855">write</a># and <a class="el" href="classByteStream.html#ae5783e755c524b6c5deb0644148a0f23">writall</a># are equivalent when <a class="el" href="classByteStream.html#aa33b66a4401b7ab98953158b766a8dec">size</a># is one. </p>

</div>
</div>
<a id="ac10e950d655e5dabb93af44e3a5da855"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac10e950d655e5dabb93af44e3a5da855">&#9670;&nbsp;</a></span>write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t ByteStream::write </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Writes data to a <a class="el" href="classByteStream.html">ByteStream</a>. This function {<em>must}</em> be implemented by each subclass of <a class="el" href="classByteStream.html">ByteStream</a>#. At most <a class="el" href="classByteStream.html#aa33b66a4401b7ab98953158b766a8dec">size</a># bytes from buffer #buffer# are written to the <a class="el" href="classByteStream.html">ByteStream</a>. Function <a class="el" href="classByteStream.html#ac10e950d655e5dabb93af44e3a5da855">write</a># returns immediately if <a class="el" href="classByteStream.html#aa33b66a4401b7ab98953158b766a8dec">size</a># is zero. The actual number of bytes written is returned. Function <a class="el" href="classByteStream.html#ac10e950d655e5dabb93af44e3a5da855">write</a># may also return a value greater than zero but smaller than <a class="el" href="classByteStream.html#aa33b66a4401b7ab98953158b766a8dec">size</a># for internal reasons. Programs must be ready to handle these cases or use function \Ref{writall}. Exception \Ref{<a class="el" href="classGException.html">GException</a>} is thrown with a plain text error message whenever an error occurs. </p>

<p>Reimplemented in <a class="el" href="classBSByteStream_1_1Encode.html#a5c0043a6ee547295e0823f42c6a115ca">BSByteStream::Encode</a>, <a class="el" href="classPoolByteStream.html#a8b387a0bd5461b0e4c63074472eec3d1">PoolByteStream</a>, <a class="el" href="classBufferByteStream.html#a943a9cb6c371761c040a500e872faa4a">BufferByteStream</a>, <a class="el" href="classByteStream_1_1Memory.html#a353c576bec160e97db7f605fc980a7ef">ByteStream::Memory</a>, <a class="el" href="classByteStream_1_1Stdio.html#ab98ef3346548c05494029037a043c3bc">ByteStream::Stdio</a>, <a class="el" href="classUnicodeByteStream.html#a45551e912ba53a602afd5a72dab8cdc8">UnicodeByteStream</a>, <a class="el" href="classParsingByteStream.html#a9fb4a9d80d38985c18d9fa04a9ebcece">ParsingByteStream</a>, and <a class="el" href="classProgressByteStream.html#a34653763e2d1b81b7d5c3c2a266c8d2f">ProgressByteStream</a>.</p>

</div>
</div>
<a id="aba0c903ed8b120f804f7c45c6de26f6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba0c903ed8b120f804f7c45c6de26f6f">&#9670;&nbsp;</a></span>write16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ByteStream::write16 </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>card16</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes a two-bytes integer to a <a class="el" href="classByteStream.html">ByteStream</a>. The integer most significant byte is written first, regardless of the processor endianness. </p>

</div>
</div>
<a id="a176da3627a17900cbdd95549c3c1a0c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a176da3627a17900cbdd95549c3c1a0c8">&#9670;&nbsp;</a></span>write24()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ByteStream::write24 </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>card24</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes a three-bytes integer to a <a class="el" href="classByteStream.html">ByteStream</a>. The integer most significant byte is written first, regardless of the processor endianness. </p>

</div>
</div>
<a id="a76ae6a61bd5c6db5d81dc95cb530cfb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76ae6a61bd5c6db5d81dc95cb530cfb0">&#9670;&nbsp;</a></span>write32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ByteStream::write32 </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>card32</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes a four-bytes integer to a <a class="el" href="classByteStream.html">ByteStream</a>. The integer most significant bytes are written first, regardless of the processor endianness. </p>

</div>
</div>
<a id="a674300c4bedd4205bad3263d9159a33a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a674300c4bedd4205bad3263d9159a33a">&#9670;&nbsp;</a></span>write8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ByteStream::write8 </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>card8</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes a one-byte integer to a <a class="el" href="classByteStream.html">ByteStream</a>. </p>

</div>
</div>
<a id="a4ab1c9315f01f695d7a2375c9bc54b94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ab1c9315f01f695d7a2375c9bc54b94">&#9670;&nbsp;</a></span>writemessage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ByteStream::writemessage </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Looks up the message and writes it to the specified stream. </p>

</div>
</div>
<a id="a3f5df9e9adbe3b37970f72c698ca1e80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f5df9e9adbe3b37970f72c698ca1e80">&#9670;&nbsp;</a></span>writestring() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ByteStream::writestring </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGNativeString.html">GNativeString</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes the string as is, to the specified stream. </p>

</div>
</div>
<a id="a49bd373dca4e0c6bbdd509b9ad7de42c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49bd373dca4e0c6bbdd509b9ad7de42c">&#9670;&nbsp;</a></span>writestring() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ByteStream::writestring </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGUTF8String.html">GUTF8String</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes the string as is, to the specified stream. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a6a752fb635ed48366afad0719be4ef08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a752fb635ed48366afad0719be4ef08">&#9670;&nbsp;</a></span>EndOfFile</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * ByteStream::EndOfFile =ERR_MSG(&quot;EOF&quot;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the conventional name for EOF exceptions </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>libdjvu/<a class="el" href="ByteStream_8h_source.html">ByteStream.h</a></li>
<li>libdjvu/Arrays.cpp</li>
<li>libdjvu/ByteStream.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
