<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: GBitmap Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classGBitmap-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">GBitmap Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="GBitmap_8h_source.html">GBitmap.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for GBitmap:</div>
<div class="dyncontent">
<div class="center"><img src="classGBitmap__inherit__graph.png" border="0" usemap="#GBitmap_inherit__map" alt="Inheritance graph"/></div>
<map name="GBitmap_inherit__map" id="GBitmap_inherit__map">
<area shape="rect" title=" " alt="" coords="12,80,91,107"/>
<area shape="rect" href="classGPEnabled.html" title=" " alt="" coords="5,5,97,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for GBitmap:</div>
<div class="dyncontent">
<div class="center"><img src="classGBitmap__coll__graph.png" border="0" usemap="#GBitmap_coll__map" alt="Collaboration graph"/></div>
<map name="GBitmap_coll__map" id="GBitmap_coll__map">
<area shape="rect" title=" " alt="" coords="661,61,740,88"/>
<area shape="rect" href="classGPEnabled.html" title=" " alt="" coords="5,5,97,32"/>
<area shape="rect" href="classGPBase.html" title=" " alt="" coords="187,31,259,57"/>
<area shape="rect" href="classGPBuffer.html" title=" " alt="" coords="353,82,507,123"/>
<area shape="rect" href="classGPBufferBase.html" title=" " alt="" coords="168,125,279,152"/>
<area shape="rect" href="classGPBuffer.html" title=" " alt="" coords="353,147,507,189"/>
<area shape="rect" href="classGP.html" title=" " alt="" coords="328,31,532,57"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGBitmap_1_1ZeroBuffer.html">ZeroBuffer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3b09711f6b528f4cd90b1d5057d3d886"><td class="memItemLeft" align="right" valign="top"><a id="a3b09711f6b528f4cd90b1d5057d3d886"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>destroy</b> (void)</td></tr>
<tr class="separator:a3b09711f6b528f4cd90b1d5057d3d886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Initialization.</div></td></tr>
<tr class="memitem:a9c33272be5ddb95fef2087a4310cbe3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGBitmap.html#a9c33272be5ddb95fef2087a4310cbe3a">init</a> (int nrows, int ncolumns, int border=0)</td></tr>
<tr class="separator:a9c33272be5ddb95fef2087a4310cbe3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7266ecb2deb89cfd50db59ad49482652"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGBitmap.html#a7266ecb2deb89cfd50db59ad49482652">init</a> (const <a class="el" href="classGBitmap.html">GBitmap</a> &amp;ref, int border=0)</td></tr>
<tr class="separator:a7266ecb2deb89cfd50db59ad49482652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cdb3138e30b689a17f6e24d4a8c2460"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGBitmap.html#a3cdb3138e30b689a17f6e24d4a8c2460">init</a> (const <a class="el" href="classGBitmap.html">GBitmap</a> &amp;ref, const <a class="el" href="classGRect.html">GRect</a> &amp;rect, int border=0)</td></tr>
<tr class="separator:a3cdb3138e30b689a17f6e24d4a8c2460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a025a599af33edd476739e11045a867c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGBitmap.html#a025a599af33edd476739e11045a867c7">init</a> (<a class="el" href="classByteStream.html">ByteStream</a> &amp;ref, int border=0)</td></tr>
<tr class="separator:a025a599af33edd476739e11045a867c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d22e48fe302d9f3ee840d6df4c39159"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGBitmap.html">GBitmap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGBitmap.html#a8d22e48fe302d9f3ee840d6df4c39159">operator=</a> (const <a class="el" href="classGBitmap.html">GBitmap</a> &amp;ref)</td></tr>
<tr class="separator:a8d22e48fe302d9f3ee840d6df4c39159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7338fa0f63ddcf387b3ed600d1b5bbbe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGBitmap.html#a7338fa0f63ddcf387b3ed600d1b5bbbe">fill</a> (unsigned char value)</td></tr>
<tr class="separator:a7338fa0f63ddcf387b3ed600d1b5bbbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Accessing the pixels.</div></td></tr>
<tr class="memitem:a26b93e377634a1d987891f76ede12f19"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGBitmap.html#a26b93e377634a1d987891f76ede12f19">rows</a> () const</td></tr>
<tr class="separator:a26b93e377634a1d987891f76ede12f19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a832aa406493c7279ae3a1a9ba36ba5c0"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGBitmap.html#a832aa406493c7279ae3a1a9ba36ba5c0">columns</a> () const</td></tr>
<tr class="separator:a832aa406493c7279ae3a1a9ba36ba5c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a913f235312cacfca2ecb1e0bee28dd8b"><td class="memItemLeft" align="right" valign="top">const unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGBitmap.html#a913f235312cacfca2ecb1e0bee28dd8b">operator[]</a> (int row) const</td></tr>
<tr class="separator:a913f235312cacfca2ecb1e0bee28dd8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ea910fa9f2131abd63be2bd57e26eb9"><td class="memItemLeft" align="right" valign="top">unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGBitmap.html#a0ea910fa9f2131abd63be2bd57e26eb9">operator[]</a> (int row)</td></tr>
<tr class="separator:a0ea910fa9f2131abd63be2bd57e26eb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adedb71b850f07744201ad0ee0a4756f7"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGBitmap.html#adedb71b850f07744201ad0ee0a4756f7">rowsize</a> () const</td></tr>
<tr class="separator:adedb71b850f07744201ad0ee0a4756f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a16be0e063dcab9046581ae2afdd3ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGBitmap.html#a0a16be0e063dcab9046581ae2afdd3ee">minborder</a> (int minimum)</td></tr>
<tr class="separator:a0a16be0e063dcab9046581ae2afdd3ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Managing gray levels.</div></td></tr>
<tr class="memitem:a020b42ff0ef5fea675f30252eabfad4a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGBitmap.html#a020b42ff0ef5fea675f30252eabfad4a">get_grays</a> () const</td></tr>
<tr class="separator:a020b42ff0ef5fea675f30252eabfad4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f205dd8631d74fe66abbf8c8103953f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGBitmap.html#a1f205dd8631d74fe66abbf8c8103953f">set_grays</a> (int grays)</td></tr>
<tr class="separator:a1f205dd8631d74fe66abbf8c8103953f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bd82b9d6776bd0aed1b8fcc8258ed7e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGBitmap.html#a0bd82b9d6776bd0aed1b8fcc8258ed7e">change_grays</a> (int grays)</td></tr>
<tr class="separator:a0bd82b9d6776bd0aed1b8fcc8258ed7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eca6b8830c1edada7bc145d9de315f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGBitmap.html#a7eca6b8830c1edada7bc145d9de315f5">binarize_grays</a> (int threshold=0)</td></tr>
<tr class="separator:a7eca6b8830c1edada7bc145d9de315f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Optimizing the memory usage.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><br  />
 The amount of memory used by bilevel images can be reduced using function \Ref{compress}, which encodes the image using a run-length encoding scheme. The bracket operator decompresses the image on demand. A few highly optimized functions (e.g. \Ref{blit}) can use a run-length encoded bitmap without decompressing it. There are unfortunate locking issues associated with this capability (c.f. \Ref{share} and \Ref{monitor}). </p>
</div></td></tr>
<tr class="memitem:a5204ead23ad993af5c23653374cfdac6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGBitmap.html#a5204ead23ad993af5c23653374cfdac6">compress</a> ()</td></tr>
<tr class="separator:a5204ead23ad993af5c23653374cfdac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2244bdca28d95f698759b690ad37d204"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGBitmap.html#a2244bdca28d95f698759b690ad37d204">uncompress</a> ()</td></tr>
<tr class="separator:a2244bdca28d95f698759b690ad37d204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab820fa24b0f604525824e730912427e8"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGBitmap.html#ab820fa24b0f604525824e730912427e8">get_memory_usage</a> () const</td></tr>
<tr class="separator:ab820fa24b0f604525824e730912427e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4b02d29e39c0c5c97fe10b56640707c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGMonitor.html">GMonitor</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGBitmap.html#ac4b02d29e39c0c5c97fe10b56640707c">monitor</a> () const</td></tr>
<tr class="separator:ac4b02d29e39c0c5c97fe10b56640707c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01acec46ce509879747ade5858b96750"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGBitmap.html#a01acec46ce509879747ade5858b96750">share</a> ()</td></tr>
<tr class="separator:a01acec46ce509879747ade5858b96750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Additive Blit.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><br  />
 The blit functions are designed to efficiently construct an anti-aliased image by copying smaller images at predefined locations. The image of a page, for instance, is composed by copying the images of characters at predefined locations. These functions are fairly optimized. They can directly use compressed GBitmaps (see \Ref{compress}). We consider in this section that each <a class="el" href="classGBitmap.html">GBitmap</a> comes with a coordinate system defined as follows. Position (#0#,#0#) corresponds to the bottom left corner of the bottom left pixel. Position (#1#,#1#) corresponds to the top right corner of the bottom left pixel, which is also the bottom left corner of the second pixel of the second row. Position (#w#,#h#), where #w# and #h# denote the size of the <a class="el" href="classGBitmap.html">GBitmap</a>, corresponds to the top right corner of the top right pixel. </p>
</div></td></tr>
<tr class="memitem:a8480f698e247c866153a5debe10fb95c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGBitmap.html#a8480f698e247c866153a5debe10fb95c">blit</a> (const <a class="el" href="classGBitmap.html">GBitmap</a> *bm, int x, int y)</td></tr>
<tr class="separator:a8480f698e247c866153a5debe10fb95c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00cb19719135c453eda2240f4f76782b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGBitmap.html#a00cb19719135c453eda2240f4f76782b">blit</a> (const <a class="el" href="classGBitmap.html">GBitmap</a> *shape, int x, int y, int subsample)</td></tr>
<tr class="separator:a00cb19719135c453eda2240f4f76782b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Saving images.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><br  />
 The following functions write PBM, PGM and RLE files. PBM and PGM are well known formats for bilevel and gray-level images. The RLE is a simple run-length encoding scheme for bilevel images. These files can be read using the <a class="el" href="classByteStream.html">ByteStream</a> based constructor or initialization function. See \Ref{PNM and RLE file formats} for more information. </p>
</div></td></tr>
<tr class="memitem:ab08cbb17f67a1c04e3f5bcef3064d93a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGBitmap.html#ab08cbb17f67a1c04e3f5bcef3064d93a">save_pbm</a> (<a class="el" href="classByteStream.html">ByteStream</a> &amp;bs, int raw=1)</td></tr>
<tr class="separator:ab08cbb17f67a1c04e3f5bcef3064d93a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae84537e31a15ce2a4cf64aefa73ef5f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGBitmap.html#ae84537e31a15ce2a4cf64aefa73ef5f0">save_pgm</a> (<a class="el" href="classByteStream.html">ByteStream</a> &amp;bs, int raw=1)</td></tr>
<tr class="separator:ae84537e31a15ce2a4cf64aefa73ef5f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f860c0b7817d1ed69950d068abe90bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGBitmap.html#a0f860c0b7817d1ed69950d068abe90bf">save_rle</a> (<a class="el" href="classByteStream.html">ByteStream</a> &amp;bs)</td></tr>
<tr class="separator:a0f860c0b7817d1ed69950d068abe90bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classGPEnabled"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classGPEnabled')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classGPEnabled.html">GPEnabled</a></td></tr>
<tr class="memitem:a9e5f12f17477e448d1fc08e37cb9d2dd inherit pub_methods_classGPEnabled"><td class="memItemLeft" align="right" valign="top"><a id="a9e5f12f17477e448d1fc08e37cb9d2dd"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGPEnabled.html#a9e5f12f17477e448d1fc08e37cb9d2dd">~GPEnabled</a> ()</td></tr>
<tr class="memdesc:a9e5f12f17477e448d1fc08e37cb9d2dd inherit pub_methods_classGPEnabled"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual destructor. <br /></td></tr>
<tr class="separator:a9e5f12f17477e448d1fc08e37cb9d2dd inherit pub_methods_classGPEnabled"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af197d1b7ec283031880818fd05fdd2f9 inherit pub_methods_classGPEnabled"><td class="memItemLeft" align="right" valign="top"><a id="af197d1b7ec283031880818fd05fdd2f9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGPEnabled.html#af197d1b7ec283031880818fd05fdd2f9">GPEnabled</a> ()</td></tr>
<tr class="memdesc:af197d1b7ec283031880818fd05fdd2f9 inherit pub_methods_classGPEnabled"><td class="mdescLeft">&#160;</td><td class="mdescRight">Null constructor. <br /></td></tr>
<tr class="separator:af197d1b7ec283031880818fd05fdd2f9 inherit pub_methods_classGPEnabled"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2875b20558241302927c11dea068b6a inherit pub_methods_classGPEnabled"><td class="memItemLeft" align="right" valign="top"><a id="ae2875b20558241302927c11dea068b6a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGPEnabled.html#ae2875b20558241302927c11dea068b6a">GPEnabled</a> (const <a class="el" href="classGPEnabled.html">GPEnabled</a> &amp;obj)</td></tr>
<tr class="memdesc:ae2875b20558241302927c11dea068b6a inherit pub_methods_classGPEnabled"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy construcotr. <br /></td></tr>
<tr class="separator:ae2875b20558241302927c11dea068b6a inherit pub_methods_classGPEnabled"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4604c98eff7df30c6071bacdbc6693aa inherit pub_methods_classGPEnabled"><td class="memItemLeft" align="right" valign="top"><a id="a4604c98eff7df30c6071bacdbc6693aa"></a>
<a class="el" href="classGPEnabled.html">GPEnabled</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGPEnabled.html#a4604c98eff7df30c6071bacdbc6693aa">operator=</a> (const <a class="el" href="classGPEnabled.html">GPEnabled</a> &amp;obj)</td></tr>
<tr class="memdesc:a4604c98eff7df30c6071bacdbc6693aa inherit pub_methods_classGPEnabled"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy operator. <br /></td></tr>
<tr class="separator:a4604c98eff7df30c6071bacdbc6693aa inherit pub_methods_classGPEnabled"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff96ec9203073e902735c5b6b1f650a0 inherit pub_methods_classGPEnabled"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGPEnabled.html#aff96ec9203073e902735c5b6b1f650a0">get_count</a> (void) const</td></tr>
<tr class="separator:aff96ec9203073e902735c5b6b1f650a0 inherit pub_methods_classGPEnabled"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Construction.</div></td></tr>
<tr class="memitem:a3183f6375c60073209586060f908d9ef"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGP.html">GP</a>&lt; <a class="el" href="classGBitmap.html">GBitmap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGBitmap.html#a3183f6375c60073209586060f908d9ef">create</a> (void)</td></tr>
<tr class="separator:a3183f6375c60073209586060f908d9ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0687095c32571d41b2faaa533973bbec"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGP.html">GP</a>&lt; <a class="el" href="classGBitmap.html">GBitmap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGBitmap.html#a0687095c32571d41b2faaa533973bbec">create</a> (const int nrows, const int ncolumns, const int border=0)</td></tr>
<tr class="separator:a0687095c32571d41b2faaa533973bbec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add8c9490fbe77215e759eb9bb5b6f565"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGP.html">GP</a>&lt; <a class="el" href="classGBitmap.html">GBitmap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGBitmap.html#add8c9490fbe77215e759eb9bb5b6f565">create</a> (const <a class="el" href="classGBitmap.html">GBitmap</a> &amp;ref)</td></tr>
<tr class="separator:add8c9490fbe77215e759eb9bb5b6f565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5603e4c5d424a9cd559f8e3c1aa2ff4b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGP.html">GP</a>&lt; <a class="el" href="classGBitmap.html">GBitmap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGBitmap.html#a5603e4c5d424a9cd559f8e3c1aa2ff4b">create</a> (const <a class="el" href="classGBitmap.html">GBitmap</a> &amp;ref, const int border)</td></tr>
<tr class="separator:a5603e4c5d424a9cd559f8e3c1aa2ff4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9ac7fb9e984fea1ed9d8179d128dc0e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGP.html">GP</a>&lt; <a class="el" href="classGBitmap.html">GBitmap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGBitmap.html#ae9ac7fb9e984fea1ed9d8179d128dc0e">create</a> (const <a class="el" href="classGBitmap.html">GBitmap</a> &amp;ref, const <a class="el" href="classGRect.html">GRect</a> &amp;rect, const int border=0)</td></tr>
<tr class="separator:ae9ac7fb9e984fea1ed9d8179d128dc0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a204e3d4608c80dd742cd673b556ded88"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGP.html">GP</a>&lt; <a class="el" href="classGBitmap.html">GBitmap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGBitmap.html#a204e3d4608c80dd742cd673b556ded88">create</a> (<a class="el" href="classByteStream.html">ByteStream</a> &amp;ref, const int border=0)</td></tr>
<tr class="separator:a204e3d4608c80dd742cd673b556ded88"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a6d274497aecd1dc040960081717cdad9"><td class="memItemLeft" align="right" valign="top"><a id="a6d274497aecd1dc040960081717cdad9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>GBitmap</b> (int nrows, int ncolumns, int border=0)</td></tr>
<tr class="separator:a6d274497aecd1dc040960081717cdad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a288c13b7acb6b5d59e6ca3668f302173"><td class="memItemLeft" align="right" valign="top"><a id="a288c13b7acb6b5d59e6ca3668f302173"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>GBitmap</b> (const <a class="el" href="classGBitmap.html">GBitmap</a> &amp;ref)</td></tr>
<tr class="separator:a288c13b7acb6b5d59e6ca3668f302173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e2e584e4baf1f9e2feb028a4d884905"><td class="memItemLeft" align="right" valign="top"><a id="a9e2e584e4baf1f9e2feb028a4d884905"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>GBitmap</b> (const <a class="el" href="classGBitmap.html">GBitmap</a> &amp;ref, int border)</td></tr>
<tr class="separator:a9e2e584e4baf1f9e2feb028a4d884905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44cd5af01c131eac2da44a913b080190"><td class="memItemLeft" align="right" valign="top"><a id="a44cd5af01c131eac2da44a913b080190"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>GBitmap</b> (const <a class="el" href="classGBitmap.html">GBitmap</a> &amp;ref, const <a class="el" href="classGRect.html">GRect</a> &amp;rect, int border=0)</td></tr>
<tr class="separator:a44cd5af01c131eac2da44a913b080190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e442b7f570df328341b3dbf22a6011b"><td class="memItemLeft" align="right" valign="top"><a id="a2e442b7f570df328341b3dbf22a6011b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>GBitmap</b> (<a class="el" href="classByteStream.html">ByteStream</a> &amp;ref, int border=0)</td></tr>
<tr class="separator:a2e442b7f570df328341b3dbf22a6011b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Accessing RLE data.</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp8ec67c12cfd55efc43933f93a8fcddfc"></a>The next functions are useful for processing bilevel images encoded using the run length encoding scheme. These functions always return zero if the bitmap is not RLE encoded. Function \Ref{compress} must be used to ensure that the bitmap is RLE encoded. <br  />
 </p>
</td></tr>
<tr class="memitem:a6f24b1c6f4617bd91bf8d649246285a5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGBitmap.html#a6f24b1c6f4617bd91bf8d649246285a5">rle_get_bits</a> (int rowno, unsigned char *bits) const</td></tr>
<tr class="separator:a6f24b1c6f4617bd91bf8d649246285a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeba63149e45bf7c3df0e727b624e0b6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGBitmap.html#adeba63149e45bf7c3df0e727b624e0b6">rle_get_runs</a> (int rowno, int *rlens) const</td></tr>
<tr class="separator:adeba63149e45bf7c3df0e727b624e0b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed863414ad68f8a97f2d66793af4e1ad"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGBitmap.html#aed863414ad68f8a97f2d66793af4e1ad">rle_get_rect</a> (<a class="el" href="classGRect.html">GRect</a> &amp;rect) const</td></tr>
<tr class="separator:aed863414ad68f8a97f2d66793af4e1ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa78fd1c091a53c9a3e8ae9123ecdc54e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGBitmap.html#aa78fd1c091a53c9a3e8ae9123ecdc54e">rle_get_bitmap</a> (const int ncolumns, const unsigned char *&amp;runs, unsigned char *bitmap, const bool invert)</td></tr>
<tr class="separator:aa78fd1c091a53c9a3e8ae9123ecdc54e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Stealing or borrowing the memory buffer (advanced).</h2></td></tr>
<tr class="memitem:a12d8954bd0d5a1ba111bd784c0ea90b4"><td class="memItemLeft" align="right" valign="top"><a id="a12d8954bd0d5a1ba111bd784c0ea90b4"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>MAXRUNSIZE</b> =0x3fff
 }</td></tr>
<tr class="separator:a12d8954bd0d5a1ba111bd784c0ea90b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07a323b59f4a98d84fd2ed5a107c2f05"><td class="memItemLeft" align="right" valign="top"><a id="a07a323b59f4a98d84fd2ed5a107c2f05"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>RUNOVERFLOWVALUE</b> =0xc0
 }</td></tr>
<tr class="separator:a07a323b59f4a98d84fd2ed5a107c2f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa592c8ac6b69c21828b5719c9f19bed7"><td class="memItemLeft" align="right" valign="top"><a id="aa592c8ac6b69c21828b5719c9f19bed7"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>RUNMSBMASK</b> =0x3f
 }</td></tr>
<tr class="separator:aa592c8ac6b69c21828b5719c9f19bed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af589e39f9bd8f25eef3685d4791434c9"><td class="memItemLeft" align="right" valign="top"><a id="af589e39f9bd8f25eef3685d4791434c9"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>RUNLSBMASK</b> =0xff
 }</td></tr>
<tr class="separator:af589e39f9bd8f25eef3685d4791434c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1af765fedc6b20527ce68d003e62268e"><td class="memItemLeft" align="right" valign="top"><a id="a1af765fedc6b20527ce68d003e62268e"></a>
unsigned short&#160;</td><td class="memItemRight" valign="bottom"><b>nrows</b></td></tr>
<tr class="separator:a1af765fedc6b20527ce68d003e62268e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88bc922042a2b83b390266b3c0a97bcd"><td class="memItemLeft" align="right" valign="top"><a id="a88bc922042a2b83b390266b3c0a97bcd"></a>
unsigned short&#160;</td><td class="memItemRight" valign="bottom"><b>ncolumns</b></td></tr>
<tr class="separator:a88bc922042a2b83b390266b3c0a97bcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae789bf23be6a3c28fc5674143a51d7f0"><td class="memItemLeft" align="right" valign="top"><a id="ae789bf23be6a3c28fc5674143a51d7f0"></a>
unsigned short&#160;</td><td class="memItemRight" valign="bottom"><b>border</b></td></tr>
<tr class="separator:ae789bf23be6a3c28fc5674143a51d7f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa130addbe5dbe9945750c8b80dcee6df"><td class="memItemLeft" align="right" valign="top"><a id="aa130addbe5dbe9945750c8b80dcee6df"></a>
unsigned short&#160;</td><td class="memItemRight" valign="bottom"><b>bytes_per_row</b></td></tr>
<tr class="separator:aa130addbe5dbe9945750c8b80dcee6df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a533c3a0dfc824590e3e8b64d3668e92e"><td class="memItemLeft" align="right" valign="top"><a id="a533c3a0dfc824590e3e8b64d3668e92e"></a>
unsigned short&#160;</td><td class="memItemRight" valign="bottom"><b>grays</b></td></tr>
<tr class="separator:a533c3a0dfc824590e3e8b64d3668e92e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab47a42cbefd58deabfeb4ccc73ce198e"><td class="memItemLeft" align="right" valign="top"><a id="ab47a42cbefd58deabfeb4ccc73ce198e"></a>
unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><b>bytes</b></td></tr>
<tr class="separator:ab47a42cbefd58deabfeb4ccc73ce198e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae175151e1d3e802582f33fb9018b3a6a"><td class="memItemLeft" align="right" valign="top"><a id="ae175151e1d3e802582f33fb9018b3a6a"></a>
unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><b>bytes_data</b></td></tr>
<tr class="separator:ae175151e1d3e802582f33fb9018b3a6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad38fe93856599e2083bda21f3bb13dbc"><td class="memItemLeft" align="right" valign="top"><a id="ad38fe93856599e2083bda21f3bb13dbc"></a>
<a class="el" href="classGPBuffer.html">GPBuffer</a>&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>gbytes_data</b></td></tr>
<tr class="separator:ad38fe93856599e2083bda21f3bb13dbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbcd094e1403efbdb9bacf271726087a"><td class="memItemLeft" align="right" valign="top"><a id="acbcd094e1403efbdb9bacf271726087a"></a>
unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><b>rle</b></td></tr>
<tr class="separator:acbcd094e1403efbdb9bacf271726087a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a296d52b3017865b60626826caf796e37"><td class="memItemLeft" align="right" valign="top"><a id="a296d52b3017865b60626826caf796e37"></a>
<a class="el" href="classGPBuffer.html">GPBuffer</a>&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>grle</b></td></tr>
<tr class="separator:a296d52b3017865b60626826caf796e37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d6329dc7605bfd1dc5aa47cb1d502ca"><td class="memItemLeft" align="right" valign="top"><a id="a7d6329dc7605bfd1dc5aa47cb1d502ca"></a>
unsigned char **&#160;</td><td class="memItemRight" valign="bottom"><b>rlerows</b></td></tr>
<tr class="separator:a7d6329dc7605bfd1dc5aa47cb1d502ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4749befec63f423a47679498d97bd61c"><td class="memItemLeft" align="right" valign="top"><a id="a4749befec63f423a47679498d97bd61c"></a>
<a class="el" href="classGPBuffer.html">GPBuffer</a>&lt; unsigned char * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>grlerows</b></td></tr>
<tr class="separator:a4749befec63f423a47679498d97bd61c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2ce8685a122fa097facd2ee64673cb3"><td class="memItemLeft" align="right" valign="top"><a id="ac2ce8685a122fa097facd2ee64673cb3"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>rlelength</b></td></tr>
<tr class="separator:ac2ce8685a122fa097facd2ee64673cb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9654b799ae80a245721479dad96c3ccb"><td class="memItemLeft" align="right" valign="top"><a id="a9654b799ae80a245721479dad96c3ccb"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>ZeroBuffer</b></td></tr>
<tr class="separator:a9654b799ae80a245721479dad96c3ccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bf7dd70dc7c90bb35187270b0cf510f"><td class="memItemLeft" align="right" valign="top"><a id="a6bf7dd70dc7c90bb35187270b0cf510f"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>DjVu_Stream</b></td></tr>
<tr class="separator:a6bf7dd70dc7c90bb35187270b0cf510f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab05b67b1d782ea524df9aab76d702c2"><td class="memItemLeft" align="right" valign="top"><a id="aab05b67b1d782ea524df9aab76d702c2"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>DjVu_PixImage</b></td></tr>
<tr class="separator:aab05b67b1d782ea524df9aab76d702c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adabff4931bb9cdecdc2a77373c6d8ba1"><td class="memItemLeft" align="right" valign="top"><a id="adabff4931bb9cdecdc2a77373c6d8ba1"></a>
<a class="el" href="classGP.html">GP</a>&lt; <a class="el" href="classGBitmap_1_1ZeroBuffer.html">ZeroBuffer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>gzerobuffer</b></td></tr>
<tr class="separator:adabff4931bb9cdecdc2a77373c6d8ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8aab5b49b79f8454a2ca9864ce53680"><td class="memItemLeft" align="right" valign="top">unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGBitmap.html#ac8aab5b49b79f8454a2ca9864ce53680">take_data</a> (size_t &amp;offset)</td></tr>
<tr class="separator:ac8aab5b49b79f8454a2ca9864ce53680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa87afc89907c6e1fc3083cb5c493d70"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGBitmap.html#afa87afc89907c6e1fc3083cb5c493d70">borrow_data</a> (unsigned char &amp;data, int w, int h)</td></tr>
<tr class="separator:afa87afc89907c6e1fc3083cb5c493d70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4ea33759a2c8b514e1d11ccac36ef8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGBitmap.html#ae4ea33759a2c8b514e1d11ccac36ef8f">donate_data</a> (unsigned char *data, int w, int h)</td></tr>
<tr class="separator:ae4ea33759a2c8b514e1d11ccac36ef8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeba0b0841d50cb3d358d3e5cf3a1d3e7"><td class="memItemLeft" align="right" valign="top">const unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGBitmap.html#aeba0b0841d50cb3d358d3e5cf3a1d3e7">get_rle</a> (unsigned int &amp;rle_length)</td></tr>
<tr class="separator:aeba0b0841d50cb3d358d3e5cf3a1d3e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0326f7cb1a6ddca8543d2da37662b7e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGBitmap.html#ab0326f7cb1a6ddca8543d2da37662b7e">donate_rle</a> (unsigned char *rledata, unsigned int rledatalen, int w, int h)</td></tr>
<tr class="separator:ab0326f7cb1a6ddca8543d2da37662b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20ec1cdefbaacc08be5801c7f179a73c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGP.html">GP</a>&lt; <a class="el" href="classGBitmap.html">GBitmap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGBitmap.html#a20ec1cdefbaacc08be5801c7f179a73c">rotate</a> (int <a class="el" href="classGPEnabled.html#aaeebfa533635d29cc70aaa3620678734">count</a>=0)</td></tr>
<tr class="separator:a20ec1cdefbaacc08be5801c7f179a73c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e1cd3f08f8869c557ef57c26510025b"><td class="memItemLeft" align="right" valign="top"><a id="a6e1cd3f08f8869c557ef57c26510025b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>check_border</b> () const</td></tr>
<tr class="separator:a6e1cd3f08f8869c557ef57c26510025b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f96f5f4259de4ee301ab4cc3864ca03"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGBitmap.html#a5f96f5f4259de4ee301ab4cc3864ca03">read_run</a> (const unsigned char *&amp;data)</td></tr>
<tr class="separator:a5f96f5f4259de4ee301ab4cc3864ca03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cf0a4335c0fa3570b89a5c95e401057"><td class="memItemLeft" align="right" valign="top"><a id="a7cf0a4335c0fa3570b89a5c95e401057"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>read_run</b> (unsigned char *&amp;data)</td></tr>
<tr class="separator:a7cf0a4335c0fa3570b89a5c95e401057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9c501fdb8510a1152b62d03ec6d51b8"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGBitmap.html#ad9c501fdb8510a1152b62d03ec6d51b8">append_run</a> (unsigned char *&amp;data, int <a class="el" href="classGPEnabled.html#aaeebfa533635d29cc70aaa3620678734">count</a>)</td></tr>
<tr class="separator:ad9c501fdb8510a1152b62d03ec6d51b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_attribs_classGPEnabled"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classGPEnabled')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classGPEnabled.html">GPEnabled</a></td></tr>
<tr class="memitem:aaeebfa533635d29cc70aaa3620678734 inherit pro_attribs_classGPEnabled"><td class="memItemLeft" align="right" valign="top"><a id="aaeebfa533635d29cc70aaa3620678734"></a>
volatile int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGPEnabled.html#aaeebfa533635d29cc70aaa3620678734">count</a></td></tr>
<tr class="memdesc:aaeebfa533635d29cc70aaa3620678734 inherit pro_attribs_classGPEnabled"><td class="mdescLeft">&#160;</td><td class="mdescRight">The reference counter. <br /></td></tr>
<tr class="separator:aaeebfa533635d29cc70aaa3620678734 inherit pro_attribs_classGPEnabled"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Bilevel and gray-level images. Instances of class <a class="el" href="classGBitmap.html">GBitmap</a># represent bilevel or gray-level images. Images are usually represented using one byte per pixel. Value zero represents a white pixel. A value equal to the number of gray levels minus one represents a black pixel. The number of gray levels is returned by the function \Ref{get_grays} and can be manipulated by the functions \Ref{set_grays} and \Ref{change_grays}.</p>
<p>The bracket operator returns a pointer to the bytes composing one line of the image. This pointer can be used to read or write the image pixels. Line zero represents the bottom line of the image.</p>
<p>The memory organization is setup in such a way that you can safely read a few pixels located in a small border surrounding all four sides of the image. The width of this border can be modified using the function \Ref{minborder}. The border pixels are initialized to zero and therefore represent white pixels. You should never write anything into border pixels because they are shared between images and between lines. <br  />
 </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ad9c501fdb8510a1152b62d03ec6d51b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9c501fdb8510a1152b62d03ec6d51b8">&#9670;&nbsp;</a></span>append_run()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GBitmap::append_run </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Static function for generating run data. This function encoded run length <a class="el" href="classGPEnabled.html#aaeebfa533635d29cc70aaa3620678734" title="The reference counter.">count</a># at position #data# and increments the pointer accordingly. The pointer must initially point to a large enough data buffer. </p>

</div>
</div>
<a id="a7eca6b8830c1edada7bc145d9de315f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eca6b8830c1edada7bc145d9de315f5">&#9670;&nbsp;</a></span>binarize_grays()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GBitmap::binarize_grays </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threshold</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Binarizes a gray level image using a threshold. The number of gray levels is reduced to #2# as in a bilevel image. All pixels whose value was strictly greater than #threshold# are set to black. All other pixels are set to white. </p>

</div>
</div>
<a id="a8480f698e247c866153a5debe10fb95c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8480f698e247c866153a5debe10fb95c">&#9670;&nbsp;</a></span>blit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GBitmap::blit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGBitmap.html">GBitmap</a> *&#160;</td>
          <td class="paramname"><em>bm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs an additive blit of the <a class="el" href="classGBitmap.html">GBitmap</a> #bm#. The <a class="el" href="classGBitmap.html">GBitmap</a> #bm# is first positioned above the current <a class="el" href="classGBitmap.html">GBitmap</a> in such a way that position (#u#,#v#) in <a class="el" href="classGBitmap.html">GBitmap</a> #bm# corresponds to position (#u#+#x#,#v#+#y#) in the current <a class="el" href="classGBitmap.html">GBitmap</a>. The value of each pixel in <a class="el" href="classGBitmap.html">GBitmap</a> #bm# is then added to the value of the corresponding pixel in the current <a class="el" href="classGBitmap.html">GBitmap</a>.</p>
<p>{\bf Example}: Assume for instance that the current <a class="el" href="classGBitmap.html">GBitmap</a> is initially white (all pixels have value zero). This operation copies the pixel values of <a class="el" href="classGBitmap.html">GBitmap</a> #bm# at position (#x#,#y#) into the current <a class="el" href="classGBitmap.html">GBitmap</a>. Note that function <a class="el" href="classGBitmap.html#a8480f698e247c866153a5debe10fb95c">blit</a># does not change the number of gray levels in the current <a class="el" href="classGBitmap.html">GBitmap</a>. You may have to call \Ref{set_grays} to specify how the pixel values should be interpreted. </p>

</div>
</div>
<a id="a00cb19719135c453eda2240f4f76782b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00cb19719135c453eda2240f4f76782b">&#9670;&nbsp;</a></span>blit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GBitmap::blit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGBitmap.html">GBitmap</a> *&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>subsample</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs an additive blit of the <a class="el" href="classGBitmap.html">GBitmap</a> #bm# with anti-aliasing. The <a class="el" href="classGBitmap.html">GBitmap</a> #bm# is first positioned above the current <a class="el" href="classGBitmap.html">GBitmap</a> in such a way that position (#u#,#v#) in <a class="el" href="classGBitmap.html">GBitmap</a> #bm# corresponds to position (#u#+#x#/#subsample#,#v#+#y#/#subsample#) in the current <a class="el" href="classGBitmap.html">GBitmap</a>. This mapping results in a contraction of <a class="el" href="classGBitmap.html">GBitmap</a> #bm# by a factor #subsample#. Each pixel of the current <a class="el" href="classGBitmap.html">GBitmap</a> can be covered by a maximum of #subsample^2# pixels of <a class="el" href="classGBitmap.html">GBitmap</a> #bm#. The value of each pixel in <a class="el" href="classGBitmap.html">GBitmap</a> #bm# is then added to the value of the corresponding pixel in the current <a class="el" href="classGBitmap.html">GBitmap</a>.</p>
<p>{\bf Example}: Assume for instance that the current <a class="el" href="classGBitmap.html">GBitmap</a> is initially white (all pixels have value zero). Each pixel of the current <a class="el" href="classGBitmap.html">GBitmap</a> then contains the sum of the gray levels of the corresponding pixels in <a class="el" href="classGBitmap.html">GBitmap</a> #bm#. There are up to #subsample*subsample# such pixels. If for instance <a class="el" href="classGBitmap.html">GBitmap</a> #bm# is a bilevel image (pixels can be #0# or #1#), the pixels of the current <a class="el" href="classGBitmap.html">GBitmap</a> can take values in range #0# to #subsample*subsample#. Note that function <a class="el" href="classGBitmap.html#a8480f698e247c866153a5debe10fb95c">blit</a># does not change the number of gray levels in the current <a class="el" href="classGBitmap.html">GBitmap</a>. You must call \Ref{set_grays} to indicate that there are #subsample^2+1# gray levels. Since there is at most 256 gray levels, this also means that #subsample# should never be greater than #15#.</p>
<p>{\bf Remark}: Arguments #x# and #y# do not represent a position in the coordinate system of the current <a class="el" href="classGBitmap.html">GBitmap</a>. According to the above discussion, the position is (#x/subsample#,#y/subsample#). In other words, you can position the blit with a sub-pixel resolution. The resulting anti-aliasing changes are paramount to the image quality. </p>

</div>
</div>
<a id="afa87afc89907c6e1fc3083cb5c493d70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa87afc89907c6e1fc3083cb5c493d70">&#9670;&nbsp;</a></span>borrow_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GBitmap::borrow_data </td>
          <td>(</td>
          <td class="paramtype">unsigned char &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes this <a class="el" href="classGBitmap.html">GBitmap</a> by borrowing a memory segment. The <a class="el" href="classGBitmap.html">GBitmap</a> then directly addresses the memory buffer #data# provided by the user. This buffer must be large enough to hold #w*h# bytes representing each one pixel. The <a class="el" href="classGBitmap.html">GBitmap</a> object does not `&lsquo;own&rsquo;' the buffer: you must explicitly de-allocate the buffer using #operator delete []#. This de-allocation should take place after the destruction or the re-initialization of the <a class="el" href="classGBitmap.html">GBitmap</a> object. <br  />
 </p>

</div>
</div>
<a id="a0bd82b9d6776bd0aed1b8fcc8258ed7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bd82b9d6776bd0aed1b8fcc8258ed7e">&#9670;&nbsp;</a></span>change_grays()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GBitmap::change_grays </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>grays</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Changes the number of gray levels. The argument #grays# must be in the range #2# to #256#. All the pixel values are then rescaled and clipped in range #0# to #grays-1#. </p>

</div>
</div>
<a id="a832aa406493c7279ae3a1a9ba36ba5c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a832aa406493c7279ae3a1a9ba36ba5c0">&#9670;&nbsp;</a></span>columns()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int GBitmap::columns </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of columns (the image width). </p>

</div>
</div>
<a id="a5204ead23ad993af5c23653374cfdac6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5204ead23ad993af5c23653374cfdac6">&#9670;&nbsp;</a></span>compress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GBitmap::compress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reduces the memory required for a bilevel image by using a run-length encoded representation. Functions that need to access the pixel array will decompress the image on demand. </p>

</div>
</div>
<a id="a204e3d4608c80dd742cd673b556ded88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a204e3d4608c80dd742cd673b556ded88">&#9670;&nbsp;</a></span>create() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGP.html">GP</a>&lt;<a class="el" href="classGBitmap.html">GBitmap</a>&gt; GBitmap::create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classByteStream.html">ByteStream</a> &amp;&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>border</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a <a class="el" href="classGBitmap.html">GBitmap</a> by reading PBM, PGM or RLE data from <a class="el" href="classByteStream.html">ByteStream</a> #ref# into this <a class="el" href="classGBitmap.html">GBitmap</a>. The optional argument #border# specifies the size of the optional border of white pixels surrounding the image. See \Ref{PNM and RLE file formats} for more information. <br  />
 </p>

</div>
</div>
<a id="add8c9490fbe77215e759eb9bb5b6f565"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add8c9490fbe77215e759eb9bb5b6f565">&#9670;&nbsp;</a></span>create() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGP.html">GP</a>&lt;<a class="el" href="classGBitmap.html">GBitmap</a>&gt; GBitmap::create </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGBitmap.html">GBitmap</a> &amp;&#160;</td>
          <td class="paramname"><em>ref</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy constructor. Constructs a <a class="el" href="classGBitmap.html">GBitmap</a> by replicating the size, the border and the contents of <a class="el" href="classGBitmap.html">GBitmap</a> #ref#. </p>

</div>
</div>
<a id="ae9ac7fb9e984fea1ed9d8179d128dc0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9ac7fb9e984fea1ed9d8179d128dc0e">&#9670;&nbsp;</a></span>create() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGP.html">GP</a>&lt;<a class="el" href="classGBitmap.html">GBitmap</a>&gt; GBitmap::create </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGBitmap.html">GBitmap</a> &amp;&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGRect.html">GRect</a> &amp;&#160;</td>
          <td class="paramname"><em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>border</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a <a class="el" href="classGBitmap.html">GBitmap</a> by copying a rectangular segment #rect# of <a class="el" href="classGBitmap.html">GBitmap</a> #ref#. The optional argument #border# specifies the size of the optional border of white pixels surrounding the image. </p>

</div>
</div>
<a id="a5603e4c5d424a9cd559f8e3c1aa2ff4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5603e4c5d424a9cd559f8e3c1aa2ff4b">&#9670;&nbsp;</a></span>create() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGP.html">GP</a>&lt;<a class="el" href="classGBitmap.html">GBitmap</a>&gt; GBitmap::create </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGBitmap.html">GBitmap</a> &amp;&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>border</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a <a class="el" href="classGBitmap.html">GBitmap</a> by copying the contents of <a class="el" href="classGBitmap.html">GBitmap</a> #ref#. <br  />
 Argument #border# specifies the width of the optional border. </p>

</div>
</div>
<a id="a0687095c32571d41b2faaa533973bbec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0687095c32571d41b2faaa533973bbec">&#9670;&nbsp;</a></span>create() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGP.html">GP</a>&lt;<a class="el" href="classGBitmap.html">GBitmap</a>&gt; GBitmap::create </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nrows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>ncolumns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>border</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a <a class="el" href="classGBitmap.html">GBitmap</a> with #nrows# rows and #ncolumns# columns. All pixels are initialized to white. The optional argument #border# specifies the size of the optional border of white pixels surrounding the image. The number of gray levels is initially set to #2#. <br  />
 </p>

</div>
</div>
<a id="a3183f6375c60073209586060f908d9ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3183f6375c60073209586060f908d9ef">&#9670;&nbsp;</a></span>create() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGP.html">GP</a>&lt;<a class="el" href="classGBitmap.html">GBitmap</a>&gt; GBitmap::create </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs an empty <a class="el" href="classGBitmap.html">GBitmap</a> object. The returned <a class="el" href="classGBitmap.html">GBitmap</a> has zero rows and zero columns. Use function \Ref{init} to change the size of the image. </p>

</div>
</div>
<a id="ae4ea33759a2c8b514e1d11ccac36ef8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4ea33759a2c8b514e1d11ccac36ef8f">&#9670;&nbsp;</a></span>donate_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GBitmap::donate_data </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as borrow_data, except <a class="el" href="classGBitmap.html">GBitmap</a> will call #delete[]#. </p>

</div>
</div>
<a id="ab0326f7cb1a6ddca8543d2da37662b7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0326f7cb1a6ddca8543d2da37662b7e">&#9670;&nbsp;</a></span>donate_rle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GBitmap::donate_rle </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>rledata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>rledatalen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes this <a class="el" href="classGBitmap.html">GBitmap</a> by setting the size to #h# rows and #w# columns, and directly addressing the memory buffer #rledata# provided by the user. This buffer contains #rledatalen# bytes representing the bitmap in run length encoded form. The <a class="el" href="classGBitmap.html">GBitmap</a> object then `&lsquo;owns&rsquo;' the buffer (unlike <a class="el" href="classGBitmap.html#afa87afc89907c6e1fc3083cb5c493d70">borrow_data</a>#, but like <a class="el" href="classGBitmap.html#ae4ea33759a2c8b514e1d11ccac36ef8f">donate_data</a>#) and will deallocate this buffer when appropriate: you should not deallocate this buffer yourself. The encoding of buffer #rledata# is similar to the data segment of the RLE file format (without the header) documented in \Ref{PNM and RLE file formats}. <br  />
 </p>

</div>
</div>
<a id="a7338fa0f63ddcf387b3ed600d1b5bbbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7338fa0f63ddcf387b3ed600d1b5bbbe">&#9670;&nbsp;</a></span>fill()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GBitmap::fill </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes all the <a class="el" href="classGBitmap.html">GBitmap</a> pixels to value #value#. </p>

</div>
</div>
<a id="a020b42ff0ef5fea675f30252eabfad4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a020b42ff0ef5fea675f30252eabfad4a">&#9670;&nbsp;</a></span>get_grays()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int GBitmap::get_grays </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of gray levels. Value #2# denotes a bilevel image. </p>

</div>
</div>
<a id="ab820fa24b0f604525824e730912427e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab820fa24b0f604525824e730912427e8">&#9670;&nbsp;</a></span>get_memory_usage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int GBitmap::get_memory_usage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of bytes allocated for this image. </p>

</div>
</div>
<a id="aeba0b0841d50cb3d358d3e5cf3a1d3e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeba0b0841d50cb3d358d3e5cf3a1d3e7">&#9670;&nbsp;</a></span>get_rle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned char * GBitmap::get_rle </td>
          <td>(</td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>rle_length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a pointer to the rle data. </p>

</div>
</div>
<a id="a025a599af33edd476739e11045a867c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a025a599af33edd476739e11045a867c7">&#9670;&nbsp;</a></span>init() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GBitmap::init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classByteStream.html">ByteStream</a> &amp;&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>border</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads PBM, PGM or RLE data from <a class="el" href="classByteStream.html">ByteStream</a> #ref# into this <a class="el" href="classGBitmap.html">GBitmap</a>. The previous content of the <a class="el" href="classGBitmap.html">GBitmap</a> object is lost. The optional argument #border# specifies the size of the optional border of white pixels surrounding the image. See \Ref{PNM and RLE file formats} for more information. </p>

</div>
</div>
<a id="a3cdb3138e30b689a17f6e24d4a8c2460"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cdb3138e30b689a17f6e24d4a8c2460">&#9670;&nbsp;</a></span>init() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GBitmap::init </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGBitmap.html">GBitmap</a> &amp;&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGRect.html">GRect</a> &amp;&#160;</td>
          <td class="paramname"><em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>border</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes this <a class="el" href="classGBitmap.html">GBitmap</a> with a rectangular segment #rect# of <a class="el" href="classGBitmap.html">GBitmap</a> #ref#. The optional argument #border# specifies the size of the optional border of white pixels surrounding the image. </p>

</div>
</div>
<a id="a7266ecb2deb89cfd50db59ad49482652"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7266ecb2deb89cfd50db59ad49482652">&#9670;&nbsp;</a></span>init() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GBitmap::init </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGBitmap.html">GBitmap</a> &amp;&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>border</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes this <a class="el" href="classGBitmap.html">GBitmap</a> with the contents of the <a class="el" href="classGBitmap.html">GBitmap</a> #ref#. The optional argument #border# specifies the size of the optional border of white pixels surrounding the image. </p>

</div>
</div>
<a id="a9c33272be5ddb95fef2087a4310cbe3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c33272be5ddb95fef2087a4310cbe3a">&#9670;&nbsp;</a></span>init() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GBitmap::init </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nrows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ncolumns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>border</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resets this <a class="el" href="classGBitmap.html">GBitmap</a> size to #nrows# rows and #ncolumns# columns and sets all pixels to white. The optional argument #border# specifies the size of the optional border of white pixels surrounding the image. The number of gray levels is initialized to #2#. </p>

</div>
</div>
<a id="a0a16be0e063dcab9046581ae2afdd3ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a16be0e063dcab9046581ae2afdd3ee">&#9670;&nbsp;</a></span>minborder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GBitmap::minborder </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minimum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Makes sure that the border is at least #minimum# pixels large. This function does nothing it the border width is already larger than #minimum#. Otherwise it reorganizes the data in order to provide a border of #minimum# pixels. </p>

</div>
</div>
<a id="ac4b02d29e39c0c5c97fe10b56640707c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4b02d29e39c0c5c97fe10b56640707c">&#9670;&nbsp;</a></span>monitor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGMonitor.html">GMonitor</a> * GBitmap::monitor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a possibly null pointer to a \Ref{<a class="el" href="classGMonitor.html">GMonitor</a>} for this bitmap. You should use this monitor to ensure that the data representation of the bitmap will not change while you are using it. We suggest using class \Ref{<a class="el" href="classGMonitorLock.html">GMonitorLock</a>} which properly handles null monitor pointers. </p>

</div>
</div>
<a id="a8d22e48fe302d9f3ee840d6df4c39159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d22e48fe302d9f3ee840d6df4c39159">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGBitmap.html">GBitmap</a> &amp; GBitmap::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGBitmap.html">GBitmap</a> &amp;&#160;</td>
          <td class="paramname"><em>ref</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Assignment operator. Initializes this <a class="el" href="classGBitmap.html">GBitmap</a> by copying the size, the border and the contents of <a class="el" href="classGBitmap.html">GBitmap</a> #ref#. </p>

</div>
</div>
<a id="a0ea910fa9f2131abd63be2bd57e26eb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ea910fa9f2131abd63be2bd57e26eb9">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char * GBitmap::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a pointer to the first byte of row #row#. This pointer can be used as an array to read or write the row elements. </p>

</div>
</div>
<a id="a913f235312cacfca2ecb1e0bee28dd8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a913f235312cacfca2ecb1e0bee28dd8b">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned char * GBitmap::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a constant pointer to the first byte of row #row#. This pointer can be used as an array to read the row elements. </p>

</div>
</div>
<a id="a5f96f5f4259de4ee301ab4cc3864ca03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f96f5f4259de4ee301ab4cc3864ca03">&#9670;&nbsp;</a></span>read_run()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int GBitmap::read_run </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Static function for parsing run data. This function returns one run length encoded at position #data# and increments the pointer #data# accordingly. </p>

</div>
</div>
<a id="aa78fd1c091a53c9a3e8ae9123ecdc54e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa78fd1c091a53c9a3e8ae9123ecdc54e">&#9670;&nbsp;</a></span>rle_get_bitmap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GBitmap::rle_get_bitmap </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>ncolumns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&amp;&#160;</td>
          <td class="paramname"><em>runs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>bitmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>invert</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the bitmap line rle data passed. One line of pixel is stored one with 8 bits per #unsigned char# in an array. The array must be large enough to hold the whole line. <br  />
 </p>

</div>
</div>
<a id="a6f24b1c6f4617bd91bf8d649246285a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f24b1c6f4617bd91bf8d649246285a5">&#9670;&nbsp;</a></span>rle_get_bits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GBitmap::rle_get_bits </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rowno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>bits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the pixels for line #rowno#. One line of pixel is stored as #unsigned char# values into array #bits#. Each pixel is either 1 or 0. The array must be large enough to hold the whole line. The number of pixels is returned. </p>

</div>
</div>
<a id="aed863414ad68f8a97f2d66793af4e1ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed863414ad68f8a97f2d66793af4e1ad">&#9670;&nbsp;</a></span>rle_get_rect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GBitmap::rle_get_rect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGRect.html">GRect</a> &amp;&#160;</td>
          <td class="paramname"><em>rect</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the smallest rectangle enclosing black pixels. Rectangle rect gives the coordinates of the smallest rectangle containing all black pixels. Returns the number of black pixels. </p>

</div>
</div>
<a id="adeba63149e45bf7c3df0e727b624e0b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adeba63149e45bf7c3df0e727b624e0b6">&#9670;&nbsp;</a></span>rle_get_runs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GBitmap::rle_get_runs </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rowno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>rlens</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the lengths of all runs in line #rowno#. The array #rlens# must be large enough to accomodate #w+2# integers where #w# is the number of columns in the image. These integers represent the lengths of consecutive runs of alternatively white or black pixels. Lengths can be zero in order to allow for lines starting with black pixels. This function returns the total number of runs in the line. </p>

</div>
</div>
<a id="a20ec1cdefbaacc08be5801c7f179a73c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20ec1cdefbaacc08be5801c7f179a73c">&#9670;&nbsp;</a></span>rotate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGP.html">GP</a>&lt; <a class="el" href="classGBitmap.html">GBitmap</a> &gt; GBitmap::rotate </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Rotates bitmap by 90, 180 or 270 degrees anticlockwise and returns a new pixmap, input bitmap is not changed. count can be 1, 2, or 3 for 90, 180, 270 degree rotation. It returns the same bitmap if not rotated. The input bitmap will be uncompressed for rotation </p>

</div>
</div>
<a id="a26b93e377634a1d987891f76ede12f19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26b93e377634a1d987891f76ede12f19">&#9670;&nbsp;</a></span>rows()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int GBitmap::rows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of rows (the image height). </p>

</div>
</div>
<a id="adedb71b850f07744201ad0ee0a4756f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adedb71b850f07744201ad0ee0a4756f7">&#9670;&nbsp;</a></span>rowsize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int GBitmap::rowsize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the size of a row in memory (in pixels). This number is equal to the difference between pointers to pixels located in the same column in consecutive rows. This difference can be larger than the number of columns in the image. </p>

</div>
</div>
<a id="ab08cbb17f67a1c04e3f5bcef3064d93a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab08cbb17f67a1c04e3f5bcef3064d93a">&#9670;&nbsp;</a></span>save_pbm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GBitmap::save_pbm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classByteStream.html">ByteStream</a> &amp;&#160;</td>
          <td class="paramname"><em>bs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>raw</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Saves the image into <a class="el" href="classByteStream.html">ByteStream</a> #bs# using the PBM format. Argument #raw# selects the <code>Raw PBM'' (1) or the</code>Ascii PBM'' (0) format. The image is saved as a bilevel image. All non zero pixels are considered black pixels. See section \Ref{PNM and RLE file formats}. </p>

</div>
</div>
<a id="ae84537e31a15ce2a4cf64aefa73ef5f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae84537e31a15ce2a4cf64aefa73ef5f0">&#9670;&nbsp;</a></span>save_pgm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GBitmap::save_pgm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classByteStream.html">ByteStream</a> &amp;&#160;</td>
          <td class="paramname"><em>bs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>raw</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Saves the image into <a class="el" href="classByteStream.html">ByteStream</a> #bs# using the PGM format. Argument #raw# selects the <code>Raw PGM'' (1) or the</code>Ascii PGM'' (0) format. The image is saved as a gray level image. See section \Ref{PNM and RLE file formats}. </p>

</div>
</div>
<a id="a0f860c0b7817d1ed69950d068abe90bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f860c0b7817d1ed69950d068abe90bf">&#9670;&nbsp;</a></span>save_rle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GBitmap::save_rle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classByteStream.html">ByteStream</a> &amp;&#160;</td>
          <td class="paramname"><em>bs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Saves the image into <a class="el" href="classByteStream.html">ByteStream</a> #bs# using the RLE file format. The image is saved as a bilevel image. All non zero pixels are considered black pixels. See section \Ref{PNM and RLE file formats}. </p>

</div>
</div>
<a id="a1f205dd8631d74fe66abbf8c8103953f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f205dd8631d74fe66abbf8c8103953f">&#9670;&nbsp;</a></span>set_grays()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GBitmap::set_grays </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>grays</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the number of gray levels without changing the pixels. Argument #grays# must be in range #2# to #256#. </p>

</div>
</div>
<a id="a01acec46ce509879747ade5858b96750"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01acec46ce509879747ade5858b96750">&#9670;&nbsp;</a></span>share()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GBitmap::share </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Associates a \Ref{<a class="el" href="classGMonitor.html">GMonitor</a>} with this bitmap. This function should be called on all bitmaps susceptible of being simultaneously used by several threads. It will make sure that function \Ref{monitor} returns a pointer to a suitable monitor for this bitmap. </p>

</div>
</div>
<a id="ac8aab5b49b79f8454a2ca9864ce53680"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8aab5b49b79f8454a2ca9864ce53680">&#9670;&nbsp;</a></span>take_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char * GBitmap::take_data </td>
          <td>(</td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Steals the memory buffer of a <a class="el" href="classGBitmap.html">GBitmap</a>. This function returns the address of the memory buffer allocated by this <a class="el" href="classGBitmap.html">GBitmap</a> object. The offset of the first pixel in the bottom line is written into variable #offset#. Other lines can be accessed using pointer arithmetic (see \Ref{rowsize}). The <a class="el" href="classGBitmap.html">GBitmap</a> object no longer `&lsquo;owns&rsquo;' the buffer: you must explicitly de-allocate the buffer using #operator delete []#. This de-allocation should take place after the destruction or the re-initialization of the <a class="el" href="classGBitmap.html">GBitmap</a> object. This function will return a null pointer if the <a class="el" href="classGBitmap.html">GBitmap</a> object does not `&lsquo;own&rsquo;' the buffer in the first place. <br  />
 </p>

</div>
</div>
<a id="a2244bdca28d95f698759b690ad37d204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2244bdca28d95f698759b690ad37d204">&#9670;&nbsp;</a></span>uncompress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GBitmap::uncompress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decodes run-length encoded bitmaps and recreate the pixel array. This function is usually called by <a class="el" href="classGBitmap.html#a913f235312cacfca2ecb1e0bee28dd8b">operator[]</a># when needed. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>libdjvu/<a class="el" href="GBitmap_8h_source.html">GBitmap.h</a></li>
<li>libdjvu/GBitmap.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
