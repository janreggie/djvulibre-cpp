\hypertarget{classIFFByteStream}{}\doxysection{I\+F\+F\+Byte\+Stream Class Reference}
\label{classIFFByteStream}\index{IFFByteStream@{IFFByteStream}}


{\ttfamily \#include $<$I\+F\+F\+Byte\+Stream.\+h$>$}



Inheritance diagram for I\+F\+F\+Byte\+Stream\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=202pt]{classIFFByteStream__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for I\+F\+F\+Byte\+Stream\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=202pt]{classIFFByteStream__coll__graph}
\end{center}
\end{figure}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classIFFByteStream_a2e8e67033701e09950ecb79401621b37}\label{classIFFByteStream_a2e8e67033701e09950ecb79401621b37}} 
virtual size\+\_\+t {\bfseries read} (void $\ast$buffer, size\+\_\+t size)
\item 
\mbox{\Hypertarget{classIFFByteStream_a76daef565c0fe38aa725f2dc8115c674}\label{classIFFByteStream_a76daef565c0fe38aa725f2dc8115c674}} 
virtual size\+\_\+t {\bfseries write} (const void $\ast$buffer, size\+\_\+t size)
\item 
\mbox{\Hypertarget{classIFFByteStream_a6a4e639062f047a95444da3e71a48a91}\label{classIFFByteStream_a6a4e639062f047a95444da3e71a48a91}} 
virtual long {\bfseries tell} (void) const
\item 
int \mbox{\hyperlink{classIFFByteStream_a090b649ebbbf504069eac0d62452c8a6}{get\+\_\+chunk}} (\mbox{\hyperlink{classGUTF8String}{G\+U\+T\+F8\+String}} \&chkid, int $\ast$rawoffsetptr=0, int $\ast$rawsizeptr=0)
\item 
void \mbox{\hyperlink{classIFFByteStream_a577fe0c110b716ab62d4ee26fcdeaffe}{put\+\_\+chunk}} (const char $\ast$chkid, int insertmagic=0)
\item 
void \mbox{\hyperlink{classIFFByteStream_affc4e3889ab3c9a611e4600b1f7025d6}{close\+\_\+chunk}} ()
\item 
void \mbox{\hyperlink{classIFFByteStream_a52fd2a62aaf2f41a44d04c1291ed9d23}{seek\+\_\+close\+\_\+chunk}} ()
\item 
int \mbox{\hyperlink{classIFFByteStream_a6ebac52c8cb9be0745b84c943c3d7403}{ready}} ()
\item 
int \mbox{\hyperlink{classIFFByteStream_a3596f544da79916f439c34aeb2fecd3f}{composite}} ()
\item 
void \mbox{\hyperlink{classIFFByteStream_a260247d28f251a5e87a8d1c0c51d5b91}{short\+\_\+id}} (\mbox{\hyperlink{classGUTF8String}{G\+U\+T\+F8\+String}} \&chkid)
\item 
void \mbox{\hyperlink{classIFFByteStream_abbcac023201687657bf623acd364aa7c}{full\+\_\+id}} (\mbox{\hyperlink{classGUTF8String}{G\+U\+T\+F8\+String}} \&chkid)
\item 
\mbox{\Hypertarget{classIFFByteStream_a7b979eb63f0ec066a084be196d38fef9}\label{classIFFByteStream_a7b979eb63f0ec066a084be196d38fef9}} 
\mbox{\hyperlink{classGP}{GP}}$<$ \mbox{\hyperlink{classByteStream}{Byte\+Stream}} $>$ {\bfseries get\+\_\+bytestream} (void)
\item 
size\+\_\+t \mbox{\hyperlink{classIFFByteStream_ac0a00773de39d5f12328da0eda423a99}{copy}} (\mbox{\hyperlink{classByteStream}{Byte\+Stream}} \&bsfrom, size\+\_\+t size=0)
\item 
virtual void \mbox{\hyperlink{classIFFByteStream_a3d55e602a9d4d8e3a2dd3fe42340fab2}{flush}} (void)
\item 
bool \mbox{\hyperlink{classIFFByteStream_afcd8dcb947a571a5c751edb6b0631002}{compare}} (\mbox{\hyperlink{classIFFByteStream}{I\+F\+F\+Byte\+Stream}} \&iff)
\end{DoxyCompactItemize}
\doxysubsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \mbox{\hyperlink{classGP}{GP}}$<$ \mbox{\hyperlink{classIFFByteStream}{I\+F\+F\+Byte\+Stream}} $>$ \mbox{\hyperlink{classIFFByteStream_ad0692a3c9bc5827fe32fe74e75e9088e}{create}} (const \mbox{\hyperlink{classGP}{GP}}$<$ \mbox{\hyperlink{classByteStream}{Byte\+Stream}} $>$ \&bs)
\item 
static int \mbox{\hyperlink{classIFFByteStream_ab4f3cf242a90ca935c7b2557ad5684b7}{check\+\_\+id}} (const char $\ast$id)
\end{DoxyCompactItemize}
\doxysubsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
bool \mbox{\hyperlink{classIFFByteStream_a6a9a71b34ea64b7b2a4b5fa05ff4297d}{has\+\_\+magic\+\_\+att}}
\item 
bool \mbox{\hyperlink{classIFFByteStream_a54d6785d5ff459faa668f5baab448d15}{has\+\_\+magic\+\_\+sdjv}}
\end{DoxyCompactItemize}
\doxysubsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classIFFByteStream_a32e559fb147613f344f94470b9a2fb14}\label{classIFFByteStream_a32e559fb147613f344f94470b9a2fb14}} 
{\bfseries I\+F\+F\+Byte\+Stream} (const \mbox{\hyperlink{classGP}{GP}}$<$ \mbox{\hyperlink{classByteStream}{Byte\+Stream}} $>$ \&bs, const int pos)
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\mbox{\hyperlink{classByteStream}{Byte\+Stream}} interface for an I\+FF file.

\mbox{\hyperlink{structClass}{Class}} \mbox{\hyperlink{classIFFByteStream}{I\+F\+F\+Byte\+Stream}}\# augments the \mbox{\hyperlink{classByteStream}{Byte\+Stream}}\# interface with functions for navigating from chunk to chunk. It works in relation with a \mbox{\hyperlink{classByteStream}{Byte\+Stream}} specified at construction time.

\{\textbackslash{}bf Reading an I\+FF file\} --- You can read an I\+FF file by constructing an \mbox{\hyperlink{classIFFByteStream}{I\+F\+F\+Byte\+Stream}}\# object attached to the \mbox{\hyperlink{classByteStream}{Byte\+Stream}} containing the I\+FF file. Calling function \textbackslash{}\+Ref\{get\+\_\+chunk\} positions the file pointer at the beginning of the first chunk. You can then use \textbackslash{}\+Ref\{\mbox{\hyperlink{classByteStream_ae69bbdbc77545f72488bde0639ae0e95}{Byte\+Stream\+::read}}\} to access the chunk data. Function \#read\# will return \#0\# if you attempt to read past the end of the chunk, just as if you were trying to read past the end of a file. You can at any time call function \textbackslash{}\+Ref\{close\+\_\+chunk\} to terminate reading data in this chunk. The following chunks can be accessed by calling \mbox{\hyperlink{classIFFByteStream_a090b649ebbbf504069eac0d62452c8a6}{get\+\_\+chunk}}\# and \mbox{\hyperlink{classIFFByteStream_affc4e3889ab3c9a611e4600b1f7025d6}{close\+\_\+chunk}}\# repeatedly until you reach the end of the file. Function \#read\# is not very useful when accessing a composite chunk. You can instead make nested calls to functions \mbox{\hyperlink{classIFFByteStream_a090b649ebbbf504069eac0d62452c8a6}{get\+\_\+chunk}}\# and \mbox{\hyperlink{classIFFByteStream_affc4e3889ab3c9a611e4600b1f7025d6}{close\+\_\+chunk}}\# in order to access the chunks located inside the composite chunk.

\{\textbackslash{}bf Writing an I\+FF file\} --- You can write an I\+FF file by constructing an \mbox{\hyperlink{classIFFByteStream}{I\+F\+F\+Byte\+Stream}}\# object attached to the seekable \mbox{\hyperlink{classByteStream}{Byte\+Stream}} object that will contain the I\+FF file. Calling function \textbackslash{}\+Ref\{put\+\_\+chunk\} creates a first chunk header and positions the file pointer at the beginning of the chunk. You can then use \textbackslash{}\+Ref\{\mbox{\hyperlink{classByteStream_ac10e950d655e5dabb93af44e3a5da855}{Byte\+Stream\+::write}}\} to store the chunk data. Calling function \textbackslash{}\+Ref\{close\+\_\+chunk\} terminates the current chunk. You can append more chunks by calling \mbox{\hyperlink{classIFFByteStream_a577fe0c110b716ab62d4ee26fcdeaffe}{put\+\_\+chunk}}\# and \mbox{\hyperlink{classIFFByteStream_affc4e3889ab3c9a611e4600b1f7025d6}{close\+\_\+chunk}}\# repeatedly. Function \#write\# is not very useful for writing a composite chunk. You can instead make nested calls to function \mbox{\hyperlink{classIFFByteStream_a577fe0c110b716ab62d4ee26fcdeaffe}{put\+\_\+chunk}}\# and \mbox{\hyperlink{classIFFByteStream_affc4e3889ab3c9a611e4600b1f7025d6}{close\+\_\+chunk}}\# in order to create chunks located inside the composite chunk.

Writing an I\+FF file requires a seekable \mbox{\hyperlink{classByteStream}{Byte\+Stream}} (see \textbackslash{}\+Ref\{Byte\+Stream\+::is\+\_\+seekable\}). This is not much of a problem because you can always create the I\+FF file into a \textbackslash{}\+Ref\{Memory\+Byte\+Stream\} and then use \textbackslash{}\+Ref\{\mbox{\hyperlink{classByteStream_ab0d1a30ac0d602194c57ff0920639391}{Byte\+Stream\+::copy}}\} to transfer the I\+FF file into a non seekable \mbox{\hyperlink{classByteStream}{Byte\+Stream}}. ~\newline
 

\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{classIFFByteStream_ab4f3cf242a90ca935c7b2557ad5684b7}\label{classIFFByteStream_ab4f3cf242a90ca935c7b2557ad5684b7}} 
\index{IFFByteStream@{IFFByteStream}!check\_id@{check\_id}}
\index{check\_id@{check\_id}!IFFByteStream@{IFFByteStream}}
\doxysubsubsection{\texorpdfstring{check\_id()}{check\_id()}}
{\footnotesize\ttfamily int I\+F\+F\+Byte\+Stream\+::check\+\_\+id (\begin{DoxyParamCaption}\item[{const char $\ast$}]{id }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Checks a potential chunk identifier. This function categorizes the chunk identifier formed by the first four characters of string \#chkid\#. It returns \#0\# if this is a legal identifier for a regular chunk. It returns \#+1\# if this is a reserved composite chunk identifier. It returns \#-\/1\# if this is an illegal or otherwise reserved identifier which should not be used. ~\newline
 \mbox{\Hypertarget{classIFFByteStream_affc4e3889ab3c9a611e4600b1f7025d6}\label{classIFFByteStream_affc4e3889ab3c9a611e4600b1f7025d6}} 
\index{IFFByteStream@{IFFByteStream}!close\_chunk@{close\_chunk}}
\index{close\_chunk@{close\_chunk}!IFFByteStream@{IFFByteStream}}
\doxysubsubsection{\texorpdfstring{close\_chunk()}{close\_chunk()}}
{\footnotesize\ttfamily void I\+F\+F\+Byte\+Stream\+::close\+\_\+chunk (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Leaves the current chunk. This function leaves the chunk previously entered by a matching call to \mbox{\hyperlink{classIFFByteStream_a090b649ebbbf504069eac0d62452c8a6}{get\+\_\+chunk}}\# and \mbox{\hyperlink{classIFFByteStream_a577fe0c110b716ab62d4ee26fcdeaffe}{put\+\_\+chunk}}\#. The \mbox{\hyperlink{classIFFByteStream}{I\+F\+F\+Byte\+Stream}} is then ready to process the next chunk at the same hierarchical level. \mbox{\Hypertarget{classIFFByteStream_afcd8dcb947a571a5c751edb6b0631002}\label{classIFFByteStream_afcd8dcb947a571a5c751edb6b0631002}} 
\index{IFFByteStream@{IFFByteStream}!compare@{compare}}
\index{compare@{compare}!IFFByteStream@{IFFByteStream}}
\doxysubsubsection{\texorpdfstring{compare()}{compare()}}
{\footnotesize\ttfamily bool I\+F\+F\+Byte\+Stream\+::compare (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classIFFByteStream}{I\+F\+F\+Byte\+Stream}} \&}]{iff }\end{DoxyParamCaption})}

This is a simple compare method. The \mbox{\hyperlink{classIFFByteStream}{I\+F\+F\+Byte\+Stream}} may be read for the sake of the comparison. Since I\+F\+F\+Byte\+Streams are non-\/seekable, the stream is not valid for use after comparing, regardless of the result. \mbox{\Hypertarget{classIFFByteStream_a3596f544da79916f439c34aeb2fecd3f}\label{classIFFByteStream_a3596f544da79916f439c34aeb2fecd3f}} 
\index{IFFByteStream@{IFFByteStream}!composite@{composite}}
\index{composite@{composite}!IFFByteStream@{IFFByteStream}}
\doxysubsubsection{\texorpdfstring{composite()}{composite()}}
{\footnotesize\ttfamily int I\+F\+F\+Byte\+Stream\+::composite (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Returns true when the current chunk is a composite chunk. \mbox{\Hypertarget{classIFFByteStream_ac0a00773de39d5f12328da0eda423a99}\label{classIFFByteStream_ac0a00773de39d5f12328da0eda423a99}} 
\index{IFFByteStream@{IFFByteStream}!copy@{copy}}
\index{copy@{copy}!IFFByteStream@{IFFByteStream}}
\doxysubsubsection{\texorpdfstring{copy()}{copy()}}
{\footnotesize\ttfamily size\+\_\+t I\+F\+F\+Byte\+Stream\+::copy (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classByteStream}{Byte\+Stream}} \&}]{bsfrom,  }\item[{size\+\_\+t}]{size = {\ttfamily 0} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Copy data from another \mbox{\hyperlink{classByteStream}{Byte\+Stream}}. A maximum of \#size\# bytes are read from the \mbox{\hyperlink{classByteStream}{Byte\+Stream}} \#bsfrom\# and are written to the \mbox{\hyperlink{classByteStream}{Byte\+Stream}} \#$\ast$this\# at the current position. Less than \#size\# bytes may be written if an end-\/of-\/file mark is reached on \#bsfrom\#. This function returns the total number of bytes copied. Setting argument \#size\# to zero (the default value) has a special meaning\+: the copying process will continue until reaching the end-\/of-\/file mark on \mbox{\hyperlink{classByteStream}{Byte\+Stream}} \#bsfrom\#, regardless of the number of bytes transferred. ~\newline
 \mbox{\Hypertarget{classIFFByteStream_ad0692a3c9bc5827fe32fe74e75e9088e}\label{classIFFByteStream_ad0692a3c9bc5827fe32fe74e75e9088e}} 
\index{IFFByteStream@{IFFByteStream}!create@{create}}
\index{create@{create}!IFFByteStream@{IFFByteStream}}
\doxysubsubsection{\texorpdfstring{create()}{create()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classGP}{GP}}$<$ \mbox{\hyperlink{classIFFByteStream}{I\+F\+F\+Byte\+Stream}} $>$ I\+F\+F\+Byte\+Stream\+::create (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classGP}{GP}}$<$ \mbox{\hyperlink{classByteStream}{Byte\+Stream}} $>$ \&}]{bs }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Constructs an \mbox{\hyperlink{classIFFByteStream}{I\+F\+F\+Byte\+Stream}} object attached to \mbox{\hyperlink{classByteStream}{Byte\+Stream}} \#bs\#. Any \mbox{\hyperlink{classByteStream}{Byte\+Stream}} can be used when reading an I\+FF file. Writing an I\+FF file however requires a seekable \mbox{\hyperlink{classByteStream}{Byte\+Stream}}. \mbox{\Hypertarget{classIFFByteStream_a3d55e602a9d4d8e3a2dd3fe42340fab2}\label{classIFFByteStream_a3d55e602a9d4d8e3a2dd3fe42340fab2}} 
\index{IFFByteStream@{IFFByteStream}!flush@{flush}}
\index{flush@{flush}!IFFByteStream@{IFFByteStream}}
\doxysubsubsection{\texorpdfstring{flush()}{flush()}}
{\footnotesize\ttfamily virtual void I\+F\+F\+Byte\+Stream\+::flush (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}

Flushes all buffers in the \mbox{\hyperlink{classByteStream}{Byte\+Stream}}. Calling this function guarantees that pending data have been actually written (i.\+e. passed to the operating system). \mbox{\hyperlink{structClass}{Class}} \mbox{\hyperlink{classByteStream}{Byte\+Stream}}\# provides a default implementation which does nothing. \mbox{\Hypertarget{classIFFByteStream_abbcac023201687657bf623acd364aa7c}\label{classIFFByteStream_abbcac023201687657bf623acd364aa7c}} 
\index{IFFByteStream@{IFFByteStream}!full\_id@{full\_id}}
\index{full\_id@{full\_id}!IFFByteStream@{IFFByteStream}}
\doxysubsubsection{\texorpdfstring{full\_id()}{full\_id()}}
{\footnotesize\ttfamily void I\+F\+F\+Byte\+Stream\+::full\+\_\+id (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classGUTF8String}{G\+U\+T\+F8\+String}} \&}]{chkid }\end{DoxyParamCaption})}

Returns the qualified chunk identifier of the current chunk. String \#chkid\# is overwritten with the \{{\itshape qualified} chunk identifier\} of the current chunk. The qualified chunk identifier of a composite chunk is equal to the extended chunk identifier. The qualified chunk identifier of a regular chunk is composed by concatenating the secondary chunk identifier of the closest \#\char`\"{}\+F\+O\+R\+M\char`\"{}\# or \#\char`\"{}\+P\+R\+O\+P\char`\"{}\# composite chunk containing the current chunk, a dot \#\char`\"{}.\char`\"{}\#, and the current chunk identifier, as in \#\char`\"{}\+D\+J\+V\+U.\+I\+N\+F\+O\char`\"{}\#. According to the EA I\+FF 85 identifier scoping rules, the qualified chunk identifier uniquely defines how the chunk data should be interpreted. \mbox{\Hypertarget{classIFFByteStream_a090b649ebbbf504069eac0d62452c8a6}\label{classIFFByteStream_a090b649ebbbf504069eac0d62452c8a6}} 
\index{IFFByteStream@{IFFByteStream}!get\_chunk@{get\_chunk}}
\index{get\_chunk@{get\_chunk}!IFFByteStream@{IFFByteStream}}
\doxysubsubsection{\texorpdfstring{get\_chunk()}{get\_chunk()}}
{\footnotesize\ttfamily int I\+F\+F\+Byte\+Stream\+::get\+\_\+chunk (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classGUTF8String}{G\+U\+T\+F8\+String}} \&}]{chkid,  }\item[{int $\ast$}]{rawoffsetptr = {\ttfamily 0},  }\item[{int $\ast$}]{rawsizeptr = {\ttfamily 0} }\end{DoxyParamCaption})}

Enters a chunk for reading. Function \mbox{\hyperlink{classIFFByteStream_a090b649ebbbf504069eac0d62452c8a6}{get\+\_\+chunk}}\# returns zero when the last chunk has already been accessed. Otherwise it parses a chunk header, positions the \mbox{\hyperlink{classIFFByteStream}{I\+F\+F\+Byte\+Stream}} at the beginning of the chunk data, stores the extended chunk identifier into string \#chkid\#, and returns the non zero chunk size. The file offset of the chunk data may be retrieved using function \#tell\#. The chunk data can then be read using function \#read\# until reaching the end of the chunk. Advanced users may supply two pointers to integer variables using arguments \#rawoffsetptr\# and \#rawsizeptr\#. These variables will be overwritten with the offset and the length of the file segment containing both the chunk header and the chunk data. \mbox{\Hypertarget{classIFFByteStream_a577fe0c110b716ab62d4ee26fcdeaffe}\label{classIFFByteStream_a577fe0c110b716ab62d4ee26fcdeaffe}} 
\index{IFFByteStream@{IFFByteStream}!put\_chunk@{put\_chunk}}
\index{put\_chunk@{put\_chunk}!IFFByteStream@{IFFByteStream}}
\doxysubsubsection{\texorpdfstring{put\_chunk()}{put\_chunk()}}
{\footnotesize\ttfamily void I\+F\+F\+Byte\+Stream\+::put\+\_\+chunk (\begin{DoxyParamCaption}\item[{const char $\ast$}]{chkid,  }\item[{int}]{insertmagic = {\ttfamily 0} }\end{DoxyParamCaption})}

Enters a chunk for writing. Function \mbox{\hyperlink{classIFFByteStream_a577fe0c110b716ab62d4ee26fcdeaffe}{put\+\_\+chunk}}\# prepares a chunk header and positions the \mbox{\hyperlink{classIFFByteStream}{I\+F\+F\+Byte\+Stream}} at the beginning of the chunk data. Argument \#chkid\# defines a extended chunk identifier for this chunk. The chunk data can then be written using function \#write\#. The chunk is terminated by a matching call to function \mbox{\hyperlink{classIFFByteStream_affc4e3889ab3c9a611e4600b1f7025d6}{close\+\_\+chunk}}\#. When \#insertmagic\# is non zero, function \mbox{\hyperlink{classIFFByteStream_a577fe0c110b716ab62d4ee26fcdeaffe}{put\+\_\+chunk}}\# inserts the bytes\+: 0x41, 0x54, 0x26, 0x54 before the chunk header, as discussed in \textbackslash{}\+Ref\{\mbox{\hyperlink{IFFByteStream_8h_source}{I\+F\+F\+Byte\+Stream.\+h}}\}. \mbox{\Hypertarget{classIFFByteStream_a6ebac52c8cb9be0745b84c943c3d7403}\label{classIFFByteStream_a6ebac52c8cb9be0745b84c943c3d7403}} 
\index{IFFByteStream@{IFFByteStream}!ready@{ready}}
\index{ready@{ready}!IFFByteStream@{IFFByteStream}}
\doxysubsubsection{\texorpdfstring{ready()}{ready()}}
{\footnotesize\ttfamily int I\+F\+F\+Byte\+Stream\+::ready (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Returns true when it is legal to call \#read\# or \#write\#. \mbox{\Hypertarget{classIFFByteStream_a52fd2a62aaf2f41a44d04c1291ed9d23}\label{classIFFByteStream_a52fd2a62aaf2f41a44d04c1291ed9d23}} 
\index{IFFByteStream@{IFFByteStream}!seek\_close\_chunk@{seek\_close\_chunk}}
\index{seek\_close\_chunk@{seek\_close\_chunk}!IFFByteStream@{IFFByteStream}}
\doxysubsubsection{\texorpdfstring{seek\_close\_chunk()}{seek\_close\_chunk()}}
{\footnotesize\ttfamily void I\+F\+F\+Byte\+Stream\+::seek\+\_\+close\+\_\+chunk (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

This is identical to the above, plus it adds a seek to the start of the next chunk. This way we catch E\+OF errors with the current chunk. \mbox{\Hypertarget{classIFFByteStream_a260247d28f251a5e87a8d1c0c51d5b91}\label{classIFFByteStream_a260247d28f251a5e87a8d1c0c51d5b91}} 
\index{IFFByteStream@{IFFByteStream}!short\_id@{short\_id}}
\index{short\_id@{short\_id}!IFFByteStream@{IFFByteStream}}
\doxysubsubsection{\texorpdfstring{short\_id()}{short\_id()}}
{\footnotesize\ttfamily void I\+F\+F\+Byte\+Stream\+::short\+\_\+id (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classGUTF8String}{G\+U\+T\+F8\+String}} \&}]{chkid }\end{DoxyParamCaption})}

Returns the current chunk identifier of the current chunk. String \#chkid\# is overwritten with the \{{\itshape extended} chunk identifier\} of the current chunk. The extended chunk identifier of a regular chunk is simply the chunk identifier, as in \#\char`\"{}\+P\+M44\char`\"{}\#. The extended chunk identifier of a composite chunk is the concatenation of the chunk identifier, of a semicolon \#\char`\"{}\+:\char`\"{}\#, and of the secondary chunk identifier, as in \#\char`\"{}\+F\+O\+R\+M\+:\+D\+J\+V\+U\char`\"{}\#. 

\doxysubsection{Member Data Documentation}
\mbox{\Hypertarget{classIFFByteStream_a6a9a71b34ea64b7b2a4b5fa05ff4297d}\label{classIFFByteStream_a6a9a71b34ea64b7b2a4b5fa05ff4297d}} 
\index{IFFByteStream@{IFFByteStream}!has\_magic\_att@{has\_magic\_att}}
\index{has\_magic\_att@{has\_magic\_att}!IFFByteStream@{IFFByteStream}}
\doxysubsubsection{\texorpdfstring{has\_magic\_att}{has\_magic\_att}}
{\footnotesize\ttfamily bool I\+F\+F\+Byte\+Stream\+::has\+\_\+magic\+\_\+att}

\mbox{\hyperlink{classIFFByteStream_a6a9a71b34ea64b7b2a4b5fa05ff4297d}{has\+\_\+magic\+\_\+att}}\# is true if the stream has the Dj\+Vu magic \textquotesingle{}AT\&T\textquotesingle{} marker. \mbox{\Hypertarget{classIFFByteStream_a54d6785d5ff459faa668f5baab448d15}\label{classIFFByteStream_a54d6785d5ff459faa668f5baab448d15}} 
\index{IFFByteStream@{IFFByteStream}!has\_magic\_sdjv@{has\_magic\_sdjv}}
\index{has\_magic\_sdjv@{has\_magic\_sdjv}!IFFByteStream@{IFFByteStream}}
\doxysubsubsection{\texorpdfstring{has\_magic\_sdjv}{has\_magic\_sdjv}}
{\footnotesize\ttfamily bool I\+F\+F\+Byte\+Stream\+::has\+\_\+magic\+\_\+sdjv}

\mbox{\hyperlink{classIFFByteStream_a54d6785d5ff459faa668f5baab448d15}{has\+\_\+magic\+\_\+sdjv}}\# is true if the stream has the Celartem magic \textquotesingle{}S\+D\+JV\textquotesingle{} marker. 

The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
libdjvu/I\+F\+F\+Byte\+Stream.\+h\item 
libdjvu/I\+F\+F\+Byte\+Stream.\+cpp\end{DoxyCompactItemize}
