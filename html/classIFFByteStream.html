<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: IFFByteStream Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classIFFByteStream-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">IFFByteStream Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="IFFByteStream_8h_source.html">IFFByteStream.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for IFFByteStream:</div>
<div class="dyncontent">
<div class="center"><img src="classIFFByteStream__inherit__graph.png" border="0" usemap="#IFFByteStream_inherit__map" alt="Inheritance graph"/></div>
<map name="IFFByteStream_inherit__map" id="IFFByteStream_inherit__map">
<area shape="rect" title=" " alt="" coords="27,80,146,107"/>
<area shape="rect" title=" " alt="" coords="5,5,168,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for IFFByteStream:</div>
<div class="dyncontent">
<div class="center"><img src="classIFFByteStream__coll__graph.png" border="0" usemap="#IFFByteStream_coll__map" alt="Collaboration graph"/></div>
<map name="IFFByteStream_coll__map" id="IFFByteStream_coll__map">
<area shape="rect" title=" " alt="" coords="27,80,146,107"/>
<area shape="rect" title=" " alt="" coords="5,5,168,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2e8e67033701e09950ecb79401621b37"><td class="memItemLeft" align="right" valign="top"><a id="a2e8e67033701e09950ecb79401621b37"></a>
virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><b>read</b> (void *buffer, size_t size)</td></tr>
<tr class="separator:a2e8e67033701e09950ecb79401621b37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76daef565c0fe38aa725f2dc8115c674"><td class="memItemLeft" align="right" valign="top"><a id="a76daef565c0fe38aa725f2dc8115c674"></a>
virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><b>write</b> (const void *buffer, size_t size)</td></tr>
<tr class="separator:a76daef565c0fe38aa725f2dc8115c674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a4e639062f047a95444da3e71a48a91"><td class="memItemLeft" align="right" valign="top"><a id="a6a4e639062f047a95444da3e71a48a91"></a>
virtual long&#160;</td><td class="memItemRight" valign="bottom"><b>tell</b> (void) const</td></tr>
<tr class="separator:a6a4e639062f047a95444da3e71a48a91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a090b649ebbbf504069eac0d62452c8a6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIFFByteStream.html#a090b649ebbbf504069eac0d62452c8a6">get_chunk</a> (<a class="el" href="classGUTF8String.html">GUTF8String</a> &amp;chkid, int *rawoffsetptr=0, int *rawsizeptr=0)</td></tr>
<tr class="separator:a090b649ebbbf504069eac0d62452c8a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a577fe0c110b716ab62d4ee26fcdeaffe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIFFByteStream.html#a577fe0c110b716ab62d4ee26fcdeaffe">put_chunk</a> (const char *chkid, int insertmagic=0)</td></tr>
<tr class="separator:a577fe0c110b716ab62d4ee26fcdeaffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affc4e3889ab3c9a611e4600b1f7025d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIFFByteStream.html#affc4e3889ab3c9a611e4600b1f7025d6">close_chunk</a> ()</td></tr>
<tr class="separator:affc4e3889ab3c9a611e4600b1f7025d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52fd2a62aaf2f41a44d04c1291ed9d23"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIFFByteStream.html#a52fd2a62aaf2f41a44d04c1291ed9d23">seek_close_chunk</a> ()</td></tr>
<tr class="separator:a52fd2a62aaf2f41a44d04c1291ed9d23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ebac52c8cb9be0745b84c943c3d7403"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIFFByteStream.html#a6ebac52c8cb9be0745b84c943c3d7403">ready</a> ()</td></tr>
<tr class="separator:a6ebac52c8cb9be0745b84c943c3d7403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3596f544da79916f439c34aeb2fecd3f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIFFByteStream.html#a3596f544da79916f439c34aeb2fecd3f">composite</a> ()</td></tr>
<tr class="separator:a3596f544da79916f439c34aeb2fecd3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a260247d28f251a5e87a8d1c0c51d5b91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIFFByteStream.html#a260247d28f251a5e87a8d1c0c51d5b91">short_id</a> (<a class="el" href="classGUTF8String.html">GUTF8String</a> &amp;chkid)</td></tr>
<tr class="separator:a260247d28f251a5e87a8d1c0c51d5b91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbcac023201687657bf623acd364aa7c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIFFByteStream.html#abbcac023201687657bf623acd364aa7c">full_id</a> (<a class="el" href="classGUTF8String.html">GUTF8String</a> &amp;chkid)</td></tr>
<tr class="separator:abbcac023201687657bf623acd364aa7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b979eb63f0ec066a084be196d38fef9"><td class="memItemLeft" align="right" valign="top"><a id="a7b979eb63f0ec066a084be196d38fef9"></a>
<a class="el" href="classGP.html">GP</a>&lt; <a class="el" href="classByteStream.html">ByteStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>get_bytestream</b> (void)</td></tr>
<tr class="separator:a7b979eb63f0ec066a084be196d38fef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0a00773de39d5f12328da0eda423a99"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIFFByteStream.html#ac0a00773de39d5f12328da0eda423a99">copy</a> (<a class="el" href="classByteStream.html">ByteStream</a> &amp;bsfrom, size_t size=0)</td></tr>
<tr class="separator:ac0a00773de39d5f12328da0eda423a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d55e602a9d4d8e3a2dd3fe42340fab2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIFFByteStream.html#a3d55e602a9d4d8e3a2dd3fe42340fab2">flush</a> (void)</td></tr>
<tr class="separator:a3d55e602a9d4d8e3a2dd3fe42340fab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcd8dcb947a571a5c751edb6b0631002"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIFFByteStream.html#afcd8dcb947a571a5c751edb6b0631002">compare</a> (<a class="el" href="classIFFByteStream.html">IFFByteStream</a> &amp;iff)</td></tr>
<tr class="separator:afcd8dcb947a571a5c751edb6b0631002"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ad0692a3c9bc5827fe32fe74e75e9088e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGP.html">GP</a>&lt; <a class="el" href="classIFFByteStream.html">IFFByteStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIFFByteStream.html#ad0692a3c9bc5827fe32fe74e75e9088e">create</a> (const <a class="el" href="classGP.html">GP</a>&lt; <a class="el" href="classByteStream.html">ByteStream</a> &gt; &amp;bs)</td></tr>
<tr class="separator:ad0692a3c9bc5827fe32fe74e75e9088e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f3cf242a90ca935c7b2557ad5684b7"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIFFByteStream.html#ab4f3cf242a90ca935c7b2557ad5684b7">check_id</a> (const char *id)</td></tr>
<tr class="separator:ab4f3cf242a90ca935c7b2557ad5684b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a6a9a71b34ea64b7b2a4b5fa05ff4297d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIFFByteStream.html#a6a9a71b34ea64b7b2a4b5fa05ff4297d">has_magic_att</a></td></tr>
<tr class="separator:a6a9a71b34ea64b7b2a4b5fa05ff4297d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54d6785d5ff459faa668f5baab448d15"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIFFByteStream.html#a54d6785d5ff459faa668f5baab448d15">has_magic_sdjv</a></td></tr>
<tr class="separator:a54d6785d5ff459faa668f5baab448d15"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a32e559fb147613f344f94470b9a2fb14"><td class="memItemLeft" align="right" valign="top"><a id="a32e559fb147613f344f94470b9a2fb14"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>IFFByteStream</b> (const <a class="el" href="classGP.html">GP</a>&lt; <a class="el" href="classByteStream.html">ByteStream</a> &gt; &amp;bs, const int pos)</td></tr>
<tr class="separator:a32e559fb147613f344f94470b9a2fb14"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classByteStream.html">ByteStream</a> interface for an IFF file.</p>
<p><a class="el" href="structClass.html">Class</a> <a class="el" href="classIFFByteStream.html">IFFByteStream</a># augments the <a class="el" href="classByteStream.html">ByteStream</a># interface with functions for navigating from chunk to chunk. It works in relation with a <a class="el" href="classByteStream.html">ByteStream</a> specified at construction time.</p>
<p>{\bf Reading an IFF file} &mdash; You can read an IFF file by constructing an <a class="el" href="classIFFByteStream.html">IFFByteStream</a># object attached to the <a class="el" href="classByteStream.html">ByteStream</a> containing the IFF file. Calling function \Ref{get_chunk} positions the file pointer at the beginning of the first chunk. You can then use \Ref{<a class="el" href="classByteStream.html#ae69bbdbc77545f72488bde0639ae0e95">ByteStream::read</a>} to access the chunk data. Function #read# will return #0# if you attempt to read past the end of the chunk, just as if you were trying to read past the end of a file. You can at any time call function \Ref{close_chunk} to terminate reading data in this chunk. The following chunks can be accessed by calling <a class="el" href="classIFFByteStream.html#a090b649ebbbf504069eac0d62452c8a6">get_chunk</a># and <a class="el" href="classIFFByteStream.html#affc4e3889ab3c9a611e4600b1f7025d6">close_chunk</a># repeatedly until you reach the end of the file. Function #read# is not very useful when accessing a composite chunk. You can instead make nested calls to functions <a class="el" href="classIFFByteStream.html#a090b649ebbbf504069eac0d62452c8a6">get_chunk</a># and <a class="el" href="classIFFByteStream.html#affc4e3889ab3c9a611e4600b1f7025d6">close_chunk</a># in order to access the chunks located inside the composite chunk.</p>
<p>{\bf Writing an IFF file} &mdash; You can write an IFF file by constructing an <a class="el" href="classIFFByteStream.html">IFFByteStream</a># object attached to the seekable <a class="el" href="classByteStream.html">ByteStream</a> object that will contain the IFF file. Calling function \Ref{put_chunk} creates a first chunk header and positions the file pointer at the beginning of the chunk. You can then use \Ref{<a class="el" href="classByteStream.html#ac10e950d655e5dabb93af44e3a5da855">ByteStream::write</a>} to store the chunk data. Calling function \Ref{close_chunk} terminates the current chunk. You can append more chunks by calling <a class="el" href="classIFFByteStream.html#a577fe0c110b716ab62d4ee26fcdeaffe">put_chunk</a># and <a class="el" href="classIFFByteStream.html#affc4e3889ab3c9a611e4600b1f7025d6">close_chunk</a># repeatedly. Function #write# is not very useful for writing a composite chunk. You can instead make nested calls to function <a class="el" href="classIFFByteStream.html#a577fe0c110b716ab62d4ee26fcdeaffe">put_chunk</a># and <a class="el" href="classIFFByteStream.html#affc4e3889ab3c9a611e4600b1f7025d6">close_chunk</a># in order to create chunks located inside the composite chunk.</p>
<p>Writing an IFF file requires a seekable <a class="el" href="classByteStream.html">ByteStream</a> (see \Ref{ByteStream::is_seekable}). This is not much of a problem because you can always create the IFF file into a \Ref{MemoryByteStream} and then use \Ref{<a class="el" href="classByteStream.html#ab0d1a30ac0d602194c57ff0920639391">ByteStream::copy</a>} to transfer the IFF file into a non seekable <a class="el" href="classByteStream.html">ByteStream</a>. <br  />
 </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ab4f3cf242a90ca935c7b2557ad5684b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4f3cf242a90ca935c7b2557ad5684b7">&#9670;&nbsp;</a></span>check_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int IFFByteStream::check_id </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks a potential chunk identifier. This function categorizes the chunk identifier formed by the first four characters of string #chkid#. It returns #0# if this is a legal identifier for a regular chunk. It returns #+1# if this is a reserved composite chunk identifier. It returns #-1# if this is an illegal or otherwise reserved identifier which should not be used. <br  />
 </p>

</div>
</div>
<a id="affc4e3889ab3c9a611e4600b1f7025d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affc4e3889ab3c9a611e4600b1f7025d6">&#9670;&nbsp;</a></span>close_chunk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IFFByteStream::close_chunk </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Leaves the current chunk. This function leaves the chunk previously entered by a matching call to <a class="el" href="classIFFByteStream.html#a090b649ebbbf504069eac0d62452c8a6">get_chunk</a># and <a class="el" href="classIFFByteStream.html#a577fe0c110b716ab62d4ee26fcdeaffe">put_chunk</a>#. The <a class="el" href="classIFFByteStream.html">IFFByteStream</a> is then ready to process the next chunk at the same hierarchical level. </p>

</div>
</div>
<a id="afcd8dcb947a571a5c751edb6b0631002"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcd8dcb947a571a5c751edb6b0631002">&#9670;&nbsp;</a></span>compare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IFFByteStream::compare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIFFByteStream.html">IFFByteStream</a> &amp;&#160;</td>
          <td class="paramname"><em>iff</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is a simple compare method. The <a class="el" href="classIFFByteStream.html">IFFByteStream</a> may be read for the sake of the comparison. Since IFFByteStreams are non-seekable, the stream is not valid for use after comparing, regardless of the result. </p>

</div>
</div>
<a id="a3596f544da79916f439c34aeb2fecd3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3596f544da79916f439c34aeb2fecd3f">&#9670;&nbsp;</a></span>composite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IFFByteStream::composite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true when the current chunk is a composite chunk. </p>

</div>
</div>
<a id="ac0a00773de39d5f12328da0eda423a99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0a00773de39d5f12328da0eda423a99">&#9670;&nbsp;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t IFFByteStream::copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classByteStream.html">ByteStream</a> &amp;&#160;</td>
          <td class="paramname"><em>bsfrom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy data from another <a class="el" href="classByteStream.html">ByteStream</a>. A maximum of #size# bytes are read from the <a class="el" href="classByteStream.html">ByteStream</a> #bsfrom# and are written to the <a class="el" href="classByteStream.html">ByteStream</a> #*this# at the current position. Less than #size# bytes may be written if an end-of-file mark is reached on #bsfrom#. This function returns the total number of bytes copied. Setting argument #size# to zero (the default value) has a special meaning: the copying process will continue until reaching the end-of-file mark on <a class="el" href="classByteStream.html">ByteStream</a> #bsfrom#, regardless of the number of bytes transferred. <br  />
 </p>

</div>
</div>
<a id="ad0692a3c9bc5827fe32fe74e75e9088e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0692a3c9bc5827fe32fe74e75e9088e">&#9670;&nbsp;</a></span>create()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGP.html">GP</a>&lt; <a class="el" href="classIFFByteStream.html">IFFByteStream</a> &gt; IFFByteStream::create </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGP.html">GP</a>&lt; <a class="el" href="classByteStream.html">ByteStream</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>bs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs an <a class="el" href="classIFFByteStream.html">IFFByteStream</a> object attached to <a class="el" href="classByteStream.html">ByteStream</a> #bs#. Any <a class="el" href="classByteStream.html">ByteStream</a> can be used when reading an IFF file. Writing an IFF file however requires a seekable <a class="el" href="classByteStream.html">ByteStream</a>. </p>

</div>
</div>
<a id="a3d55e602a9d4d8e3a2dd3fe42340fab2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d55e602a9d4d8e3a2dd3fe42340fab2">&#9670;&nbsp;</a></span>flush()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IFFByteStream::flush </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Flushes all buffers in the <a class="el" href="classByteStream.html">ByteStream</a>. Calling this function guarantees that pending data have been actually written (i.e. passed to the operating system). <a class="el" href="structClass.html">Class</a> <a class="el" href="classByteStream.html">ByteStream</a># provides a default implementation which does nothing. </p>

</div>
</div>
<a id="abbcac023201687657bf623acd364aa7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbcac023201687657bf623acd364aa7c">&#9670;&nbsp;</a></span>full_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IFFByteStream::full_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGUTF8String.html">GUTF8String</a> &amp;&#160;</td>
          <td class="paramname"><em>chkid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the qualified chunk identifier of the current chunk. String #chkid# is overwritten with the {<em>qualified</em> chunk identifier} of the current chunk. The qualified chunk identifier of a composite chunk is equal to the extended chunk identifier. The qualified chunk identifier of a regular chunk is composed by concatenating the secondary chunk identifier of the closest #"FORM"# or #"PROP"# composite chunk containing the current chunk, a dot #"."#, and the current chunk identifier, as in #"DJVU.INFO"#. According to the EA IFF 85 identifier scoping rules, the qualified chunk identifier uniquely defines how the chunk data should be interpreted. </p>

</div>
</div>
<a id="a090b649ebbbf504069eac0d62452c8a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a090b649ebbbf504069eac0d62452c8a6">&#9670;&nbsp;</a></span>get_chunk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IFFByteStream::get_chunk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGUTF8String.html">GUTF8String</a> &amp;&#160;</td>
          <td class="paramname"><em>chkid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>rawoffsetptr</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>rawsizeptr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enters a chunk for reading. Function <a class="el" href="classIFFByteStream.html#a090b649ebbbf504069eac0d62452c8a6">get_chunk</a># returns zero when the last chunk has already been accessed. Otherwise it parses a chunk header, positions the <a class="el" href="classIFFByteStream.html">IFFByteStream</a> at the beginning of the chunk data, stores the extended chunk identifier into string #chkid#, and returns the non zero chunk size. The file offset of the chunk data may be retrieved using function #tell#. The chunk data can then be read using function #read# until reaching the end of the chunk. Advanced users may supply two pointers to integer variables using arguments #rawoffsetptr# and #rawsizeptr#. These variables will be overwritten with the offset and the length of the file segment containing both the chunk header and the chunk data. </p>

</div>
</div>
<a id="a577fe0c110b716ab62d4ee26fcdeaffe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a577fe0c110b716ab62d4ee26fcdeaffe">&#9670;&nbsp;</a></span>put_chunk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IFFByteStream::put_chunk </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>chkid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>insertmagic</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enters a chunk for writing. Function <a class="el" href="classIFFByteStream.html#a577fe0c110b716ab62d4ee26fcdeaffe">put_chunk</a># prepares a chunk header and positions the <a class="el" href="classIFFByteStream.html">IFFByteStream</a> at the beginning of the chunk data. Argument #chkid# defines a extended chunk identifier for this chunk. The chunk data can then be written using function #write#. The chunk is terminated by a matching call to function <a class="el" href="classIFFByteStream.html#affc4e3889ab3c9a611e4600b1f7025d6">close_chunk</a>#. When #insertmagic# is non zero, function <a class="el" href="classIFFByteStream.html#a577fe0c110b716ab62d4ee26fcdeaffe">put_chunk</a># inserts the bytes: 0x41, 0x54, 0x26, 0x54 before the chunk header, as discussed in \Ref{<a class="el" href="IFFByteStream_8h_source.html">IFFByteStream.h</a>}. </p>

</div>
</div>
<a id="a6ebac52c8cb9be0745b84c943c3d7403"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ebac52c8cb9be0745b84c943c3d7403">&#9670;&nbsp;</a></span>ready()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IFFByteStream::ready </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true when it is legal to call #read# or #write#. </p>

</div>
</div>
<a id="a52fd2a62aaf2f41a44d04c1291ed9d23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52fd2a62aaf2f41a44d04c1291ed9d23">&#9670;&nbsp;</a></span>seek_close_chunk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IFFByteStream::seek_close_chunk </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is identical to the above, plus it adds a seek to the start of the next chunk. This way we catch EOF errors with the current chunk. </p>

</div>
</div>
<a id="a260247d28f251a5e87a8d1c0c51d5b91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a260247d28f251a5e87a8d1c0c51d5b91">&#9670;&nbsp;</a></span>short_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IFFByteStream::short_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGUTF8String.html">GUTF8String</a> &amp;&#160;</td>
          <td class="paramname"><em>chkid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the current chunk identifier of the current chunk. String #chkid# is overwritten with the {<em>extended</em> chunk identifier} of the current chunk. The extended chunk identifier of a regular chunk is simply the chunk identifier, as in #"PM44"#. The extended chunk identifier of a composite chunk is the concatenation of the chunk identifier, of a semicolon #":"#, and of the secondary chunk identifier, as in #"FORM:DJVU"#. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a6a9a71b34ea64b7b2a4b5fa05ff4297d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a9a71b34ea64b7b2a4b5fa05ff4297d">&#9670;&nbsp;</a></span>has_magic_att</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IFFByteStream::has_magic_att</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classIFFByteStream.html#a6a9a71b34ea64b7b2a4b5fa05ff4297d">has_magic_att</a># is true if the stream has the DjVu magic 'AT&amp;T' marker. </p>

</div>
</div>
<a id="a54d6785d5ff459faa668f5baab448d15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54d6785d5ff459faa668f5baab448d15">&#9670;&nbsp;</a></span>has_magic_sdjv</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IFFByteStream::has_magic_sdjv</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classIFFByteStream.html#a54d6785d5ff459faa668f5baab448d15">has_magic_sdjv</a># is true if the stream has the Celartem magic 'SDJV' marker. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>libdjvu/<a class="el" href="IFFByteStream_8h_source.html">IFFByteStream.h</a></li>
<li>libdjvu/IFFByteStream.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
