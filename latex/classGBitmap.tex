\hypertarget{classGBitmap}{}\doxysection{G\+Bitmap Class Reference}
\label{classGBitmap}\index{GBitmap@{GBitmap}}


{\ttfamily \#include $<$G\+Bitmap.\+h$>$}



Inheritance diagram for G\+Bitmap\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=149pt]{classGBitmap__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for G\+Bitmap\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classGBitmap__coll__graph}
\end{center}
\end{figure}
\doxysubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{classGBitmap_1_1ZeroBuffer}{Zero\+Buffer}}
\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classGBitmap_a3b09711f6b528f4cd90b1d5057d3d886}\label{classGBitmap_a3b09711f6b528f4cd90b1d5057d3d886}} 
void {\bfseries destroy} (void)
\end{DoxyCompactItemize}
\begin{Indent}\textbf{ Initialization.}\par
\begin{DoxyCompactItemize}
\item 
void \mbox{\hyperlink{classGBitmap_a9c33272be5ddb95fef2087a4310cbe3a}{init}} (int nrows, int ncolumns, int border=0)
\item 
void \mbox{\hyperlink{classGBitmap_a7266ecb2deb89cfd50db59ad49482652}{init}} (const \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} \&ref, int border=0)
\item 
void \mbox{\hyperlink{classGBitmap_a3cdb3138e30b689a17f6e24d4a8c2460}{init}} (const \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} \&ref, const \mbox{\hyperlink{classGRect}{G\+Rect}} \&rect, int border=0)
\item 
void \mbox{\hyperlink{classGBitmap_a025a599af33edd476739e11045a867c7}{init}} (\mbox{\hyperlink{classByteStream}{Byte\+Stream}} \&ref, int border=0)
\item 
\mbox{\hyperlink{classGBitmap}{G\+Bitmap}} \& \mbox{\hyperlink{classGBitmap_a8d22e48fe302d9f3ee840d6df4c39159}{operator=}} (const \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} \&ref)
\item 
void \mbox{\hyperlink{classGBitmap_a7338fa0f63ddcf387b3ed600d1b5bbbe}{fill}} (unsigned char value)
\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}\textbf{ Accessing the pixels.}\par
\begin{DoxyCompactItemize}
\item 
unsigned int \mbox{\hyperlink{classGBitmap_a26b93e377634a1d987891f76ede12f19}{rows}} () const
\item 
unsigned int \mbox{\hyperlink{classGBitmap_a832aa406493c7279ae3a1a9ba36ba5c0}{columns}} () const
\item 
const unsigned char $\ast$ \mbox{\hyperlink{classGBitmap_a913f235312cacfca2ecb1e0bee28dd8b}{operator\mbox{[}$\,$\mbox{]}}} (int row) const
\item 
unsigned char $\ast$ \mbox{\hyperlink{classGBitmap_a0ea910fa9f2131abd63be2bd57e26eb9}{operator\mbox{[}$\,$\mbox{]}}} (int row)
\item 
unsigned int \mbox{\hyperlink{classGBitmap_adedb71b850f07744201ad0ee0a4756f7}{rowsize}} () const
\item 
void \mbox{\hyperlink{classGBitmap_a0a16be0e063dcab9046581ae2afdd3ee}{minborder}} (int minimum)
\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}\textbf{ Managing gray levels.}\par
\begin{DoxyCompactItemize}
\item 
int \mbox{\hyperlink{classGBitmap_a020b42ff0ef5fea675f30252eabfad4a}{get\+\_\+grays}} () const
\item 
void \mbox{\hyperlink{classGBitmap_a1f205dd8631d74fe66abbf8c8103953f}{set\+\_\+grays}} (int grays)
\item 
void \mbox{\hyperlink{classGBitmap_a0bd82b9d6776bd0aed1b8fcc8258ed7e}{change\+\_\+grays}} (int grays)
\item 
void \mbox{\hyperlink{classGBitmap_a7eca6b8830c1edada7bc145d9de315f5}{binarize\+\_\+grays}} (int threshold=0)
\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}\textbf{ Optimizing the memory usage.}\par
{\em ~\newline
 The amount of memory used by bilevel images can be reduced using function \textbackslash{}\+Ref\{compress\}, which encodes the image using a run-\/length encoding scheme. The bracket operator decompresses the image on demand. A few highly optimized functions (e.\+g. \textbackslash{}\+Ref\{blit\}) can use a run-\/length encoded bitmap without decompressing it. There are unfortunate locking issues associated with this capability (c.\+f. \textbackslash{}\+Ref\{share\} and \textbackslash{}\+Ref\{monitor\}). }\begin{DoxyCompactItemize}
\item 
void \mbox{\hyperlink{classGBitmap_a5204ead23ad993af5c23653374cfdac6}{compress}} ()
\item 
void \mbox{\hyperlink{classGBitmap_a2244bdca28d95f698759b690ad37d204}{uncompress}} ()
\item 
unsigned int \mbox{\hyperlink{classGBitmap_ab820fa24b0f604525824e730912427e8}{get\+\_\+memory\+\_\+usage}} () const
\item 
\mbox{\hyperlink{classGMonitor}{G\+Monitor}} $\ast$ \mbox{\hyperlink{classGBitmap_ac4b02d29e39c0c5c97fe10b56640707c}{monitor}} () const
\item 
void \mbox{\hyperlink{classGBitmap_a01acec46ce509879747ade5858b96750}{share}} ()
\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}\textbf{ Additive Blit.}\par
{\em ~\newline
 The blit functions are designed to efficiently construct an anti-\/aliased image by copying smaller images at predefined locations. The image of a page, for instance, is composed by copying the images of characters at predefined locations. These functions are fairly optimized. They can directly use compressed G\+Bitmaps (see \textbackslash{}\+Ref\{compress\}). We consider in this section that each \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} comes with a coordinate system defined as follows. Position (\#0\#,\#0\#) corresponds to the bottom left corner of the bottom left pixel. Position (\#1\#,\#1\#) corresponds to the top right corner of the bottom left pixel, which is also the bottom left corner of the second pixel of the second row. Position (\#w\#,\#h\#), where \#w\# and \#h\# denote the size of the \mbox{\hyperlink{classGBitmap}{G\+Bitmap}}, corresponds to the top right corner of the top right pixel. }\begin{DoxyCompactItemize}
\item 
void \mbox{\hyperlink{classGBitmap_a8480f698e247c866153a5debe10fb95c}{blit}} (const \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} $\ast$bm, int x, int y)
\item 
void \mbox{\hyperlink{classGBitmap_a00cb19719135c453eda2240f4f76782b}{blit}} (const \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} $\ast$shape, int x, int y, int subsample)
\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}\textbf{ Saving images.}\par
{\em ~\newline
 The following functions write P\+BM, P\+GM and R\+LE files. P\+BM and P\+GM are well known formats for bilevel and gray-\/level images. The R\+LE is a simple run-\/length encoding scheme for bilevel images. These files can be read using the \mbox{\hyperlink{classByteStream}{Byte\+Stream}} based constructor or initialization function. See \textbackslash{}\+Ref\{P\+NM and R\+LE file formats\} for more information. }\begin{DoxyCompactItemize}
\item 
void \mbox{\hyperlink{classGBitmap_ab08cbb17f67a1c04e3f5bcef3064d93a}{save\+\_\+pbm}} (\mbox{\hyperlink{classByteStream}{Byte\+Stream}} \&bs, int raw=1)
\item 
void \mbox{\hyperlink{classGBitmap_ae84537e31a15ce2a4cf64aefa73ef5f0}{save\+\_\+pgm}} (\mbox{\hyperlink{classByteStream}{Byte\+Stream}} \&bs, int raw=1)
\item 
void \mbox{\hyperlink{classGBitmap_a0f860c0b7817d1ed69950d068abe90bf}{save\+\_\+rle}} (\mbox{\hyperlink{classByteStream}{Byte\+Stream}} \&bs)
\end{DoxyCompactItemize}
\end{Indent}
\doxysubsection*{Static Public Member Functions}
\begin{Indent}\textbf{ Construction.}\par
\begin{DoxyCompactItemize}
\item 
static \mbox{\hyperlink{classGP}{GP}}$<$ \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} $>$ \mbox{\hyperlink{classGBitmap_a3183f6375c60073209586060f908d9ef}{create}} (void)
\item 
static \mbox{\hyperlink{classGP}{GP}}$<$ \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} $>$ \mbox{\hyperlink{classGBitmap_a0687095c32571d41b2faaa533973bbec}{create}} (const int nrows, const int ncolumns, const int border=0)
\item 
static \mbox{\hyperlink{classGP}{GP}}$<$ \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} $>$ \mbox{\hyperlink{classGBitmap_add8c9490fbe77215e759eb9bb5b6f565}{create}} (const \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} \&ref)
\item 
static \mbox{\hyperlink{classGP}{GP}}$<$ \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} $>$ \mbox{\hyperlink{classGBitmap_a5603e4c5d424a9cd559f8e3c1aa2ff4b}{create}} (const \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} \&ref, const int border)
\item 
static \mbox{\hyperlink{classGP}{GP}}$<$ \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} $>$ \mbox{\hyperlink{classGBitmap_ae9ac7fb9e984fea1ed9d8179d128dc0e}{create}} (const \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} \&ref, const \mbox{\hyperlink{classGRect}{G\+Rect}} \&rect, const int border=0)
\item 
static \mbox{\hyperlink{classGP}{GP}}$<$ \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} $>$ \mbox{\hyperlink{classGBitmap_a204e3d4608c80dd742cd673b556ded88}{create}} (\mbox{\hyperlink{classByteStream}{Byte\+Stream}} \&ref, const int border=0)
\end{DoxyCompactItemize}
\end{Indent}
\doxysubsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classGBitmap_a6d274497aecd1dc040960081717cdad9}\label{classGBitmap_a6d274497aecd1dc040960081717cdad9}} 
{\bfseries G\+Bitmap} (int nrows, int ncolumns, int border=0)
\item 
\mbox{\Hypertarget{classGBitmap_a288c13b7acb6b5d59e6ca3668f302173}\label{classGBitmap_a288c13b7acb6b5d59e6ca3668f302173}} 
{\bfseries G\+Bitmap} (const \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} \&ref)
\item 
\mbox{\Hypertarget{classGBitmap_a9e2e584e4baf1f9e2feb028a4d884905}\label{classGBitmap_a9e2e584e4baf1f9e2feb028a4d884905}} 
{\bfseries G\+Bitmap} (const \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} \&ref, int border)
\item 
\mbox{\Hypertarget{classGBitmap_a44cd5af01c131eac2da44a913b080190}\label{classGBitmap_a44cd5af01c131eac2da44a913b080190}} 
{\bfseries G\+Bitmap} (const \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} \&ref, const \mbox{\hyperlink{classGRect}{G\+Rect}} \&rect, int border=0)
\item 
\mbox{\Hypertarget{classGBitmap_a2e442b7f570df328341b3dbf22a6011b}\label{classGBitmap_a2e442b7f570df328341b3dbf22a6011b}} 
{\bfseries G\+Bitmap} (\mbox{\hyperlink{classByteStream}{Byte\+Stream}} \&ref, int border=0)
\end{DoxyCompactItemize}
\doxysubsection*{Accessing R\+LE data.}
\label{_amgrp8ec67c12cfd55efc43933f93a8fcddfc}%
The next functions are useful for processing bilevel images encoded using the run length encoding scheme. These functions always return zero if the bitmap is not R\+LE encoded. Function \textbackslash{}\+Ref\{compress\} must be used to ensure that the bitmap is R\+LE encoded. ~\newline
 \begin{DoxyCompactItemize}
\item 
int \mbox{\hyperlink{classGBitmap_a6f24b1c6f4617bd91bf8d649246285a5}{rle\+\_\+get\+\_\+bits}} (int rowno, unsigned char $\ast$bits) const
\item 
int \mbox{\hyperlink{classGBitmap_adeba63149e45bf7c3df0e727b624e0b6}{rle\+\_\+get\+\_\+runs}} (int rowno, int $\ast$rlens) const
\item 
int \mbox{\hyperlink{classGBitmap_aed863414ad68f8a97f2d66793af4e1ad}{rle\+\_\+get\+\_\+rect}} (\mbox{\hyperlink{classGRect}{G\+Rect}} \&rect) const
\item 
static void \mbox{\hyperlink{classGBitmap_aa78fd1c091a53c9a3e8ae9123ecdc54e}{rle\+\_\+get\+\_\+bitmap}} (const int ncolumns, const unsigned char $\ast$\&runs, unsigned char $\ast$bitmap, const bool invert)
\end{DoxyCompactItemize}
\doxysubsection*{Stealing or borrowing the memory buffer (advanced).}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classGBitmap_a12d8954bd0d5a1ba111bd784c0ea90b4}\label{classGBitmap_a12d8954bd0d5a1ba111bd784c0ea90b4}} 
enum \{ {\bfseries M\+A\+X\+R\+U\+N\+S\+I\+ZE} =0x3fff
 \}
\item 
\mbox{\Hypertarget{classGBitmap_a07a323b59f4a98d84fd2ed5a107c2f05}\label{classGBitmap_a07a323b59f4a98d84fd2ed5a107c2f05}} 
enum \{ {\bfseries R\+U\+N\+O\+V\+E\+R\+F\+L\+O\+W\+V\+A\+L\+UE} =0xc0
 \}
\item 
\mbox{\Hypertarget{classGBitmap_aa592c8ac6b69c21828b5719c9f19bed7}\label{classGBitmap_aa592c8ac6b69c21828b5719c9f19bed7}} 
enum \{ {\bfseries R\+U\+N\+M\+S\+B\+M\+A\+SK} =0x3f
 \}
\item 
\mbox{\Hypertarget{classGBitmap_af589e39f9bd8f25eef3685d4791434c9}\label{classGBitmap_af589e39f9bd8f25eef3685d4791434c9}} 
enum \{ {\bfseries R\+U\+N\+L\+S\+B\+M\+A\+SK} =0xff
 \}
\item 
\mbox{\Hypertarget{classGBitmap_a1af765fedc6b20527ce68d003e62268e}\label{classGBitmap_a1af765fedc6b20527ce68d003e62268e}} 
unsigned short {\bfseries nrows}
\item 
\mbox{\Hypertarget{classGBitmap_a88bc922042a2b83b390266b3c0a97bcd}\label{classGBitmap_a88bc922042a2b83b390266b3c0a97bcd}} 
unsigned short {\bfseries ncolumns}
\item 
\mbox{\Hypertarget{classGBitmap_ae789bf23be6a3c28fc5674143a51d7f0}\label{classGBitmap_ae789bf23be6a3c28fc5674143a51d7f0}} 
unsigned short {\bfseries border}
\item 
\mbox{\Hypertarget{classGBitmap_aa130addbe5dbe9945750c8b80dcee6df}\label{classGBitmap_aa130addbe5dbe9945750c8b80dcee6df}} 
unsigned short {\bfseries bytes\+\_\+per\+\_\+row}
\item 
\mbox{\Hypertarget{classGBitmap_a533c3a0dfc824590e3e8b64d3668e92e}\label{classGBitmap_a533c3a0dfc824590e3e8b64d3668e92e}} 
unsigned short {\bfseries grays}
\item 
\mbox{\Hypertarget{classGBitmap_ab47a42cbefd58deabfeb4ccc73ce198e}\label{classGBitmap_ab47a42cbefd58deabfeb4ccc73ce198e}} 
unsigned char $\ast$ {\bfseries bytes}
\item 
\mbox{\Hypertarget{classGBitmap_ae175151e1d3e802582f33fb9018b3a6a}\label{classGBitmap_ae175151e1d3e802582f33fb9018b3a6a}} 
unsigned char $\ast$ {\bfseries bytes\+\_\+data}
\item 
\mbox{\Hypertarget{classGBitmap_ad38fe93856599e2083bda21f3bb13dbc}\label{classGBitmap_ad38fe93856599e2083bda21f3bb13dbc}} 
\mbox{\hyperlink{classGPBuffer}{G\+P\+Buffer}}$<$ unsigned char $>$ {\bfseries gbytes\+\_\+data}
\item 
\mbox{\Hypertarget{classGBitmap_acbcd094e1403efbdb9bacf271726087a}\label{classGBitmap_acbcd094e1403efbdb9bacf271726087a}} 
unsigned char $\ast$ {\bfseries rle}
\item 
\mbox{\Hypertarget{classGBitmap_a296d52b3017865b60626826caf796e37}\label{classGBitmap_a296d52b3017865b60626826caf796e37}} 
\mbox{\hyperlink{classGPBuffer}{G\+P\+Buffer}}$<$ unsigned char $>$ {\bfseries grle}
\item 
\mbox{\Hypertarget{classGBitmap_a7d6329dc7605bfd1dc5aa47cb1d502ca}\label{classGBitmap_a7d6329dc7605bfd1dc5aa47cb1d502ca}} 
unsigned char $\ast$$\ast$ {\bfseries rlerows}
\item 
\mbox{\Hypertarget{classGBitmap_a4749befec63f423a47679498d97bd61c}\label{classGBitmap_a4749befec63f423a47679498d97bd61c}} 
\mbox{\hyperlink{classGPBuffer}{G\+P\+Buffer}}$<$ unsigned char $\ast$ $>$ {\bfseries grlerows}
\item 
\mbox{\Hypertarget{classGBitmap_ac2ce8685a122fa097facd2ee64673cb3}\label{classGBitmap_ac2ce8685a122fa097facd2ee64673cb3}} 
unsigned int {\bfseries rlelength}
\item 
\mbox{\Hypertarget{classGBitmap_a9654b799ae80a245721479dad96c3ccb}\label{classGBitmap_a9654b799ae80a245721479dad96c3ccb}} 
class {\bfseries Zero\+Buffer}
\item 
\mbox{\Hypertarget{classGBitmap_a6bf7dd70dc7c90bb35187270b0cf510f}\label{classGBitmap_a6bf7dd70dc7c90bb35187270b0cf510f}} 
class {\bfseries Dj\+Vu\+\_\+\+Stream}
\item 
\mbox{\Hypertarget{classGBitmap_aab05b67b1d782ea524df9aab76d702c2}\label{classGBitmap_aab05b67b1d782ea524df9aab76d702c2}} 
class {\bfseries Dj\+Vu\+\_\+\+Pix\+Image}
\item 
\mbox{\Hypertarget{classGBitmap_adabff4931bb9cdecdc2a77373c6d8ba1}\label{classGBitmap_adabff4931bb9cdecdc2a77373c6d8ba1}} 
\mbox{\hyperlink{classGP}{GP}}$<$ \mbox{\hyperlink{classGBitmap_1_1ZeroBuffer}{Zero\+Buffer}} $>$ {\bfseries gzerobuffer}
\item 
unsigned char $\ast$ \mbox{\hyperlink{classGBitmap_ac8aab5b49b79f8454a2ca9864ce53680}{take\+\_\+data}} (size\+\_\+t \&offset)
\item 
void \mbox{\hyperlink{classGBitmap_afa87afc89907c6e1fc3083cb5c493d70}{borrow\+\_\+data}} (unsigned char \&data, int w, int h)
\item 
void \mbox{\hyperlink{classGBitmap_ae4ea33759a2c8b514e1d11ccac36ef8f}{donate\+\_\+data}} (unsigned char $\ast$data, int w, int h)
\item 
const unsigned char $\ast$ \mbox{\hyperlink{classGBitmap_aeba0b0841d50cb3d358d3e5cf3a1d3e7}{get\+\_\+rle}} (unsigned int \&rle\+\_\+length)
\item 
void \mbox{\hyperlink{classGBitmap_ab0326f7cb1a6ddca8543d2da37662b7e}{donate\+\_\+rle}} (unsigned char $\ast$rledata, unsigned int rledatalen, int w, int h)
\item 
\mbox{\hyperlink{classGP}{GP}}$<$ \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} $>$ \mbox{\hyperlink{classGBitmap_a20ec1cdefbaacc08be5801c7f179a73c}{rotate}} (int \mbox{\hyperlink{classGPEnabled_aaeebfa533635d29cc70aaa3620678734}{count}}=0)
\item 
\mbox{\Hypertarget{classGBitmap_a6e1cd3f08f8869c557ef57c26510025b}\label{classGBitmap_a6e1cd3f08f8869c557ef57c26510025b}} 
void {\bfseries check\+\_\+border} () const
\item 
static int \mbox{\hyperlink{classGBitmap_a5f96f5f4259de4ee301ab4cc3864ca03}{read\+\_\+run}} (const unsigned char $\ast$\&data)
\item 
\mbox{\Hypertarget{classGBitmap_a7cf0a4335c0fa3570b89a5c95e401057}\label{classGBitmap_a7cf0a4335c0fa3570b89a5c95e401057}} 
static int {\bfseries read\+\_\+run} (unsigned char $\ast$\&data)
\item 
static void \mbox{\hyperlink{classGBitmap_ad9c501fdb8510a1152b62d03ec6d51b8}{append\+\_\+run}} (unsigned char $\ast$\&data, int \mbox{\hyperlink{classGPEnabled_aaeebfa533635d29cc70aaa3620678734}{count}})
\end{DoxyCompactItemize}
\doxysubsection*{Additional Inherited Members}


\doxysubsection{Detailed Description}
Bilevel and gray-\/level images. Instances of class \mbox{\hyperlink{classGBitmap}{G\+Bitmap}}\# represent bilevel or gray-\/level images. Images are usually represented using one byte per pixel. Value zero represents a white pixel. A value equal to the number of gray levels minus one represents a black pixel. The number of gray levels is returned by the function \textbackslash{}\+Ref\{get\+\_\+grays\} and can be manipulated by the functions \textbackslash{}\+Ref\{set\+\_\+grays\} and \textbackslash{}\+Ref\{change\+\_\+grays\}.

The bracket operator returns a pointer to the bytes composing one line of the image. This pointer can be used to read or write the image pixels. Line zero represents the bottom line of the image.

The memory organization is setup in such a way that you can safely read a few pixels located in a small border surrounding all four sides of the image. The width of this border can be modified using the function \textbackslash{}\+Ref\{minborder\}. The border pixels are initialized to zero and therefore represent white pixels. You should never write anything into border pixels because they are shared between images and between lines. ~\newline
 

\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{classGBitmap_ad9c501fdb8510a1152b62d03ec6d51b8}\label{classGBitmap_ad9c501fdb8510a1152b62d03ec6d51b8}} 
\index{GBitmap@{GBitmap}!append\_run@{append\_run}}
\index{append\_run@{append\_run}!GBitmap@{GBitmap}}
\doxysubsubsection{\texorpdfstring{append\_run()}{append\_run()}}
{\footnotesize\ttfamily void G\+Bitmap\+::append\+\_\+run (\begin{DoxyParamCaption}\item[{unsigned char $\ast$\&}]{data,  }\item[{int}]{count }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}

Static function for generating run data. This function encoded run length \mbox{\hyperlink{classGPEnabled_aaeebfa533635d29cc70aaa3620678734}{count}}\# at position \#data\# and increments the pointer accordingly. The pointer must initially point to a large enough data buffer. \mbox{\Hypertarget{classGBitmap_a7eca6b8830c1edada7bc145d9de315f5}\label{classGBitmap_a7eca6b8830c1edada7bc145d9de315f5}} 
\index{GBitmap@{GBitmap}!binarize\_grays@{binarize\_grays}}
\index{binarize\_grays@{binarize\_grays}!GBitmap@{GBitmap}}
\doxysubsubsection{\texorpdfstring{binarize\_grays()}{binarize\_grays()}}
{\footnotesize\ttfamily void G\+Bitmap\+::binarize\+\_\+grays (\begin{DoxyParamCaption}\item[{int}]{threshold = {\ttfamily 0} }\end{DoxyParamCaption})}

Binarizes a gray level image using a threshold. The number of gray levels is reduced to \#2\# as in a bilevel image. All pixels whose value was strictly greater than \#threshold\# are set to black. All other pixels are set to white. \mbox{\Hypertarget{classGBitmap_a8480f698e247c866153a5debe10fb95c}\label{classGBitmap_a8480f698e247c866153a5debe10fb95c}} 
\index{GBitmap@{GBitmap}!blit@{blit}}
\index{blit@{blit}!GBitmap@{GBitmap}}
\doxysubsubsection{\texorpdfstring{blit()}{blit()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void G\+Bitmap\+::blit (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} $\ast$}]{bm,  }\item[{int}]{x,  }\item[{int}]{y }\end{DoxyParamCaption})}

Performs an additive blit of the \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} \#bm\#. The \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} \#bm\# is first positioned above the current \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} in such a way that position (\#u\#,\#v\#) in \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} \#bm\# corresponds to position (\#u\#+\#x\#,\#v\#+\#y\#) in the current \mbox{\hyperlink{classGBitmap}{G\+Bitmap}}. The value of each pixel in \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} \#bm\# is then added to the value of the corresponding pixel in the current \mbox{\hyperlink{classGBitmap}{G\+Bitmap}}.

\{\textbackslash{}bf Example\}\+: Assume for instance that the current \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} is initially white (all pixels have value zero). This operation copies the pixel values of \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} \#bm\# at position (\#x\#,\#y\#) into the current \mbox{\hyperlink{classGBitmap}{G\+Bitmap}}. Note that function \mbox{\hyperlink{classGBitmap_a8480f698e247c866153a5debe10fb95c}{blit}}\# does not change the number of gray levels in the current \mbox{\hyperlink{classGBitmap}{G\+Bitmap}}. You may have to call \textbackslash{}\+Ref\{set\+\_\+grays\} to specify how the pixel values should be interpreted. \mbox{\Hypertarget{classGBitmap_a00cb19719135c453eda2240f4f76782b}\label{classGBitmap_a00cb19719135c453eda2240f4f76782b}} 
\index{GBitmap@{GBitmap}!blit@{blit}}
\index{blit@{blit}!GBitmap@{GBitmap}}
\doxysubsubsection{\texorpdfstring{blit()}{blit()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void G\+Bitmap\+::blit (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} $\ast$}]{shape,  }\item[{int}]{x,  }\item[{int}]{y,  }\item[{int}]{subsample }\end{DoxyParamCaption})}

Performs an additive blit of the \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} \#bm\# with anti-\/aliasing. The \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} \#bm\# is first positioned above the current \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} in such a way that position (\#u\#,\#v\#) in \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} \#bm\# corresponds to position (\#u\#+\#x\#/\#subsample\#,\#v\#+\#y\#/\#subsample\#) in the current \mbox{\hyperlink{classGBitmap}{G\+Bitmap}}. This mapping results in a contraction of \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} \#bm\# by a factor \#subsample\#. Each pixel of the current \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} can be covered by a maximum of \#subsample$^\wedge$2\# pixels of \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} \#bm\#. The value of each pixel in \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} \#bm\# is then added to the value of the corresponding pixel in the current \mbox{\hyperlink{classGBitmap}{G\+Bitmap}}.

\{\textbackslash{}bf Example\}\+: Assume for instance that the current \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} is initially white (all pixels have value zero). Each pixel of the current \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} then contains the sum of the gray levels of the corresponding pixels in \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} \#bm\#. There are up to \#subsample$\ast$subsample\# such pixels. If for instance \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} \#bm\# is a bilevel image (pixels can be \#0\# or \#1\#), the pixels of the current \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} can take values in range \#0\# to \#subsample$\ast$subsample\#. Note that function \mbox{\hyperlink{classGBitmap_a8480f698e247c866153a5debe10fb95c}{blit}}\# does not change the number of gray levels in the current \mbox{\hyperlink{classGBitmap}{G\+Bitmap}}. You must call \textbackslash{}\+Ref\{set\+\_\+grays\} to indicate that there are \#subsample$^\wedge$2+1\# gray levels. Since there is at most 256 gray levels, this also means that \#subsample\# should never be greater than \#15\#.

\{\textbackslash{}bf Remark\}\+: Arguments \#x\# and \#y\# do not represent a position in the coordinate system of the current \mbox{\hyperlink{classGBitmap}{G\+Bitmap}}. According to the above discussion, the position is (\#x/subsample\#,\#y/subsample\#). In other words, you can position the blit with a sub-\/pixel resolution. The resulting anti-\/aliasing changes are paramount to the image quality. \mbox{\Hypertarget{classGBitmap_afa87afc89907c6e1fc3083cb5c493d70}\label{classGBitmap_afa87afc89907c6e1fc3083cb5c493d70}} 
\index{GBitmap@{GBitmap}!borrow\_data@{borrow\_data}}
\index{borrow\_data@{borrow\_data}!GBitmap@{GBitmap}}
\doxysubsubsection{\texorpdfstring{borrow\_data()}{borrow\_data()}}
{\footnotesize\ttfamily void G\+Bitmap\+::borrow\+\_\+data (\begin{DoxyParamCaption}\item[{unsigned char \&}]{data,  }\item[{int}]{w,  }\item[{int}]{h }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Initializes this \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} by borrowing a memory segment. The \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} then directly addresses the memory buffer \#data\# provided by the user. This buffer must be large enough to hold \#w$\ast$h\# bytes representing each one pixel. The \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} object does not \`{}`own'\textquotesingle{} the buffer\+: you must explicitly de-\/allocate the buffer using \#operator delete \mbox{[}$\,$\mbox{]}\#. This de-\/allocation should take place after the destruction or the re-\/initialization of the \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} object. ~\newline
 \mbox{\Hypertarget{classGBitmap_a0bd82b9d6776bd0aed1b8fcc8258ed7e}\label{classGBitmap_a0bd82b9d6776bd0aed1b8fcc8258ed7e}} 
\index{GBitmap@{GBitmap}!change\_grays@{change\_grays}}
\index{change\_grays@{change\_grays}!GBitmap@{GBitmap}}
\doxysubsubsection{\texorpdfstring{change\_grays()}{change\_grays()}}
{\footnotesize\ttfamily void G\+Bitmap\+::change\+\_\+grays (\begin{DoxyParamCaption}\item[{int}]{grays }\end{DoxyParamCaption})}

Changes the number of gray levels. The argument \#grays\# must be in the range \#2\# to \#256\#. All the pixel values are then rescaled and clipped in range \#0\# to \#grays-\/1\#. \mbox{\Hypertarget{classGBitmap_a832aa406493c7279ae3a1a9ba36ba5c0}\label{classGBitmap_a832aa406493c7279ae3a1a9ba36ba5c0}} 
\index{GBitmap@{GBitmap}!columns@{columns}}
\index{columns@{columns}!GBitmap@{GBitmap}}
\doxysubsubsection{\texorpdfstring{columns()}{columns()}}
{\footnotesize\ttfamily unsigned int G\+Bitmap\+::columns (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Returns the number of columns (the image width). \mbox{\Hypertarget{classGBitmap_a5204ead23ad993af5c23653374cfdac6}\label{classGBitmap_a5204ead23ad993af5c23653374cfdac6}} 
\index{GBitmap@{GBitmap}!compress@{compress}}
\index{compress@{compress}!GBitmap@{GBitmap}}
\doxysubsubsection{\texorpdfstring{compress()}{compress()}}
{\footnotesize\ttfamily void G\+Bitmap\+::compress (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Reduces the memory required for a bilevel image by using a run-\/length encoded representation. Functions that need to access the pixel array will decompress the image on demand. \mbox{\Hypertarget{classGBitmap_a204e3d4608c80dd742cd673b556ded88}\label{classGBitmap_a204e3d4608c80dd742cd673b556ded88}} 
\index{GBitmap@{GBitmap}!create@{create}}
\index{create@{create}!GBitmap@{GBitmap}}
\doxysubsubsection{\texorpdfstring{create()}{create()}\hspace{0.1cm}{\footnotesize\ttfamily [1/6]}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classGP}{GP}}$<$\mbox{\hyperlink{classGBitmap}{G\+Bitmap}}$>$ G\+Bitmap\+::create (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classByteStream}{Byte\+Stream}} \&}]{ref,  }\item[{const int}]{border = {\ttfamily 0} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}

Constructs a \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} by reading P\+BM, P\+GM or R\+LE data from \mbox{\hyperlink{classByteStream}{Byte\+Stream}} \#ref\# into this \mbox{\hyperlink{classGBitmap}{G\+Bitmap}}. The optional argument \#border\# specifies the size of the optional border of white pixels surrounding the image. See \textbackslash{}\+Ref\{P\+NM and R\+LE file formats\} for more information. ~\newline
 \mbox{\Hypertarget{classGBitmap_add8c9490fbe77215e759eb9bb5b6f565}\label{classGBitmap_add8c9490fbe77215e759eb9bb5b6f565}} 
\index{GBitmap@{GBitmap}!create@{create}}
\index{create@{create}!GBitmap@{GBitmap}}
\doxysubsubsection{\texorpdfstring{create()}{create()}\hspace{0.1cm}{\footnotesize\ttfamily [2/6]}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classGP}{GP}}$<$\mbox{\hyperlink{classGBitmap}{G\+Bitmap}}$>$ G\+Bitmap\+::create (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} \&}]{ref }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}

Copy constructor. Constructs a \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} by replicating the size, the border and the contents of \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} \#ref\#. \mbox{\Hypertarget{classGBitmap_ae9ac7fb9e984fea1ed9d8179d128dc0e}\label{classGBitmap_ae9ac7fb9e984fea1ed9d8179d128dc0e}} 
\index{GBitmap@{GBitmap}!create@{create}}
\index{create@{create}!GBitmap@{GBitmap}}
\doxysubsubsection{\texorpdfstring{create()}{create()}\hspace{0.1cm}{\footnotesize\ttfamily [3/6]}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classGP}{GP}}$<$\mbox{\hyperlink{classGBitmap}{G\+Bitmap}}$>$ G\+Bitmap\+::create (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} \&}]{ref,  }\item[{const \mbox{\hyperlink{classGRect}{G\+Rect}} \&}]{rect,  }\item[{const int}]{border = {\ttfamily 0} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}

Constructs a \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} by copying a rectangular segment \#rect\# of \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} \#ref\#. The optional argument \#border\# specifies the size of the optional border of white pixels surrounding the image. \mbox{\Hypertarget{classGBitmap_a5603e4c5d424a9cd559f8e3c1aa2ff4b}\label{classGBitmap_a5603e4c5d424a9cd559f8e3c1aa2ff4b}} 
\index{GBitmap@{GBitmap}!create@{create}}
\index{create@{create}!GBitmap@{GBitmap}}
\doxysubsubsection{\texorpdfstring{create()}{create()}\hspace{0.1cm}{\footnotesize\ttfamily [4/6]}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classGP}{GP}}$<$\mbox{\hyperlink{classGBitmap}{G\+Bitmap}}$>$ G\+Bitmap\+::create (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} \&}]{ref,  }\item[{const int}]{border }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}

Constructs a \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} by copying the contents of \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} \#ref\#. ~\newline
 Argument \#border\# specifies the width of the optional border. \mbox{\Hypertarget{classGBitmap_a0687095c32571d41b2faaa533973bbec}\label{classGBitmap_a0687095c32571d41b2faaa533973bbec}} 
\index{GBitmap@{GBitmap}!create@{create}}
\index{create@{create}!GBitmap@{GBitmap}}
\doxysubsubsection{\texorpdfstring{create()}{create()}\hspace{0.1cm}{\footnotesize\ttfamily [5/6]}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classGP}{GP}}$<$\mbox{\hyperlink{classGBitmap}{G\+Bitmap}}$>$ G\+Bitmap\+::create (\begin{DoxyParamCaption}\item[{const int}]{nrows,  }\item[{const int}]{ncolumns,  }\item[{const int}]{border = {\ttfamily 0} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}

Constructs a \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} with \#nrows\# rows and \#ncolumns\# columns. All pixels are initialized to white. The optional argument \#border\# specifies the size of the optional border of white pixels surrounding the image. The number of gray levels is initially set to \#2\#. ~\newline
 \mbox{\Hypertarget{classGBitmap_a3183f6375c60073209586060f908d9ef}\label{classGBitmap_a3183f6375c60073209586060f908d9ef}} 
\index{GBitmap@{GBitmap}!create@{create}}
\index{create@{create}!GBitmap@{GBitmap}}
\doxysubsubsection{\texorpdfstring{create()}{create()}\hspace{0.1cm}{\footnotesize\ttfamily [6/6]}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classGP}{GP}}$<$\mbox{\hyperlink{classGBitmap}{G\+Bitmap}}$>$ G\+Bitmap\+::create (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}

Constructs an empty \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} object. The returned \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} has zero rows and zero columns. Use function \textbackslash{}\+Ref\{init\} to change the size of the image. \mbox{\Hypertarget{classGBitmap_ae4ea33759a2c8b514e1d11ccac36ef8f}\label{classGBitmap_ae4ea33759a2c8b514e1d11ccac36ef8f}} 
\index{GBitmap@{GBitmap}!donate\_data@{donate\_data}}
\index{donate\_data@{donate\_data}!GBitmap@{GBitmap}}
\doxysubsubsection{\texorpdfstring{donate\_data()}{donate\_data()}}
{\footnotesize\ttfamily void G\+Bitmap\+::donate\+\_\+data (\begin{DoxyParamCaption}\item[{unsigned char $\ast$}]{data,  }\item[{int}]{w,  }\item[{int}]{h }\end{DoxyParamCaption})}

Same as borrow\+\_\+data, except \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} will call \#delete\mbox{[}\mbox{]}\#. \mbox{\Hypertarget{classGBitmap_ab0326f7cb1a6ddca8543d2da37662b7e}\label{classGBitmap_ab0326f7cb1a6ddca8543d2da37662b7e}} 
\index{GBitmap@{GBitmap}!donate\_rle@{donate\_rle}}
\index{donate\_rle@{donate\_rle}!GBitmap@{GBitmap}}
\doxysubsubsection{\texorpdfstring{donate\_rle()}{donate\_rle()}}
{\footnotesize\ttfamily void G\+Bitmap\+::donate\+\_\+rle (\begin{DoxyParamCaption}\item[{unsigned char $\ast$}]{rledata,  }\item[{unsigned int}]{rledatalen,  }\item[{int}]{w,  }\item[{int}]{h }\end{DoxyParamCaption})}

Initializes this \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} by setting the size to \#h\# rows and \#w\# columns, and directly addressing the memory buffer \#rledata\# provided by the user. This buffer contains \#rledatalen\# bytes representing the bitmap in run length encoded form. The \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} object then \`{}`owns'\textquotesingle{} the buffer (unlike \mbox{\hyperlink{classGBitmap_afa87afc89907c6e1fc3083cb5c493d70}{borrow\+\_\+data}}\#, but like \mbox{\hyperlink{classGBitmap_ae4ea33759a2c8b514e1d11ccac36ef8f}{donate\+\_\+data}}\#) and will deallocate this buffer when appropriate\+: you should not deallocate this buffer yourself. The encoding of buffer \#rledata\# is similar to the data segment of the R\+LE file format (without the header) documented in \textbackslash{}\+Ref\{P\+NM and R\+LE file formats\}. ~\newline
 \mbox{\Hypertarget{classGBitmap_a7338fa0f63ddcf387b3ed600d1b5bbbe}\label{classGBitmap_a7338fa0f63ddcf387b3ed600d1b5bbbe}} 
\index{GBitmap@{GBitmap}!fill@{fill}}
\index{fill@{fill}!GBitmap@{GBitmap}}
\doxysubsubsection{\texorpdfstring{fill()}{fill()}}
{\footnotesize\ttfamily void G\+Bitmap\+::fill (\begin{DoxyParamCaption}\item[{unsigned char}]{value }\end{DoxyParamCaption})}

Initializes all the \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} pixels to value \#value\#. \mbox{\Hypertarget{classGBitmap_a020b42ff0ef5fea675f30252eabfad4a}\label{classGBitmap_a020b42ff0ef5fea675f30252eabfad4a}} 
\index{GBitmap@{GBitmap}!get\_grays@{get\_grays}}
\index{get\_grays@{get\_grays}!GBitmap@{GBitmap}}
\doxysubsubsection{\texorpdfstring{get\_grays()}{get\_grays()}}
{\footnotesize\ttfamily int G\+Bitmap\+::get\+\_\+grays (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Returns the number of gray levels. Value \#2\# denotes a bilevel image. \mbox{\Hypertarget{classGBitmap_ab820fa24b0f604525824e730912427e8}\label{classGBitmap_ab820fa24b0f604525824e730912427e8}} 
\index{GBitmap@{GBitmap}!get\_memory\_usage@{get\_memory\_usage}}
\index{get\_memory\_usage@{get\_memory\_usage}!GBitmap@{GBitmap}}
\doxysubsubsection{\texorpdfstring{get\_memory\_usage()}{get\_memory\_usage()}}
{\footnotesize\ttfamily unsigned int G\+Bitmap\+::get\+\_\+memory\+\_\+usage (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}

Returns the number of bytes allocated for this image. \mbox{\Hypertarget{classGBitmap_aeba0b0841d50cb3d358d3e5cf3a1d3e7}\label{classGBitmap_aeba0b0841d50cb3d358d3e5cf3a1d3e7}} 
\index{GBitmap@{GBitmap}!get\_rle@{get\_rle}}
\index{get\_rle@{get\_rle}!GBitmap@{GBitmap}}
\doxysubsubsection{\texorpdfstring{get\_rle()}{get\_rle()}}
{\footnotesize\ttfamily const unsigned char $\ast$ G\+Bitmap\+::get\+\_\+rle (\begin{DoxyParamCaption}\item[{unsigned int \&}]{rle\+\_\+length }\end{DoxyParamCaption})}

Return a pointer to the rle data. \mbox{\Hypertarget{classGBitmap_a025a599af33edd476739e11045a867c7}\label{classGBitmap_a025a599af33edd476739e11045a867c7}} 
\index{GBitmap@{GBitmap}!init@{init}}
\index{init@{init}!GBitmap@{GBitmap}}
\doxysubsubsection{\texorpdfstring{init()}{init()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily void G\+Bitmap\+::init (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classByteStream}{Byte\+Stream}} \&}]{ref,  }\item[{int}]{border = {\ttfamily 0} }\end{DoxyParamCaption})}

Reads P\+BM, P\+GM or R\+LE data from \mbox{\hyperlink{classByteStream}{Byte\+Stream}} \#ref\# into this \mbox{\hyperlink{classGBitmap}{G\+Bitmap}}. The previous content of the \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} object is lost. The optional argument \#border\# specifies the size of the optional border of white pixels surrounding the image. See \textbackslash{}\+Ref\{P\+NM and R\+LE file formats\} for more information. \mbox{\Hypertarget{classGBitmap_a3cdb3138e30b689a17f6e24d4a8c2460}\label{classGBitmap_a3cdb3138e30b689a17f6e24d4a8c2460}} 
\index{GBitmap@{GBitmap}!init@{init}}
\index{init@{init}!GBitmap@{GBitmap}}
\doxysubsubsection{\texorpdfstring{init()}{init()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily void G\+Bitmap\+::init (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} \&}]{ref,  }\item[{const \mbox{\hyperlink{classGRect}{G\+Rect}} \&}]{rect,  }\item[{int}]{border = {\ttfamily 0} }\end{DoxyParamCaption})}

Initializes this \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} with a rectangular segment \#rect\# of \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} \#ref\#. The optional argument \#border\# specifies the size of the optional border of white pixels surrounding the image. \mbox{\Hypertarget{classGBitmap_a7266ecb2deb89cfd50db59ad49482652}\label{classGBitmap_a7266ecb2deb89cfd50db59ad49482652}} 
\index{GBitmap@{GBitmap}!init@{init}}
\index{init@{init}!GBitmap@{GBitmap}}
\doxysubsubsection{\texorpdfstring{init()}{init()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily void G\+Bitmap\+::init (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} \&}]{ref,  }\item[{int}]{border = {\ttfamily 0} }\end{DoxyParamCaption})}

Initializes this \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} with the contents of the \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} \#ref\#. The optional argument \#border\# specifies the size of the optional border of white pixels surrounding the image. \mbox{\Hypertarget{classGBitmap_a9c33272be5ddb95fef2087a4310cbe3a}\label{classGBitmap_a9c33272be5ddb95fef2087a4310cbe3a}} 
\index{GBitmap@{GBitmap}!init@{init}}
\index{init@{init}!GBitmap@{GBitmap}}
\doxysubsubsection{\texorpdfstring{init()}{init()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily void G\+Bitmap\+::init (\begin{DoxyParamCaption}\item[{int}]{nrows,  }\item[{int}]{ncolumns,  }\item[{int}]{border = {\ttfamily 0} }\end{DoxyParamCaption})}

Resets this \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} size to \#nrows\# rows and \#ncolumns\# columns and sets all pixels to white. The optional argument \#border\# specifies the size of the optional border of white pixels surrounding the image. The number of gray levels is initialized to \#2\#. \mbox{\Hypertarget{classGBitmap_a0a16be0e063dcab9046581ae2afdd3ee}\label{classGBitmap_a0a16be0e063dcab9046581ae2afdd3ee}} 
\index{GBitmap@{GBitmap}!minborder@{minborder}}
\index{minborder@{minborder}!GBitmap@{GBitmap}}
\doxysubsubsection{\texorpdfstring{minborder()}{minborder()}}
{\footnotesize\ttfamily void G\+Bitmap\+::minborder (\begin{DoxyParamCaption}\item[{int}]{minimum }\end{DoxyParamCaption})}

Makes sure that the border is at least \#minimum\# pixels large. This function does nothing it the border width is already larger than \#minimum\#. Otherwise it reorganizes the data in order to provide a border of \#minimum\# pixels. \mbox{\Hypertarget{classGBitmap_ac4b02d29e39c0c5c97fe10b56640707c}\label{classGBitmap_ac4b02d29e39c0c5c97fe10b56640707c}} 
\index{GBitmap@{GBitmap}!monitor@{monitor}}
\index{monitor@{monitor}!GBitmap@{GBitmap}}
\doxysubsubsection{\texorpdfstring{monitor()}{monitor()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classGMonitor}{G\+Monitor}} $\ast$ G\+Bitmap\+::monitor (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Returns a possibly null pointer to a \textbackslash{}\+Ref\{\mbox{\hyperlink{classGMonitor}{G\+Monitor}}\} for this bitmap. You should use this monitor to ensure that the data representation of the bitmap will not change while you are using it. We suggest using class \textbackslash{}\+Ref\{\mbox{\hyperlink{classGMonitorLock}{G\+Monitor\+Lock}}\} which properly handles null monitor pointers. \mbox{\Hypertarget{classGBitmap_a8d22e48fe302d9f3ee840d6df4c39159}\label{classGBitmap_a8d22e48fe302d9f3ee840d6df4c39159}} 
\index{GBitmap@{GBitmap}!operator=@{operator=}}
\index{operator=@{operator=}!GBitmap@{GBitmap}}
\doxysubsubsection{\texorpdfstring{operator=()}{operator=()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} \& G\+Bitmap\+::operator= (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} \&}]{ref }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Assignment operator. Initializes this \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} by copying the size, the border and the contents of \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} \#ref\#. \mbox{\Hypertarget{classGBitmap_a0ea910fa9f2131abd63be2bd57e26eb9}\label{classGBitmap_a0ea910fa9f2131abd63be2bd57e26eb9}} 
\index{GBitmap@{GBitmap}!operator\mbox{[}\mbox{]}@{operator[]}}
\index{operator\mbox{[}\mbox{]}@{operator[]}!GBitmap@{GBitmap}}
\doxysubsubsection{\texorpdfstring{operator[]()}{operator[]()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily unsigned char $\ast$ G\+Bitmap\+::operator\mbox{[}$\,$\mbox{]} (\begin{DoxyParamCaption}\item[{int}]{row }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Returns a pointer to the first byte of row \#row\#. This pointer can be used as an array to read or write the row elements. \mbox{\Hypertarget{classGBitmap_a913f235312cacfca2ecb1e0bee28dd8b}\label{classGBitmap_a913f235312cacfca2ecb1e0bee28dd8b}} 
\index{GBitmap@{GBitmap}!operator\mbox{[}\mbox{]}@{operator[]}}
\index{operator\mbox{[}\mbox{]}@{operator[]}!GBitmap@{GBitmap}}
\doxysubsubsection{\texorpdfstring{operator[]()}{operator[]()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily const unsigned char $\ast$ G\+Bitmap\+::operator\mbox{[}$\,$\mbox{]} (\begin{DoxyParamCaption}\item[{int}]{row }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Returns a constant pointer to the first byte of row \#row\#. This pointer can be used as an array to read the row elements. \mbox{\Hypertarget{classGBitmap_a5f96f5f4259de4ee301ab4cc3864ca03}\label{classGBitmap_a5f96f5f4259de4ee301ab4cc3864ca03}} 
\index{GBitmap@{GBitmap}!read\_run@{read\_run}}
\index{read\_run@{read\_run}!GBitmap@{GBitmap}}
\doxysubsubsection{\texorpdfstring{read\_run()}{read\_run()}}
{\footnotesize\ttfamily int G\+Bitmap\+::read\+\_\+run (\begin{DoxyParamCaption}\item[{const unsigned char $\ast$\&}]{data }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}

Static function for parsing run data. This function returns one run length encoded at position \#data\# and increments the pointer \#data\# accordingly. \mbox{\Hypertarget{classGBitmap_aa78fd1c091a53c9a3e8ae9123ecdc54e}\label{classGBitmap_aa78fd1c091a53c9a3e8ae9123ecdc54e}} 
\index{GBitmap@{GBitmap}!rle\_get\_bitmap@{rle\_get\_bitmap}}
\index{rle\_get\_bitmap@{rle\_get\_bitmap}!GBitmap@{GBitmap}}
\doxysubsubsection{\texorpdfstring{rle\_get\_bitmap()}{rle\_get\_bitmap()}}
{\footnotesize\ttfamily void G\+Bitmap\+::rle\+\_\+get\+\_\+bitmap (\begin{DoxyParamCaption}\item[{const int}]{ncolumns,  }\item[{const unsigned char $\ast$\&}]{runs,  }\item[{unsigned char $\ast$}]{bitmap,  }\item[{const bool}]{invert }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Gets the bitmap line rle data passed. One line of pixel is stored one with 8 bits per \#unsigned char\# in an array. The array must be large enough to hold the whole line. ~\newline
 \mbox{\Hypertarget{classGBitmap_a6f24b1c6f4617bd91bf8d649246285a5}\label{classGBitmap_a6f24b1c6f4617bd91bf8d649246285a5}} 
\index{GBitmap@{GBitmap}!rle\_get\_bits@{rle\_get\_bits}}
\index{rle\_get\_bits@{rle\_get\_bits}!GBitmap@{GBitmap}}
\doxysubsubsection{\texorpdfstring{rle\_get\_bits()}{rle\_get\_bits()}}
{\footnotesize\ttfamily int G\+Bitmap\+::rle\+\_\+get\+\_\+bits (\begin{DoxyParamCaption}\item[{int}]{rowno,  }\item[{unsigned char $\ast$}]{bits }\end{DoxyParamCaption}) const}

Gets the pixels for line \#rowno\#. One line of pixel is stored as \#unsigned char\# values into array \#bits\#. Each pixel is either 1 or 0. The array must be large enough to hold the whole line. The number of pixels is returned. \mbox{\Hypertarget{classGBitmap_aed863414ad68f8a97f2d66793af4e1ad}\label{classGBitmap_aed863414ad68f8a97f2d66793af4e1ad}} 
\index{GBitmap@{GBitmap}!rle\_get\_rect@{rle\_get\_rect}}
\index{rle\_get\_rect@{rle\_get\_rect}!GBitmap@{GBitmap}}
\doxysubsubsection{\texorpdfstring{rle\_get\_rect()}{rle\_get\_rect()}}
{\footnotesize\ttfamily int G\+Bitmap\+::rle\+\_\+get\+\_\+rect (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classGRect}{G\+Rect}} \&}]{rect }\end{DoxyParamCaption}) const}

Gets the smallest rectangle enclosing black pixels. Rectangle rect gives the coordinates of the smallest rectangle containing all black pixels. Returns the number of black pixels. \mbox{\Hypertarget{classGBitmap_adeba63149e45bf7c3df0e727b624e0b6}\label{classGBitmap_adeba63149e45bf7c3df0e727b624e0b6}} 
\index{GBitmap@{GBitmap}!rle\_get\_runs@{rle\_get\_runs}}
\index{rle\_get\_runs@{rle\_get\_runs}!GBitmap@{GBitmap}}
\doxysubsubsection{\texorpdfstring{rle\_get\_runs()}{rle\_get\_runs()}}
{\footnotesize\ttfamily int G\+Bitmap\+::rle\+\_\+get\+\_\+runs (\begin{DoxyParamCaption}\item[{int}]{rowno,  }\item[{int $\ast$}]{rlens }\end{DoxyParamCaption}) const}

Gets the lengths of all runs in line \#rowno\#. The array \#rlens\# must be large enough to accomodate \#w+2\# integers where \#w\# is the number of columns in the image. These integers represent the lengths of consecutive runs of alternatively white or black pixels. Lengths can be zero in order to allow for lines starting with black pixels. This function returns the total number of runs in the line. \mbox{\Hypertarget{classGBitmap_a20ec1cdefbaacc08be5801c7f179a73c}\label{classGBitmap_a20ec1cdefbaacc08be5801c7f179a73c}} 
\index{GBitmap@{GBitmap}!rotate@{rotate}}
\index{rotate@{rotate}!GBitmap@{GBitmap}}
\doxysubsubsection{\texorpdfstring{rotate()}{rotate()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classGP}{GP}}$<$ \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} $>$ G\+Bitmap\+::rotate (\begin{DoxyParamCaption}\item[{int}]{count = {\ttfamily 0} }\end{DoxyParamCaption})}

Rotates bitmap by 90, 180 or 270 degrees anticlockwise and returns a new pixmap, input bitmap is not changed. count can be 1, 2, or 3 for 90, 180, 270 degree rotation. It returns the same bitmap if not rotated. The input bitmap will be uncompressed for rotation \mbox{\Hypertarget{classGBitmap_a26b93e377634a1d987891f76ede12f19}\label{classGBitmap_a26b93e377634a1d987891f76ede12f19}} 
\index{GBitmap@{GBitmap}!rows@{rows}}
\index{rows@{rows}!GBitmap@{GBitmap}}
\doxysubsubsection{\texorpdfstring{rows()}{rows()}}
{\footnotesize\ttfamily unsigned int G\+Bitmap\+::rows (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Returns the number of rows (the image height). \mbox{\Hypertarget{classGBitmap_adedb71b850f07744201ad0ee0a4756f7}\label{classGBitmap_adedb71b850f07744201ad0ee0a4756f7}} 
\index{GBitmap@{GBitmap}!rowsize@{rowsize}}
\index{rowsize@{rowsize}!GBitmap@{GBitmap}}
\doxysubsubsection{\texorpdfstring{rowsize()}{rowsize()}}
{\footnotesize\ttfamily unsigned int G\+Bitmap\+::rowsize (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Returns the size of a row in memory (in pixels). This number is equal to the difference between pointers to pixels located in the same column in consecutive rows. This difference can be larger than the number of columns in the image. \mbox{\Hypertarget{classGBitmap_ab08cbb17f67a1c04e3f5bcef3064d93a}\label{classGBitmap_ab08cbb17f67a1c04e3f5bcef3064d93a}} 
\index{GBitmap@{GBitmap}!save\_pbm@{save\_pbm}}
\index{save\_pbm@{save\_pbm}!GBitmap@{GBitmap}}
\doxysubsubsection{\texorpdfstring{save\_pbm()}{save\_pbm()}}
{\footnotesize\ttfamily void G\+Bitmap\+::save\+\_\+pbm (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classByteStream}{Byte\+Stream}} \&}]{bs,  }\item[{int}]{raw = {\ttfamily 1} }\end{DoxyParamCaption})}

Saves the image into \mbox{\hyperlink{classByteStream}{Byte\+Stream}} \#bs\# using the P\+BM format. Argument \#raw\# selects the {\ttfamily Raw P\+BM\textquotesingle{}\textquotesingle{} (1) or the}Ascii P\+BM\textquotesingle{}\textquotesingle{} (0) format. The image is saved as a bilevel image. All non zero pixels are considered black pixels. See section \textbackslash{}\+Ref\{P\+NM and R\+LE file formats\}. \mbox{\Hypertarget{classGBitmap_ae84537e31a15ce2a4cf64aefa73ef5f0}\label{classGBitmap_ae84537e31a15ce2a4cf64aefa73ef5f0}} 
\index{GBitmap@{GBitmap}!save\_pgm@{save\_pgm}}
\index{save\_pgm@{save\_pgm}!GBitmap@{GBitmap}}
\doxysubsubsection{\texorpdfstring{save\_pgm()}{save\_pgm()}}
{\footnotesize\ttfamily void G\+Bitmap\+::save\+\_\+pgm (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classByteStream}{Byte\+Stream}} \&}]{bs,  }\item[{int}]{raw = {\ttfamily 1} }\end{DoxyParamCaption})}

Saves the image into \mbox{\hyperlink{classByteStream}{Byte\+Stream}} \#bs\# using the P\+GM format. Argument \#raw\# selects the {\ttfamily Raw P\+GM\textquotesingle{}\textquotesingle{} (1) or the}Ascii P\+GM\textquotesingle{}\textquotesingle{} (0) format. The image is saved as a gray level image. See section \textbackslash{}\+Ref\{P\+NM and R\+LE file formats\}. \mbox{\Hypertarget{classGBitmap_a0f860c0b7817d1ed69950d068abe90bf}\label{classGBitmap_a0f860c0b7817d1ed69950d068abe90bf}} 
\index{GBitmap@{GBitmap}!save\_rle@{save\_rle}}
\index{save\_rle@{save\_rle}!GBitmap@{GBitmap}}
\doxysubsubsection{\texorpdfstring{save\_rle()}{save\_rle()}}
{\footnotesize\ttfamily void G\+Bitmap\+::save\+\_\+rle (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classByteStream}{Byte\+Stream}} \&}]{bs }\end{DoxyParamCaption})}

Saves the image into \mbox{\hyperlink{classByteStream}{Byte\+Stream}} \#bs\# using the R\+LE file format. The image is saved as a bilevel image. All non zero pixels are considered black pixels. See section \textbackslash{}\+Ref\{P\+NM and R\+LE file formats\}. \mbox{\Hypertarget{classGBitmap_a1f205dd8631d74fe66abbf8c8103953f}\label{classGBitmap_a1f205dd8631d74fe66abbf8c8103953f}} 
\index{GBitmap@{GBitmap}!set\_grays@{set\_grays}}
\index{set\_grays@{set\_grays}!GBitmap@{GBitmap}}
\doxysubsubsection{\texorpdfstring{set\_grays()}{set\_grays()}}
{\footnotesize\ttfamily void G\+Bitmap\+::set\+\_\+grays (\begin{DoxyParamCaption}\item[{int}]{grays }\end{DoxyParamCaption})}

Sets the number of gray levels without changing the pixels. Argument \#grays\# must be in range \#2\# to \#256\#. \mbox{\Hypertarget{classGBitmap_a01acec46ce509879747ade5858b96750}\label{classGBitmap_a01acec46ce509879747ade5858b96750}} 
\index{GBitmap@{GBitmap}!share@{share}}
\index{share@{share}!GBitmap@{GBitmap}}
\doxysubsubsection{\texorpdfstring{share()}{share()}}
{\footnotesize\ttfamily void G\+Bitmap\+::share (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Associates a \textbackslash{}\+Ref\{\mbox{\hyperlink{classGMonitor}{G\+Monitor}}\} with this bitmap. This function should be called on all bitmaps susceptible of being simultaneously used by several threads. It will make sure that function \textbackslash{}\+Ref\{monitor\} returns a pointer to a suitable monitor for this bitmap. \mbox{\Hypertarget{classGBitmap_ac8aab5b49b79f8454a2ca9864ce53680}\label{classGBitmap_ac8aab5b49b79f8454a2ca9864ce53680}} 
\index{GBitmap@{GBitmap}!take\_data@{take\_data}}
\index{take\_data@{take\_data}!GBitmap@{GBitmap}}
\doxysubsubsection{\texorpdfstring{take\_data()}{take\_data()}}
{\footnotesize\ttfamily unsigned char $\ast$ G\+Bitmap\+::take\+\_\+data (\begin{DoxyParamCaption}\item[{size\+\_\+t \&}]{offset }\end{DoxyParamCaption})}

Steals the memory buffer of a \mbox{\hyperlink{classGBitmap}{G\+Bitmap}}. This function returns the address of the memory buffer allocated by this \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} object. The offset of the first pixel in the bottom line is written into variable \#offset\#. Other lines can be accessed using pointer arithmetic (see \textbackslash{}\+Ref\{rowsize\}). The \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} object no longer \`{}`owns'\textquotesingle{} the buffer\+: you must explicitly de-\/allocate the buffer using \#operator delete \mbox{[}$\,$\mbox{]}\#. This de-\/allocation should take place after the destruction or the re-\/initialization of the \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} object. This function will return a null pointer if the \mbox{\hyperlink{classGBitmap}{G\+Bitmap}} object does not \`{}`own'\textquotesingle{} the buffer in the first place. ~\newline
 \mbox{\Hypertarget{classGBitmap_a2244bdca28d95f698759b690ad37d204}\label{classGBitmap_a2244bdca28d95f698759b690ad37d204}} 
\index{GBitmap@{GBitmap}!uncompress@{uncompress}}
\index{uncompress@{uncompress}!GBitmap@{GBitmap}}
\doxysubsubsection{\texorpdfstring{uncompress()}{uncompress()}}
{\footnotesize\ttfamily void G\+Bitmap\+::uncompress (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Decodes run-\/length encoded bitmaps and recreate the pixel array. This function is usually called by \mbox{\hyperlink{classGBitmap_a913f235312cacfca2ecb1e0bee28dd8b}{operator\mbox{[}$\,$\mbox{]}}}\# when needed. 

The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
libdjvu/G\+Bitmap.\+h\item 
libdjvu/G\+Bitmap.\+cpp\end{DoxyCompactItemize}
