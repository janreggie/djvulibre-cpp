\hypertarget{classZPCodec}{}\doxysection{Z\+P\+Codec Class Reference}
\label{classZPCodec}\index{ZPCodec@{ZPCodec}}


{\ttfamily \#include $<$Z\+P\+Codec.\+h$>$}



Inheritance diagram for Z\+P\+Codec\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=302pt]{classZPCodec__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for Z\+P\+Codec\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=276pt]{classZPCodec__coll__graph}
\end{center}
\end{figure}
\doxysubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{classZPCodec_1_1Decode}{Decode}}
\item 
class \mbox{\hyperlink{classZPCodec_1_1Encode}{Encode}}
\item 
struct \mbox{\hyperlink{structZPCodec_1_1Table}{Table}}
\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classZPCodec_a43cf91bd3a226a138b8badb80fba09da}\label{classZPCodec_a43cf91bd3a226a138b8badb80fba09da}} 
\mbox{\hyperlink{classZPCodec_a43cf91bd3a226a138b8badb80fba09da}{$\sim$\+Z\+P\+Codec}} ()
\begin{DoxyCompactList}\small\item\em Non-\/virtual destructor. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classZPCodec_a6d04c3b9c8da001ee747a43a89bf60d5}\label{classZPCodec_a6d04c3b9c8da001ee747a43a89bf60d5}} 
void {\bfseries newtable} (\mbox{\hyperlink{structZPCodec_1_1Table}{Z\+P\+Codec\+::\+Table}} $\ast$table)
\item 
\mbox{\Hypertarget{classZPCodec_aafe70a223f36c3d7a047670e5203f81d}\label{classZPCodec_aafe70a223f36c3d7a047670e5203f81d}} 
Bit\+Context {\bfseries state} (float prob1)
\end{DoxyCompactItemize}
\begin{Indent}\textbf{ Z\+P\+Codec.\+h}\par
{\em Files \#\char`\"{}\+Z\+P\+Codec.\+h\char`\"{}\# and \#\char`\"{}\+Z\+P\+Codec.\+cpp\char`\"{}\# implement a fast binary adaptive quasi-\/arithmetic coder named Z\+P-\/\+Coder. Because of its speed and convenience, the Z\+P-\/\+Coder is used in several parts of the Dj\+Vu reference library (See \textbackslash{}\+Ref\{\mbox{\hyperlink{BSByteStream_8h_source}{B\+S\+Byte\+Stream.\+h}}\}, \textbackslash{}\+Ref\{\mbox{\hyperlink{JB2Image_8h_source}{J\+B2\+Image.\+h}}\}, \textbackslash{}\+Ref\{\mbox{\hyperlink{IW44Image_8h_source}{I\+W44\+Image.\+h}}\}). The following comments avoid the theory (see the historical remarks for useful pointers) and concentrate on the user perspective on the Z\+P-\/\+Coder.

\{\textbackslash{}bf Introduction\} --- Encoding consists of transforming a sequence of \{{\itshape message} bits\} into a sequence of \{{\itshape code} bits\}. Decoding consists of retrieving the message bits using only the code bits. We can make the code smaller than the message as soon as we can predict a message bit on the basis of a \{{\itshape coding} context\} composed of previously encoded or decoded bits. If the prediction is always correct, we do not even need to encode the message bit. If the prediction is totally unreliable, we need to generate one code bit in order to unambiguously specify the message bit. In other words, the more reliable the prediction, the more compression we get.

The Z\+P-\/\+Coder handles prediction by means of \{{\itshape context} variables\} (see \textbackslash{}\+Ref\{Bit\+Context\}). There must be a context variable for each possible combination of context bits. Both the encoder and the decoder use same context variable for coding each message bit. For instance, we can code a binary image by successively coding all the pixels (the message bits) in row and column order. It is reasonable to assume that each pixel can be reasonably well predicted by looking at a few (say 10) neighboring pixels located above and to the left of the current pixel. Since these 10 pixels make 1024 combinations, we need 1024 context variables. Each pixel is encoded using the context variable corresponding to the values of the 10 neighboring pixels. Each pixel will be decoded by specifying the same context variable corresponding to the values of these 10 pixels. This is possible because these 10 pixels (located above and to the left) have already been decoded and therefore are known by the decoder program.

The context variables are initially set to zero, which mean that we do not know yet how to predict the current message bit on the basis of the context bits. While coding the message bits, the Z\+P-\/\+Coder automatically estimates the frequencies of \#0\#s and \#1\#s coded using each context variable. These frequencies actually provide a prediction (the most probable bit value) and an estimation of the prediction reliability (how often the prediction was correct in the past). All this statistical information is stored into the context variable after coding each bit. In other words, the more we code bits within a particular context, the better the Z\+P-\/\+Coder adapts its prediction model, and the more compression we can obtain.

All this adaptation works indeed because both the encoder program and the decoder program are always synchronized. Both the encoder and the decoder see the same message bits encoded (or decoded) with the same context variables. Both the encoder and the decoder apply the same rules to update the context variables and improve the predictors. Both the encoder and the decoder programs use the same predictors for any given message bit. The decoder could not work if this was not the case.

Just before encoding a message bit, all the context variables in the encoder program contain certain values. Just before decoding this message bit, all the context variables in the decoder program must contain the same values as for the encoder program. This is guaranteed as long as each prediction only depends on already coded bits\+: \{{\itshape the} coding context, on which the each prediction is based, must be composed of message bits which have already been coded. \}

\{\textbackslash{}bf Usage\} --- Once you know how to organize the predictions (i.\+e. which coding context to use, how many context variables to initialize, etc.), using the Z\+P-\/\+Coder is straightforward (see \textbackslash{}\+Ref\{\mbox{\hyperlink{classZPCodec}{Z\+P\+Codec}} Examples\})\+: \textbackslash{}begin\{itemize\} \textbackslash{}item The \{{\itshape encoder} program\} allocates context variables and initializes them to zero. It then constructs a \textbackslash{}\+Ref\{\mbox{\hyperlink{classZPCodec}{Z\+P\+Codec}}\} object for encoding. For each message bit, the encoder program retrieves the context bits, selects a context variable on the basis of the context bits and calls member function \textbackslash{}\+Ref\{\mbox{\hyperlink{classZPCodec_a254b08d83c5d9147983e1a58447acbf3}{Z\+P\+Codec\+::encoder}}\} with the message bit and a reference to the context variable. \textbackslash{}item The \{{\itshape decoder} program\} allocates context variables and initializes them to zero. It then constructs a \textbackslash{}\+Ref\{\mbox{\hyperlink{classZPCodec}{Z\+P\+Codec}}\} object for decoding. For each message bit, the decoder program retrieves the context bits, selects a context variable on the basis of the context bits and calls member function \textbackslash{}\+Ref\{\mbox{\hyperlink{classZPCodec_a88ded024d698c8616f6e49e246ab1fae}{Z\+P\+Codec\+::decoder}}\} with a reference to the context variable. This function returns the message bit. \textbackslash{}end\{itemize\} Functions \mbox{\hyperlink{classZPCodec_a254b08d83c5d9147983e1a58447acbf3}{encoder}}\# and \mbox{\hyperlink{classZPCodec_a88ded024d698c8616f6e49e246ab1fae}{decoder}}\# only require a few machine cycles to perform two essential tasks, namely \{{\itshape coding\}} and \{{\itshape context} adaptation\}. Function \mbox{\hyperlink{classZPCodec_a88ded024d698c8616f6e49e246ab1fae}{decoder}}\# often returns after two arithmetic operations only. To make your program fast, you just need to feed message bits and context variables fast enough.

\{\textbackslash{}bf History\} --- The Z\+P-\/\+Coder is similar in function and performance to the seminal Q-\/\+Coder (Pennebaker, Mitchell, Langdon, Arps, I\+BM J. Res Dev. 32, 1988). An improved version of the Q-\/\+Coder, named Q\+M-\/\+Coder, has been described in certain parts of the J\+P\+EG standard. Unfortunate patent policies have made these coders very difficult to use in general purpose applications. The Z-\/\+Coder is constructed using a new approach based on an extension of the Golomb codes (Bottou, Howard, Bengio, I\+E\+EE D\+CC 98, 1998 \textbackslash{}\+U\+RL\mbox{[}Dj\+Vu\mbox{]}\{\href{http://www.research.att.com/~leonb/DJVU/bottou-howard-bengio/}{\texttt{ http\+://www.\+research.\+att.\+com/$\sim$leonb/\+D\+J\+V\+U/bottou-\/howard-\/bengio/}}\} \textbackslash{}\+U\+RL\mbox{[}Post\+Script\mbox{]}\{\href{http://www.research.att.com/~leonb/PS/bottou-howard-bengio.ps.gz}{\texttt{ http\+://www.\+research.\+att.\+com/$\sim$leonb/\+P\+S/bottou-\/howard-\/bengio.\+ps.\+gz}}\}) This new approach does not infringe the Q\+M-\/\+Coder patents. Unfortunately the Z-\/\+Coder is dangerously close to the patented Arithmetic M\+EL Coder. Therefore we wrote the Z\+P-\/\+Coder (pronounce Zee-\/\+Prime Coder) which we believe is clear of legal problems. Needless to say, AT\&T has patents pending for both the Z-\/\+Coder and the Z\+P-\/\+Coder, licenced to Lizard\+Tech. The good news however is that we can grant a license to use the Z\+P-\/\+Coder in \`{}`free software'\textquotesingle{} without further complication. See the Copyright for more information.

@memo Binary adaptive quasi-\/arithmetic coder. \begin{DoxyAuthor}{Author}
L\textbackslash{}\textquotesingle{}eon Bottou \href{mailto:leonb@research.att.com}{\texttt{ leonb@research.\+att.\+com}} 
\end{DoxyAuthor}
}\begin{DoxyCompactItemize}
\item 
void \mbox{\hyperlink{classZPCodec_a254b08d83c5d9147983e1a58447acbf3}{encoder}} (int bit, Bit\+Context \&ctx)
\item 
int \mbox{\hyperlink{classZPCodec_a88ded024d698c8616f6e49e246ab1fae}{decoder}} (Bit\+Context \&ctx)
\item 
void \mbox{\hyperlink{classZPCodec_a1f8f6a3b5f586e2d96995932d89c0941}{encoder}} (int bit)
\item 
int \mbox{\hyperlink{classZPCodec_acfe938bd49e953c0b163721873092176}{decoder}} (void)
\item 
\mbox{\Hypertarget{classZPCodec_a6147a04997b33efd0c045cc5ebf07a49}\label{classZPCodec_a6147a04997b33efd0c045cc5ebf07a49}} 
void {\bfseries encoder\+\_\+nolearn} (int pix, Bit\+Context \&ctx)
\item 
\mbox{\Hypertarget{classZPCodec_a33011ef08511a0d3305156ad48c4b28a}\label{classZPCodec_a33011ef08511a0d3305156ad48c4b28a}} 
int {\bfseries decoder\+\_\+nolearn} (Bit\+Context \&ctx)
\item 
\mbox{\Hypertarget{classZPCodec_af123974e5623012109bfad7aa2b4979c}\label{classZPCodec_af123974e5623012109bfad7aa2b4979c}} 
int {\bfseries I\+Wdecoder} (void)
\item 
\mbox{\Hypertarget{classZPCodec_a0e7b3ac93092588625b64c0dc4e984c3}\label{classZPCodec_a0e7b3ac93092588625b64c0dc4e984c3}} 
void {\bfseries I\+Wencoder} (const bool bit)
\end{DoxyCompactItemize}
\end{Indent}
\doxysubsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \mbox{\hyperlink{classGP}{GP}}$<$ \mbox{\hyperlink{classZPCodec}{Z\+P\+Codec}} $>$ \mbox{\hyperlink{classZPCodec_a84098e668495d208f467c37ea3ac3049}{create}} (\mbox{\hyperlink{classGP}{GP}}$<$ \mbox{\hyperlink{classByteStream}{Byte\+Stream}} $>$ gbs, const bool encoding, const bool djvucompat=false)
\end{DoxyCompactItemize}
\doxysubsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classZPCodec_a4656438eb4fee5b2ef6a39b4162735b0}\label{classZPCodec_a4656438eb4fee5b2ef6a39b4162735b0}} 
{\bfseries Z\+P\+Codec} (\mbox{\hyperlink{classGP}{GP}}$<$ \mbox{\hyperlink{classByteStream}{Byte\+Stream}} $>$ gbs, const bool encoding, const bool djvucompat=false)
\item 
\mbox{\Hypertarget{classZPCodec_a260ef8a27a204a0f0eb9f98aabc9d959}\label{classZPCodec_a260ef8a27a204a0f0eb9f98aabc9d959}} 
void {\bfseries einit} (void)
\item 
\mbox{\Hypertarget{classZPCodec_a5f3aa7dc57e01b78e99118b3b4846ebc}\label{classZPCodec_a5f3aa7dc57e01b78e99118b3b4846ebc}} 
void {\bfseries eflush} (void)
\item 
\mbox{\Hypertarget{classZPCodec_a90868cf4c3984e9debeb4c198f07d2c1}\label{classZPCodec_a90868cf4c3984e9debeb4c198f07d2c1}} 
void {\bfseries outbit} (int bit)
\item 
\mbox{\Hypertarget{classZPCodec_a8c973e07d050754b1f6bc99579be59a0}\label{classZPCodec_a8c973e07d050754b1f6bc99579be59a0}} 
void {\bfseries zemit} (int b)
\item 
\mbox{\Hypertarget{classZPCodec_ade818d6181f01257acc2ee9c8d424823}\label{classZPCodec_ade818d6181f01257acc2ee9c8d424823}} 
void {\bfseries encode\+\_\+mps} (Bit\+Context \&ctx, unsigned int z)
\item 
\mbox{\Hypertarget{classZPCodec_acbd6c7b5042b53d0aea3a04f5c103a07}\label{classZPCodec_acbd6c7b5042b53d0aea3a04f5c103a07}} 
void {\bfseries encode\+\_\+lps} (Bit\+Context \&ctx, unsigned int z)
\item 
\mbox{\Hypertarget{classZPCodec_a5edf56accd8cba4ee9f55f9036a282f4}\label{classZPCodec_a5edf56accd8cba4ee9f55f9036a282f4}} 
void {\bfseries encode\+\_\+mps\+\_\+simple} (unsigned int z)
\item 
\mbox{\Hypertarget{classZPCodec_a1ed71325390bfd83a6cbf76f860fc757}\label{classZPCodec_a1ed71325390bfd83a6cbf76f860fc757}} 
void {\bfseries encode\+\_\+lps\+\_\+simple} (unsigned int z)
\item 
\mbox{\Hypertarget{classZPCodec_ab3d00c12cd229913c26bab0b553de164}\label{classZPCodec_ab3d00c12cd229913c26bab0b553de164}} 
void {\bfseries encode\+\_\+mps\+\_\+nolearn} (unsigned int z)
\item 
\mbox{\Hypertarget{classZPCodec_a1312747973ad2a43eafd0bb68c33d0fa}\label{classZPCodec_a1312747973ad2a43eafd0bb68c33d0fa}} 
void {\bfseries encode\+\_\+lps\+\_\+nolearn} (unsigned int z)
\item 
\mbox{\Hypertarget{classZPCodec_a420252a39550b344c17d6901a5a0ef8a}\label{classZPCodec_a420252a39550b344c17d6901a5a0ef8a}} 
void {\bfseries dinit} (void)
\item 
\mbox{\Hypertarget{classZPCodec_aff5d61f783d432889a8fcf6ffb3a09ac}\label{classZPCodec_aff5d61f783d432889a8fcf6ffb3a09ac}} 
void {\bfseries preload} (void)
\item 
\mbox{\Hypertarget{classZPCodec_a93b1369f1bfa9f5c07eee4ccfcc06cdb}\label{classZPCodec_a93b1369f1bfa9f5c07eee4ccfcc06cdb}} 
int {\bfseries ffz} (unsigned int x)
\item 
\mbox{\Hypertarget{classZPCodec_ab411ce77ee094d16e39d1788b6fe8c67}\label{classZPCodec_ab411ce77ee094d16e39d1788b6fe8c67}} 
int {\bfseries decode\+\_\+sub} (Bit\+Context \&ctx, unsigned int z)
\item 
\mbox{\Hypertarget{classZPCodec_a4e94e7eb24c2e5d53d65fe78b16c3fe4}\label{classZPCodec_a4e94e7eb24c2e5d53d65fe78b16c3fe4}} 
int {\bfseries decode\+\_\+sub\+\_\+simple} (int mps, unsigned int z)
\item 
\mbox{\Hypertarget{classZPCodec_a0b8f382425ee11acb805130b1abdef53}\label{classZPCodec_a0b8f382425ee11acb805130b1abdef53}} 
int {\bfseries decode\+\_\+sub\+\_\+nolearn} (int mps, unsigned int z)
\end{DoxyCompactItemize}
\doxysubsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classZPCodec_a44b926f2a7f449f7729395ceb89fcfbe}\label{classZPCodec_a44b926f2a7f449f7729395ceb89fcfbe}} 
\mbox{\hyperlink{classGP}{GP}}$<$ \mbox{\hyperlink{classByteStream}{Byte\+Stream}} $>$ {\bfseries gbs}
\item 
\mbox{\Hypertarget{classZPCodec_a842d18a53a5c4c98c3a0ceb50bb849f6}\label{classZPCodec_a842d18a53a5c4c98c3a0ceb50bb849f6}} 
\mbox{\hyperlink{classByteStream}{Byte\+Stream}} $\ast$ {\bfseries bs}
\item 
\mbox{\Hypertarget{classZPCodec_ac21ce70f12a79f8197eb844b65083fcf}\label{classZPCodec_ac21ce70f12a79f8197eb844b65083fcf}} 
const bool {\bfseries encoding}
\item 
\mbox{\Hypertarget{classZPCodec_a8df20f77744a1e9e56cb279e64b33975}\label{classZPCodec_a8df20f77744a1e9e56cb279e64b33975}} 
unsigned char {\bfseries byte}
\item 
\mbox{\Hypertarget{classZPCodec_ac81975965d427fea4d956bb5a75c3ab9}\label{classZPCodec_ac81975965d427fea4d956bb5a75c3ab9}} 
unsigned char {\bfseries scount}
\item 
\mbox{\Hypertarget{classZPCodec_ac8a7bf1e1e6cecf56d558bf7c60e9119}\label{classZPCodec_ac8a7bf1e1e6cecf56d558bf7c60e9119}} 
unsigned char {\bfseries delay}
\item 
\mbox{\Hypertarget{classZPCodec_ad1702b5b7c5396b31172eaeb9426197b}\label{classZPCodec_ad1702b5b7c5396b31172eaeb9426197b}} 
unsigned int {\bfseries a}
\item 
\mbox{\Hypertarget{classZPCodec_a5565bef8695fd7601d6faf4e62781546}\label{classZPCodec_a5565bef8695fd7601d6faf4e62781546}} 
unsigned int {\bfseries code}
\item 
\mbox{\Hypertarget{classZPCodec_a3d283ec3b0418afd28e8612b630ff7fc}\label{classZPCodec_a3d283ec3b0418afd28e8612b630ff7fc}} 
unsigned int {\bfseries fence}
\item 
\mbox{\Hypertarget{classZPCodec_ae6eb6463848faf94be8884d0c746598e}\label{classZPCodec_ae6eb6463848faf94be8884d0c746598e}} 
unsigned int {\bfseries subend}
\item 
\mbox{\Hypertarget{classZPCodec_a18f21a46dd6a567898c3e8bfff5feafb}\label{classZPCodec_a18f21a46dd6a567898c3e8bfff5feafb}} 
unsigned int {\bfseries buffer}
\item 
\mbox{\Hypertarget{classZPCodec_aef481d430cc939f88af045a730e17e64}\label{classZPCodec_aef481d430cc939f88af045a730e17e64}} 
unsigned int {\bfseries nrun}
\item 
\mbox{\Hypertarget{classZPCodec_a3adff4e52cd916317e258ac86f673537}\label{classZPCodec_a3adff4e52cd916317e258ac86f673537}} 
unsigned int {\bfseries p} \mbox{[}256\mbox{]}
\item 
\mbox{\Hypertarget{classZPCodec_afeb64b12ad539dfc0219b511d591dc07}\label{classZPCodec_afeb64b12ad539dfc0219b511d591dc07}} 
unsigned int {\bfseries m} \mbox{[}256\mbox{]}
\item 
\mbox{\Hypertarget{classZPCodec_a1202d8ca9b67034868b37a2d92dfbc96}\label{classZPCodec_a1202d8ca9b67034868b37a2d92dfbc96}} 
Bit\+Context {\bfseries up} \mbox{[}256\mbox{]}
\item 
\mbox{\Hypertarget{classZPCodec_a3a95c14a58595fa73197c9614396db3e}\label{classZPCodec_a3a95c14a58595fa73197c9614396db3e}} 
Bit\+Context {\bfseries dn} \mbox{[}256\mbox{]}
\item 
\mbox{\Hypertarget{classZPCodec_a096deb10bffa077aff9fa52d1bed2332}\label{classZPCodec_a096deb10bffa077aff9fa52d1bed2332}} 
char {\bfseries ffzt} \mbox{[}256\mbox{]}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Performs Z\+P-\/\+Coder encoding and decoding. A \mbox{\hyperlink{classZPCodec}{Z\+P\+Codec}} object must either constructed for encoding or for decoding. The \mbox{\hyperlink{classZPCodec}{Z\+P\+Codec}} object is connected with a \textbackslash{}\+Ref\{\mbox{\hyperlink{classByteStream}{Byte\+Stream}}\} object specified at construction time. A \mbox{\hyperlink{classZPCodec}{Z\+P\+Codec}} object constructed for decoding reads code bits from the \mbox{\hyperlink{classByteStream}{Byte\+Stream}} and returns a message bit whenever function \textbackslash{}\+Ref\{decoder\} is called. A \mbox{\hyperlink{classZPCodec}{Z\+P\+Codec}} constructed for encoding processes the message bits provided by function \textbackslash{}\+Ref\{encoder\} and writes the corresponding code bits to \mbox{\hyperlink{classByteStream}{Byte\+Stream}} \#bs\#.

You should never directly access a \mbox{\hyperlink{classByteStream}{Byte\+Stream}} object connected to a valid \mbox{\hyperlink{classZPCodec}{Z\+P\+Codec}} object. The most direct way to access the \mbox{\hyperlink{classByteStream}{Byte\+Stream}} object consists of using the \char`\"{}pass-\/thru\char`\"{} versions of functions \textbackslash{}\+Ref\{encoder\} and \textbackslash{}\+Ref\{decoder\}.

The \mbox{\hyperlink{classByteStream}{Byte\+Stream}} object can be accessed again after the destruction of the \mbox{\hyperlink{classZPCodec}{Z\+P\+Codec}} object. Note that the encoder always flushes its internal buffers and writes a few final code bytes when the \mbox{\hyperlink{classZPCodec}{Z\+P\+Codec}} object is destroyed. Note also that the decoder often reads a few bytes beyond the last code byte written by the encoder. This lag means that you must reposition the \mbox{\hyperlink{classByteStream}{Byte\+Stream}} after the destruction of the \mbox{\hyperlink{classZPCodec}{Z\+P\+Codec}} object and before re-\/using the \mbox{\hyperlink{classByteStream}{Byte\+Stream}} object (see \textbackslash{}\+Ref\{\mbox{\hyperlink{classIFFByteStream}{I\+F\+F\+Byte\+Stream}}\}.)

Please note also that the decoder has no way to reliably indicate the end of the message bit sequence. The content of the message must be designed in a way which indicates when to stop decoding. Simple ways to achieve this consists of announcing the message length at the beginning (like a pascal style string), or of defining a termination code (like a null terminated string). ~\newline
 

\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{classZPCodec_a84098e668495d208f467c37ea3ac3049}\label{classZPCodec_a84098e668495d208f467c37ea3ac3049}} 
\index{ZPCodec@{ZPCodec}!create@{create}}
\index{create@{create}!ZPCodec@{ZPCodec}}
\doxysubsubsection{\texorpdfstring{create()}{create()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classGP}{GP}}$<$ \mbox{\hyperlink{classZPCodec}{Z\+P\+Codec}} $>$ Z\+P\+Codec\+::create (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classGP}{GP}}$<$ \mbox{\hyperlink{classByteStream}{Byte\+Stream}} $>$}]{gbs,  }\item[{const bool}]{encoding,  }\item[{const bool}]{djvucompat = {\ttfamily false} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Constructs a Z\+P-\/\+Coder. If argument \#encoding\# is zero, the Z\+P-\/\+Coder object will read code bits from the \mbox{\hyperlink{classByteStream}{Byte\+Stream}} \#bs\# and return a message bit whenever function \mbox{\hyperlink{classZPCodec_a88ded024d698c8616f6e49e246ab1fae}{decoder}}\# is called. If flag \#encoding\# is set the Z\+P-\/\+Coder object will process the message bits provided by function \mbox{\hyperlink{classZPCodec_a254b08d83c5d9147983e1a58447acbf3}{encoder}}\# and write code bits to \mbox{\hyperlink{classByteStream}{Byte\+Stream}} \#bs\#. Optional flag \#djvucompat\# selects a slightly less efficient adaptation table which is used by the Dj\+Vu project. This is required in order to ensure the bitstream compatibility. You should not use this flag unless you want to decode J\+B2, I\+W44 or B\+ZZ encoded data. \mbox{\Hypertarget{classZPCodec_a88ded024d698c8616f6e49e246ab1fae}\label{classZPCodec_a88ded024d698c8616f6e49e246ab1fae}} 
\index{ZPCodec@{ZPCodec}!decoder@{decoder}}
\index{decoder@{decoder}!ZPCodec@{ZPCodec}}
\doxysubsubsection{\texorpdfstring{decoder()}{decoder()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily int Z\+P\+Codec\+::decoder (\begin{DoxyParamCaption}\item[{Bit\+Context \&}]{ctx }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Decodes a bit using context variable \#ctx\#. This function should only be used with Z\+P-\/\+Coder objects created for decoding. It may modify the contents of variable \#ctx\# in order to perform context adaptation. \mbox{\Hypertarget{classZPCodec_acfe938bd49e953c0b163721873092176}\label{classZPCodec_acfe938bd49e953c0b163721873092176}} 
\index{ZPCodec@{ZPCodec}!decoder@{decoder}}
\index{decoder@{decoder}!ZPCodec@{ZPCodec}}
\doxysubsubsection{\texorpdfstring{decoder()}{decoder()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily int Z\+P\+Codec\+::decoder (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Decodes a bit without compression (pass-\/thru decoder). This function retrieves bits encoded with the pass-\/thru encoder. \mbox{\Hypertarget{classZPCodec_a1f8f6a3b5f586e2d96995932d89c0941}\label{classZPCodec_a1f8f6a3b5f586e2d96995932d89c0941}} 
\index{ZPCodec@{ZPCodec}!encoder@{encoder}}
\index{encoder@{encoder}!ZPCodec@{ZPCodec}}
\doxysubsubsection{\texorpdfstring{encoder()}{encoder()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void Z\+P\+Codec\+::encoder (\begin{DoxyParamCaption}\item[{int}]{bit }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Encodes bit \#bit\# without compression (pass-\/thru encoder). Argument \#bit\# must be \#0\# or \#1\#. No compression will be applied. Calling this function always increases the length of the code bit sequence by one bit. \mbox{\Hypertarget{classZPCodec_a254b08d83c5d9147983e1a58447acbf3}\label{classZPCodec_a254b08d83c5d9147983e1a58447acbf3}} 
\index{ZPCodec@{ZPCodec}!encoder@{encoder}}
\index{encoder@{encoder}!ZPCodec@{ZPCodec}}
\doxysubsubsection{\texorpdfstring{encoder()}{encoder()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void Z\+P\+Codec\+::encoder (\begin{DoxyParamCaption}\item[{int}]{bit,  }\item[{Bit\+Context \&}]{ctx }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Encodes bit \#bit\# using context variable \#ctx\#. Argument \#bit\# must be \#0\# or \#1\#. This function should only be used with Z\+P-\/\+Coder objects created for encoding. It may modify the contents of variable \#ctx\# in order to perform context adaptation. 

The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
libdjvu/Z\+P\+Codec.\+h\item 
libdjvu/Z\+P\+Codec.\+cpp\end{DoxyCompactItemize}
